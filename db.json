{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/image/liutao01.jpg","path":"image/liutao01.jpg","modified":1,"renderable":0},{"_id":"source/image/liutao02.jpg","path":"image/liutao02.jpg","modified":1,"renderable":0},{"_id":"source/image/liutao03.gif","path":"image/liutao03.gif","modified":1,"renderable":0},{"_id":"themes/hiker/source/css/archive.css","path":"css/archive.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/dialog.css","path":"css/dialog.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/header-post.css","path":"css/header-post.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/home.css","path":"css/home.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/vdonate.css","path":"css/vdonate.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/dialog.js","path":"js/dialog.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/home.js","path":"js/home.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/insight.js","path":"js/insight.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/scripts.js","path":"js/scripts.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/vdonate.js","path":"js/vdonate.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/browser-support.png","path":"preview/browser-support.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/donation-btn.png","path":"preview/donation-btn.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/preview-abstract.png","path":"preview/preview-abstract.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/theme-color.png","path":"preview/theme-color.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/bootstrap.js","path":"js/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/js/jquery-3.1.1.min.js","path":"js/jquery-3.1.1.min.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/bootstrap.css","path":"css/bootstrap.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.eot","path":"css/fonts/glyphicons-halflings-regular.eot","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.ttf","path":"css/fonts/glyphicons-halflings-regular.ttf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.woff","path":"css/fonts/glyphicons-halflings-regular.woff","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.woff2","path":"css/fonts/glyphicons-halflings-regular.woff2","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/avatar.jpg","path":"css/images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/homelogo.jpg","path":"css/images/homelogo.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/mylogo.jpg","path":"css/images/mylogo.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/rocket.png","path":"css/images/rocket.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/setting.jpg","path":"css/images/setting.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FuturaPTBook.otf","path":"css/fonts/FuturaPTBook.otf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FuturaPTMedium.otf","path":"css/fonts/FuturaPTMedium.otf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FuturaPTBold.otf","path":"css/fonts/FuturaPTBold.otf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FuturaPTBoldOblique.otf","path":"css/fonts/FuturaPTBoldOblique.otf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/FuturaPTBookOblique.otf","path":"css/fonts/FuturaPTBookOblique.otf","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.svg","path":"css/fonts/glyphicons-halflings-regular.svg","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/preview-mobile.png","path":"preview/preview-mobile.png","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/home-bg.jpg","path":"css/images/home-bg.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/css/images/pose.jpg","path":"css/images/pose.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/code-theme.jpg","path":"preview/code-theme.jpg","modified":1,"renderable":1},{"_id":"themes/hiker/source/preview/preview-pc.png","path":"preview/preview-pc.png","modified":1,"renderable":1}],"Cache":[{"_id":"themes/hiker/.gitignore","hash":"ea2b285a29690f1eabbad0f3a158e34e9ccd1d86","modified":1568771020016},{"_id":"themes/hiker/.travis.yml","hash":"7ed5eb33c899eb49ec323f7ed7ee431bea52bf4f","modified":1568771020017},{"_id":"themes/hiker/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1568771020017},{"_id":"themes/hiker/LICENSE","hash":"df913ae888823f1551d5f1837902f7ccb2634459","modified":1568771020018},{"_id":"themes/hiker/README.cn.md","hash":"4df3101e2e77865b2cb5913fe7f7e3feff81e6f5","modified":1568771020019},{"_id":"themes/hiker/README.md","hash":"2bc2899d048e6df9dff5ad01bdf550bb6a158e24","modified":1568771020019},{"_id":"themes/hiker/_config.yml","hash":"d5fd4a3bed1008d5cdd3ee08d42e65d5b55e4c39","modified":1573281713405},{"_id":"themes/hiker/package.json","hash":"5800ffd530e6ec7fb9e3f261b5e3a1286c2b54f6","modified":1568771020076},{"_id":"source/_posts/==的隐式转换.md","hash":"9f776329fc38e07ba50252ee2112f763b7a7cf54","modified":1569305449296},{"_id":"source/_posts/JavaScript中深拷贝与浅拷贝的理解.md","hash":"3a46fe7335969891156b4fad5f571c32b0768caf","modified":1570503458487},{"_id":"source/_posts/SPA的前世今生.md","hash":"0b73f0e51008a9a4c7b49afe13cecd2d095eefd4","modified":1573281713402},{"_id":"source/_posts/call apply bind的区别和用法.md","hash":"efbcea09650aeacef5d438bbccbf7437cbab1878","modified":1568771020008},{"_id":"source/_posts/cookie、localstorage和sessionstorage三者之间的区别以及使用方式.md","hash":"1b55ae8013f5d9c123c315ef2e9d18fffe8493a3","modified":1568771020009},{"_id":"source/_posts/gulp入门（一）.md","hash":"91458981746d178ac70ef569bf138cefde1979c4","modified":1573715854309},{"_id":"source/_posts/gulp入门（三）.md","hash":"c93a7a2644179ba3b831cbfb3dba8afa7a27e0ef","modified":1573715854299},{"_id":"source/_posts/gulp入门（二）.md","hash":"2d78b34e27ebf506864032dfb1fa5648f9ed0538","modified":1573715854307},{"_id":"source/_posts/javascript中的Map.md","hash":"fca60fea114aacfd5b1d9068f9ff26112ee157a6","modified":1569305449296},{"_id":"source/_posts/javascript垃圾回收机制.md","hash":"b8fb93ae09e31dd51c210e40dd4989542594a0c4","modified":1568771020011},{"_id":"source/_posts/vue双向数据绑定原理.md","hash":"ea7b108c6e23fef2d3e1f14b1a2619b2158d4bb8","modified":1573281713403},{"_id":"source/_posts/web前端常见的安全问题.md","hash":"cbb50e33f6795adbfffcd17b4d9d65d6bcc3e9c8","modified":1573623412592},{"_id":"source/_posts/什么是BFC.md","hash":"427e9160d4111ff5ffec209b36946cc0d7124b08","modified":1570082251166},{"_id":"source/_posts/使用console进行-性能测试-和-计算代码运行时间.md","hash":"94f67a212980221bff8e35ab7057e7b2a1d3d315","modified":1571746159569},{"_id":"source/_posts/前端性能优化一-性能指标.md","hash":"6e2e3d552a161b56416c42b4a045b34535cf7afa","modified":1568771020012},{"_id":"source/_posts/如何为平台设计一个插件系统.md","hash":"ad834664f662fcb091f167f05d6a2092899dc560","modified":1568771020013},{"_id":"source/_posts/如何在nuxt中使用Vuex做登陆管理.md","hash":"5b451ebcb9938580eb4af318c9f796ce5e8773b9","modified":1573281713404},{"_id":"source/_posts/如何理解ES6中Promise.md","hash":"853ca27fbe227293eaa9ed8b5f3b9402de45e331","modified":1571746428084},{"_id":"source/_posts/对于Javascript执行上下文的理解.md","hash":"ccb4db301395cafe86bc2a6b4a84a7f28697d811","modified":1570669723908},{"_id":"source/_posts/浅谈v-slot.md","hash":"21f2d2a17694d71699b18ff27a67929956307f34","modified":1573715762806},{"_id":"source/_posts/网页禁止审查及一些简单禁止用户对页面操作.md","hash":"e8995f9d87968be93424fa0328d18448ea661930","modified":1573281713404},{"_id":"source/_posts/谈谈前端路由.md","hash":"5389e5f5ded2e8d7d202489e7320a817529be678","modified":1569305449296},{"_id":"source/_posts/闭包的概念与应用.md","hash":"8c72403d007003ab7196c4b300b9295856a5f88f","modified":1570500004365},{"_id":"source/categories/index.md","hash":"7109745f4ef12f687440b8ce120f2ca065b7e944","modified":1568771020014},{"_id":"source/image/liutao01.jpg","hash":"b3a2b12b09d73008fe795e527d152d07572c4f96","modified":1569292899638},{"_id":"source/image/liutao02.jpg","hash":"870c5c7742359e75ac92803a67c2fa44bdbc0b93","modified":1569294130923},{"_id":"source/image/liutao03.gif","hash":"2bfdd4ce07a220efcf7c731a664b63425bb444bf","modified":1569294431381},{"_id":"source/tags/index.md","hash":"2dbfacae0a629bc49d68fb3d397188cd117db81e","modified":1568771020015},{"_id":"themes/hiker/languages/de.yml","hash":"df34667b1ee138061bab8e18afdd36b5d6bc4c64","modified":1568771020021},{"_id":"themes/hiker/languages/default.yml","hash":"c6cae9c884f18037528859aeffe8ebf71ad61a0d","modified":1568771020021},{"_id":"themes/hiker/languages/en.yml","hash":"c6cae9c884f18037528859aeffe8ebf71ad61a0d","modified":1568771020022},{"_id":"themes/hiker/languages/es.yml","hash":"0f954201f1fb771c433318fe629bdf1fd04b9f16","modified":1568771020022},{"_id":"themes/hiker/languages/fr.yml","hash":"a8c93cab64270fa6ed93b69e69451be134e09405","modified":1568771020023},{"_id":"themes/hiker/languages/nl.yml","hash":"03e752a18b6acc37cda39618ccd3e1deff12db81","modified":1568771020024},{"_id":"themes/hiker/languages/no.yml","hash":"21ae751ff478ac75d7b8fa7f1ffaed91e2f9ab19","modified":1568771020024},{"_id":"themes/hiker/languages/pt.yml","hash":"63a7c432f11af69467361ee680b9d0c5d754459a","modified":1568771020025},{"_id":"themes/hiker/languages/ru.yml","hash":"1ddf1cbdf5622feda11b49375254bbb68aed66ad","modified":1568771020026},{"_id":"themes/hiker/languages/zh-CN.yml","hash":"f39a36603a8ec5a99f659f5c6b8edd045143b76f","modified":1568771020026},{"_id":"themes/hiker/languages/zh-TW.yml","hash":"0c0c48f908f17b3c7602bd544c844b188d4cd717","modified":1568771020027},{"_id":"themes/hiker/layout/archive.ejs","hash":"fff20dc39a59641b35bbc921866921375ef584a5","modified":1568771020068},{"_id":"themes/hiker/layout/categories.ejs","hash":"5e8ec5304c76f80bcecb710d83c3dead4cab8a2a","modified":1568771020068},{"_id":"themes/hiker/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1568771020069},{"_id":"themes/hiker/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1568771020070},{"_id":"themes/hiker/layout/layout.ejs","hash":"f4e7d8cdf47f654f8c011ae21bc77f2c71219861","modified":1568771020070},{"_id":"themes/hiker/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1568771020071},{"_id":"themes/hiker/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1568771020071},{"_id":"themes/hiker/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1568771020075},{"_id":"themes/hiker/layout/tags.ejs","hash":"f1f8530e856cb7e7bfed044d2117a4d8b374709a","modified":1568771020076},{"_id":"themes/hiker/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1568771020077},{"_id":"themes/hiker/layout/_partial/after-footer.ejs","hash":"cb3e2715acd7fdde1d4c7d439dec6cae71179887","modified":1568771020028},{"_id":"themes/hiker/layout/_partial/archive-post.ejs","hash":"7f17ae361df4071091b37fe1420247523d20ed90","modified":1568771020029},{"_id":"themes/hiker/layout/_partial/archive.ejs","hash":"11290e1529e50fe7c8953e26e61477635bb4d501","modified":1568771020029},{"_id":"themes/hiker/layout/_partial/article.ejs","hash":"a83f159c30b2008c48be88d0d6827fd79066e7e4","modified":1568785052122},{"_id":"themes/hiker/layout/_partial/baidu-analytics.ejs","hash":"335749b60b4274d9751bac8baf39d69f424930fd","modified":1568771020031},{"_id":"themes/hiker/layout/_partial/busuanzi-analytics.ejs","hash":"539549eeebe53abd1efc6903c11403c618c57810","modified":1568771020031},{"_id":"themes/hiker/layout/_partial/cnzz-analytics.ejs","hash":"1d6f7c86f5b0f2a7636caace94bef3ed12309dce","modified":1568771020032},{"_id":"themes/hiker/layout/_partial/comment.ejs","hash":"5102c373b39985087854091b7b9f056fe0ba9a1b","modified":1568771020032},{"_id":"themes/hiker/layout/_partial/copyright.ejs","hash":"73d1b18b1f572f10121b85795b69b947bfc56419","modified":1568771020033},{"_id":"themes/hiker/layout/_partial/donate.ejs","hash":"ce2dc1ca23cc12a6b91651aaf7845508ab95832f","modified":1568771020034},{"_id":"themes/hiker/layout/_partial/dialog.ejs","hash":"1b38de12939c21906c66f2fde16b2bc86b23c673","modified":1568771020033},{"_id":"themes/hiker/layout/_partial/facebook-sdk.ejs","hash":"8fc5cf7abbfd587057fb86ee028c7f216d30d68c","modified":1568771020035},{"_id":"themes/hiker/layout/_partial/footer.ejs","hash":"d2949d40f7aac65d2ac8426f5099eded12a5ec94","modified":1568771020035},{"_id":"themes/hiker/layout/_partial/gauges-analytics.ejs","hash":"ace3000bd3e01d03041d5be24f7640b6c003a5b5","modified":1568771020036},{"_id":"themes/hiker/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1568771020036},{"_id":"themes/hiker/layout/_partial/head.ejs","hash":"f4738161853263d673520320f725c39a7130548f","modified":1568771020037},{"_id":"themes/hiker/layout/_partial/header-post.ejs","hash":"daf3ba44792f119c437d8c0915d3554d43fa921b","modified":1573281713406},{"_id":"themes/hiker/layout/_partial/header.ejs","hash":"7d894fc61023289609006a2b03ba255edd722efa","modified":1568771020038},{"_id":"themes/hiker/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1568771020047},{"_id":"themes/hiker/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1568771020062},{"_id":"themes/hiker/layout/_partial/tencent-analytics.ejs","hash":"0aa56b1efa4a360be687c0e0b9aafd865f53c995","modified":1568771020063},{"_id":"themes/hiker/layout/_widget/archive.ejs","hash":"856a6352a0f8d55f3d2965eea8ad4ec517f6af96","modified":1568771020064},{"_id":"themes/hiker/layout/_widget/category.ejs","hash":"866790acc13fed44b7ef74c3e19c300a3d6180d8","modified":1568771020064},{"_id":"themes/hiker/layout/_widget/curtains.ejs","hash":"d96be843847211664b83b786bfee43fa2f897616","modified":1568771020065},{"_id":"themes/hiker/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1568771020065},{"_id":"themes/hiker/layout/_widget/social.ejs","hash":"5719baf6cee0ddd97a0a61351d5d107257531504","modified":1568771020066},{"_id":"themes/hiker/layout/_widget/tag.ejs","hash":"6017c54a8c3c8ff8db491cfbea3100c139da75d6","modified":1568771020067},{"_id":"themes/hiker/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1568771020067},{"_id":"themes/hiker/layout/search/baidu.ejs","hash":"8cc6f6e601b14d310f20eaf29dc55d6c60ab4ee4","modified":1568771020072},{"_id":"themes/hiker/layout/search/index-mobile.ejs","hash":"8e2e28b37a908f60e4953bf9175a7af329d15d40","modified":1568771020073},{"_id":"themes/hiker/layout/search/index.ejs","hash":"48e0d133a808000a60a4ce0d673737c37be2410d","modified":1568771020073},{"_id":"themes/hiker/layout/search/insight.ejs","hash":"5205e75f0ceedc38e2bd9904464324ce179b8e25","modified":1568771020074},{"_id":"themes/hiker/layout/search/swiftype.ejs","hash":"cce9c44180d9490f45b30b8f052ac82675a9d66a","modified":1568771020074},{"_id":"themes/hiker/source/css/_extend.styl","hash":"3c4dd93884eb25385d837fb975bb311a639ecc1d","modified":1568771020079},{"_id":"themes/hiker/source/css/_variables.styl","hash":"cbb703c722fb98b2f08cc803e8b954acdf7b5522","modified":1568771020088},{"_id":"themes/hiker/source/css/archive.css","hash":"6e7e24bc6c356fe83833ceb73986036248d2892c","modified":1568771020089},{"_id":"themes/hiker/source/css/dialog.css","hash":"c248717aecf61b42e2bbfece61140a5c44911b4b","modified":1568771020098},{"_id":"themes/hiker/source/css/header-post.css","hash":"18e6e212ae21df9dfa9a7f20b5eba798b151230c","modified":1568771020118},{"_id":"themes/hiker/source/css/home.css","hash":"89668f263471706473350dc39d6621162f6648ac","modified":1568771020119},{"_id":"themes/hiker/source/css/style.styl","hash":"f6711414b8a161ff46b980d8b135d861feb97b7f","modified":1568771020132},{"_id":"themes/hiker/source/css/vdonate.css","hash":"b43acd89a3d87725d6496a4f780dcf5eb576f866","modified":1568771020133},{"_id":"themes/hiker/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1568771020133},{"_id":"themes/hiker/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1568771020134},{"_id":"themes/hiker/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1568771020135},{"_id":"themes/hiker/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1568771020135},{"_id":"themes/hiker/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1568771020136},{"_id":"themes/hiker/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1568771020137},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1568771020141},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1568771020142},{"_id":"themes/hiker/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1568771020143},{"_id":"themes/hiker/source/js/dialog.js","hash":"f982934062fd6b2b385d1b6a6f7fbe4510087210","modified":1568771020145},{"_id":"themes/hiker/source/js/home.js","hash":"6534b583d310c57c49cb16aa75f6f33e9af41a92","modified":1568771020146},{"_id":"themes/hiker/source/js/insight.js","hash":"d09a22f5dc23d79c198d3945b4139c9359ba1ab3","modified":1568771020146},{"_id":"themes/hiker/source/js/scripts.js","hash":"7b8531f6fdfeb1590cf096fbf913a63c66e5bbef","modified":1568771020148},{"_id":"themes/hiker/source/js/totop.js","hash":"aefa54321fdacd48537be444215bcb8df9190c3b","modified":1568771020149},{"_id":"themes/hiker/source/js/vdonate.js","hash":"a3482fae4f782028e7faa090f2f001ad9bca05e5","modified":1568771020149},{"_id":"themes/hiker/source/preview/browser-support.png","hash":"a6d8498553550c6b18a8f22bcd2f53c993c7d677","modified":1568771020150},{"_id":"themes/hiker/source/preview/donation-btn.png","hash":"ad78b1605b162e2399a1cdc5232f6a44298dba6c","modified":1568771020158},{"_id":"themes/hiker/source/preview/preview-abstract.png","hash":"3d18ad9ba38fe24770ba6758d8f1bb242f669ce3","modified":1568771020159},{"_id":"themes/hiker/source/preview/theme-color.png","hash":"725130ceea5e41bb2cc60b31e45275b4b0cc77b3","modified":1568771020168},{"_id":"themes/hiker/source/js/bootstrap.js","hash":"474b25cebd06d57a38090c6716d5dfaa5591baad","modified":1568771020145},{"_id":"themes/hiker/source/js/jquery-3.1.1.min.js","hash":"042dd055cd289215835a58507c9531f808e1648a","modified":1568771020148},{"_id":"themes/hiker/layout/_partial/post/author.ejs","hash":"257866bf6cc1ffd106b7f9bf794bd2bfb4f20f63","modified":1568785052122},{"_id":"themes/hiker/layout/_partial/post/category.ejs","hash":"692c4fab11b31adce8f724f51203bec6ea759b9a","modified":1568771020056},{"_id":"themes/hiker/layout/_partial/post/busuanzi-analytics.ejs","hash":"b282fb7e646dfe02dc89e7e786f233a6700dc808","modified":1568771020055},{"_id":"themes/hiker/layout/_partial/post/date.ejs","hash":"cc160cd537a966c6ecb3c73c4a44207f254b0461","modified":1568771020058},{"_id":"themes/hiker/layout/_partial/post/edit.ejs","hash":"3ec3c6502d2ced9140c132492d52ceaac6c4c05d","modified":1568771020058},{"_id":"themes/hiker/layout/_partial/post/gallery.ejs","hash":"bfde040b4c4a8ce43645e0783cdd2b944269ec80","modified":1568771020059},{"_id":"themes/hiker/layout/_partial/post/mathjax.ejs","hash":"0199c323b8ecebef7ebfa8914e49b6d1e236ad71","modified":1568771020059},{"_id":"themes/hiker/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1568771020060},{"_id":"themes/hiker/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1568771020061},{"_id":"themes/hiker/layout/_partial/post/title.ejs","hash":"9ee31f67ad337d5dcaaa10aa8ba55c7c22074b1c","modified":1568771020061},{"_id":"themes/hiker/layout/_partial/post/urlconvert.ejs","hash":"2133f1029632417f9043b9d4749d580ed0c75db0","modified":1568771020061},{"_id":"themes/hiker/source/css/_partial/archive.styl","hash":"b16abc653626645f570d48aca094e6d0ca1f231d","modified":1568771020080},{"_id":"themes/hiker/source/css/_partial/article.styl","hash":"b1fa3a44c3aa2e80ab12af7019d60b43561e64f8","modified":1568785052124},{"_id":"themes/hiker/source/css/_partial/comment.styl","hash":"43279aaaa00cc07b4a65b13ef01c391355e82717","modified":1568771020081},{"_id":"themes/hiker/source/css/_partial/footer.styl","hash":"203c03d670a6fd434efdb1d9047166db7d6d874b","modified":1568771020082},{"_id":"themes/hiker/source/css/_partial/header-post.styl","hash":"81539c15e42c40e1ffbc36952e4617e17fdbba9c","modified":1568771020082},{"_id":"themes/hiker/source/css/_partial/header.styl","hash":"5686f062d84928ceec78efbd01dba59609437efb","modified":1568771020083},{"_id":"themes/hiker/source/css/_partial/highlight.styl","hash":"4a1e3bcb26ff291704283effb9ec22e8967c4bba","modified":1568771020083},{"_id":"themes/hiker/source/css/_partial/insight.styl","hash":"3b4042ebff85ded51eccd6183bad812d9aeef844","modified":1568771020084},{"_id":"themes/hiker/source/css/_partial/mobile.styl","hash":"3920e4c3cd11f294d3e7835ed628f169cbea6b21","modified":1568771020085},{"_id":"themes/hiker/source/css/_partial/sidebar-aside.styl","hash":"4f323b13a7594a46b5b21a9052bbdb7fb5144411","modified":1568771020085},{"_id":"themes/hiker/source/css/_partial/sidebar-bottom.styl","hash":"73909106254b7ec312367079687c0de37740bb31","modified":1568771020086},{"_id":"themes/hiker/source/css/_partial/sidebar.styl","hash":"a0b01d34317f4b17ce0f8c14cd978798ad2fbecc","modified":1568771020086},{"_id":"themes/hiker/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1568771020087},{"_id":"themes/hiker/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1568771020088},{"_id":"themes/hiker/source/css/bootstrap.css","hash":"e779837d33b0311a4d61928c595622ae82e7f8a8","modified":1568771020091},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1568771020109},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1568771020114},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1568771020114},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1568771020117},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1568771020117},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1568771020118},{"_id":"themes/hiker/source/css/images/avatar.jpg","hash":"d685c61842df6ff3f44a96ba4ac15117502168ee","modified":1568771020120},{"_id":"themes/hiker/source/css/images/homelogo.jpg","hash":"4bfc9650c4fd6e60b09ae29f888a819cdf88e9fe","modified":1568771020125},{"_id":"themes/hiker/source/css/images/mylogo.jpg","hash":"d646f67782734c5092d8a504b4972b69b4442f56","modified":1568771020126},{"_id":"themes/hiker/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1568771020131},{"_id":"themes/hiker/source/css/images/setting.jpg","hash":"e56c94251bd37b5ac91de3c8740e360c81af35c0","modified":1573281713407},{"_id":"themes/hiker/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1568771020137},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1568771020138},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1568771020139},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1568771020139},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1568771020140},{"_id":"themes/hiker/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1568771020141},{"_id":"themes/hiker/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1568771020100},{"_id":"themes/hiker/source/css/fonts/FuturaPTBook.otf","hash":"d633453cd20a2fe9bb6ed0067b2188500b3562d3","modified":1568771020105},{"_id":"themes/hiker/source/css/fonts/FuturaPTMedium.otf","hash":"b90cbd107617a2648ea088d5cd7cf6e188b90786","modified":1568771020108},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1568771020113},{"_id":"themes/hiker/source/css/fonts/FuturaPTBold.otf","hash":"134b9ed86365117365f124c88fbb2698b913cdc7","modified":1568771020101},{"_id":"themes/hiker/source/css/fonts/FuturaPTBoldOblique.otf","hash":"146e20605d3fc5a5e1c637fb6158a37b4838cb5c","modified":1568771020103},{"_id":"themes/hiker/source/css/fonts/FuturaPTBookOblique.otf","hash":"a9af9fc360988d9e1ede642761dc7d0be454574b","modified":1568771020106},{"_id":"themes/hiker/source/css/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1568771020115},{"_id":"themes/hiker/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1568771020111},{"_id":"themes/hiker/source/preview/preview-mobile.png","hash":"7679a50aef93fc364cbcee4a52cd84604bf741b1","modified":1568771020161},{"_id":"themes/hiker/source/css/images/home-bg.jpg","hash":"e8dcdb6e03bd02d831bae593feccb7028c9dc5e9","modified":1568771020124},{"_id":"themes/hiker/source/css/images/pose.jpg","hash":"4d394a662e7d6d2de6a4598688c7cd3dba5c2fa3","modified":1568771020131},{"_id":"themes/hiker/source/preview/code-theme.jpg","hash":"8c8512fd04e6106033656d10e92d51de76cca6d8","modified":1568771020156},{"_id":"themes/hiker/source/preview/preview-pc.png","hash":"2471e0697938721e4c5d7c66940e165c59a31a0f","modified":1568771020166},{"_id":"public/content.json","hash":"1e72667f0f5534fed5dd017292218776d2ce6cb8","modified":1573715953152},{"_id":"public/categories/gulp/index.html","hash":"c1f01d7b317ea22c9de118ca678a03d49114f586","modified":1573715953702},{"_id":"public/categories/JavaScript/vue/index.html","hash":"366fbfbf59249efc6fe1195a1971d0e686ea3965","modified":1573715953702},{"_id":"public/page/3/index.html","hash":"58f77ac76ead928f07d5972694173e20e57d9c48","modified":1573715953766},{"_id":"public/tags/js基础/index.html","hash":"db8a0573371f91e050d6e6c03a33a8425799e582","modified":1573715953766},{"_id":"public/tags/javascript/index.html","hash":"4380d303790f13191fed48436b8fc8baae417a78","modified":1573715953767},{"_id":"public/tags/gulp/index.html","hash":"c69d6fbfe32799e22ff09ab4267d020fcb59cd91","modified":1573715953767},{"_id":"public/tags/vue/index.html","hash":"21d9ee7220910641816ac27c75e5f5fdc9e3076b","modified":1573715953767},{"_id":"public/tags/css/index.html","hash":"c74a82e5481937249c3377638b984ee0fc2b4903","modified":1573715953767},{"_id":"public/tags/性能测试/index.html","hash":"9588234e5dcf8fcc1ce1ec63dbe7734db70db388","modified":1573715953767},{"_id":"public/tags/SSR/index.html","hash":"4809d113183aa1a0dc8feeb3bc7977ddcba5710c","modified":1573715953767},{"_id":"public/tags/Nuxt/index.html","hash":"5bf2145f227d075143dc02511c7115b59a29aba7","modified":1573715953767},{"_id":"public/tags/前端路由/index.html","hash":"92f86ec19d5d0990cbc2a99ba720aab320928672","modified":1573715953767},{"_id":"public/tags/闭包/index.html","hash":"08279777989fb341695ed5c7ed59113f91323ad7","modified":1573715953767},{"_id":"public/tags/js/index.html","hash":"70fc51f54f189f3a648129e2c0f4822f836c74ba","modified":1573715953767},{"_id":"public/tags/Javascript/index.html","hash":"2a479ce043a8de01809782370a8f93b45fac250f","modified":1573715953768},{"_id":"public/categories/index.html","hash":"e795afb09ee198e52be78b7a26784488c1847d7b","modified":1573715953768},{"_id":"public/tags/index.html","hash":"2847e656afadc31a407d55ef57bcabdcd634e82e","modified":1573715953768},{"_id":"public/2019/11/12/web前端常见的安全问题/index.html","hash":"c17a64dfb1e6552fd606d89de2eebc617be452e2","modified":1573715953768},{"_id":"public/2019/11/05/网页禁止审查及一些简单禁止用户对页面操作/index.html","hash":"47dd57901b50b4520e7d9c3a931ce6f0940a9968","modified":1573715953768},{"_id":"public/2019/11/04/如何在nuxt中使用Vuex做登陆管理/index.html","hash":"d9d447232c5df1fa5a134ed77db214e56a1687f0","modified":1573715953768},{"_id":"public/2019/10/30/vue双向数据绑定原理/index.html","hash":"51792460017ceb75bff34cf4c9f36e0420d03842","modified":1573715953768},{"_id":"public/2019/10/22/如何理解ES6中Promise/index.html","hash":"f65c0af9755cf7341d5d0a312e380a394017394c","modified":1573715953768},{"_id":"public/2019/10/11/SPA的前世今生/index.html","hash":"0a5a4f4b3e3a2fe96b9fe649aa60f49e13f4dea9","modified":1573715953768},{"_id":"public/2019/10/08/JavaScript中深拷贝与浅拷贝的理解/index.html","hash":"65168cd1bd80069bac58dd5fc3e3d7d5bae57107","modified":1573715953768},{"_id":"public/2019/10/07/闭包的概念与应用/index.html","hash":"0c289d394edd75dc4aa3b825e39f468647e23c30","modified":1573715953768},{"_id":"public/2019/09/24/对于Javascript执行上下文的理解/index.html","hash":"a8398395492e26a28447038da7b650e517160b9d","modified":1573715953768},{"_id":"public/2019/09/19/谈谈前端路由/index.html","hash":"688ded0e345252cb7494d5724e0c5a2ec5629ebd","modified":1573715953768},{"_id":"public/2019/09/18/什么是BFC/index.html","hash":"f5d5c602947fdf90910d90384bca741c423fc612","modified":1573715953768},{"_id":"public/2019/09/17/使用console进行-性能测试-和-计算代码运行时间/index.html","hash":"36dc55ef7c04fdabaa9636715056ec866c0ec76b","modified":1573715953769},{"_id":"public/2019/09/16/前端性能优化一-性能指标/index.html","hash":"9cd5d5961bcc5dc83f7b150e6f61ff014a241bca","modified":1573715953769},{"_id":"public/2019/08/26/javascript中的Map/index.html","hash":"458786dae2f98fb04ff85fcf153d3d13ecd9b370","modified":1573715953769},{"_id":"public/2019/08/25/如何为平台设计一个插件系统/index.html","hash":"82c769dae48b7ac62a45366fc429ee4e50762186","modified":1573715953769},{"_id":"public/2019/08/22/call apply bind的区别和用法/index.html","hash":"1eef0bf3b865e96a7d6ba7515af8c562cda11c24","modified":1573715953769},{"_id":"public/2019/08/06/cookie、localstorage和sessionstorage三者之间的区别以及使用方式/index.html","hash":"74bc0d7a5077ed8f633ffc2eda0e394b30f15c3e","modified":1573715953769},{"_id":"public/2019/07/01/javascript垃圾回收机制/index.html","hash":"712622e11bcfd1187d77c94dfd67fd131dff6eff","modified":1573715953769},{"_id":"public/2019/04/28/==的隐式转换/index.html","hash":"a4a42915b7d1ee6d27b0b51ce2fc4b8ada9ba75b","modified":1573715953769},{"_id":"public/archives/index.html","hash":"94dd869b9f2e10c5fabee25ded0d3cb6ceccadd7","modified":1573715953769},{"_id":"public/archives/page/2/index.html","hash":"47283c7fee797e640c5c07d6fe11bf69708f23a0","modified":1573715953769},{"_id":"public/archives/page/3/index.html","hash":"6133877c6ac4f616862833fe358b242fe47c17e1","modified":1573715953769},{"_id":"public/archives/2019/index.html","hash":"bc8990c2ee3e4c5e23ddf8b7ab32d1520f5ae721","modified":1573715953770},{"_id":"public/archives/2019/page/2/index.html","hash":"d28a4bc287f9305c16e6807ef1c9f6ce7fbc9cd4","modified":1573715953770},{"_id":"public/archives/2019/page/3/index.html","hash":"f9970a2732e180d3fd1d2282ccde56d248de8293","modified":1573715953770},{"_id":"public/archives/2019/04/index.html","hash":"6e889015eb70330c76f06ce3a9e6406fac5e755e","modified":1573715953770},{"_id":"public/archives/2019/07/index.html","hash":"826c83451447808f74182ba09e386faf7c0e2699","modified":1573715953770},{"_id":"public/archives/2019/09/index.html","hash":"4d64d0fb2b294c83a8c81fec6c28f4bee413289f","modified":1573715953770},{"_id":"public/archives/2019/08/index.html","hash":"3b6c77b44b216383139b868831a4f95fcfd6d919","modified":1573715953770},{"_id":"public/archives/2019/10/index.html","hash":"0ea94d8c75e83ebc4d0d22a6fa9825541c113c27","modified":1573715953770},{"_id":"public/archives/2019/11/index.html","hash":"60b1d77cdd980b440e51ca3cb801339ce6781019","modified":1573715953770},{"_id":"public/categories/JavaScript/index.html","hash":"fb2fe09ce59f247e62645da9d4c779066dcd5225","modified":1573715953770},{"_id":"public/index.html","hash":"c95906d8486bcecc5133abf4298f04225cee9b7a","modified":1573715953770},{"_id":"public/page/2/index.html","hash":"6d258b6a760e9c9ef554a735ee8ab865b104ec4f","modified":1573715953770},{"_id":"public/categories/vue/index.html","hash":"96433a8c107a50e82de275d3e416c2bbe68205ef","modified":1573715953788},{"_id":"public/2019/11/14/浅谈v-slot/index.html","hash":"241fa24a0f3a384ea49253e268ecfba8ac6dc625","modified":1573715953788},{"_id":"public/2019/11/13/gulp入门（三）/index.html","hash":"7fcca4922a6124edc4600fcdc7c011de5cdce874","modified":1573715953794},{"_id":"public/2019/11/11/gulp入门（二）/index.html","hash":"d97986fdf7cacbfed53053034951a5212c74ca3c","modified":1573715953794},{"_id":"public/2019/11/07/gulp入门（一）/index.html","hash":"96ae6c9fc6d36f5ea9fcf0e549a7940f03a30c7b","modified":1573715953794},{"_id":"public/tags/vue基础/index.html","hash":"e52f1de03687619a69375c15f6bf6e2bb6f935c8","modified":1573715953800},{"_id":"public/image/liutao01.jpg","hash":"b3a2b12b09d73008fe795e527d152d07572c4f96","modified":1573715953800},{"_id":"public/image/liutao02.jpg","hash":"870c5c7742359e75ac92803a67c2fa44bdbc0b93","modified":1573715953801},{"_id":"public/image/liutao03.gif","hash":"2bfdd4ce07a220efcf7c731a664b63425bb444bf","modified":1573715953801},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1573715953801},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1573715953801},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1573715953801},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1573715953801},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1573715953801},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1573715953801},{"_id":"public/preview/browser-support.png","hash":"a6d8498553550c6b18a8f22bcd2f53c993c7d677","modified":1573715953801},{"_id":"public/preview/donation-btn.png","hash":"ad78b1605b162e2399a1cdc5232f6a44298dba6c","modified":1573715953801},{"_id":"public/preview/theme-color.png","hash":"725130ceea5e41bb2cc60b31e45275b4b0cc77b3","modified":1573715953801},{"_id":"public/preview/preview-abstract.png","hash":"3d18ad9ba38fe24770ba6758d8f1bb242f669ce3","modified":1573715953801},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1573715953801},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1573715953801},{"_id":"public/css/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1573715953802},{"_id":"public/css/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1573715953802},{"_id":"public/css/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1573715953802},{"_id":"public/css/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1573715953802},{"_id":"public/css/images/avatar.jpg","hash":"d685c61842df6ff3f44a96ba4ac15117502168ee","modified":1573715953802},{"_id":"public/css/images/homelogo.jpg","hash":"4bfc9650c4fd6e60b09ae29f888a819cdf88e9fe","modified":1573715953802},{"_id":"public/css/images/mylogo.jpg","hash":"d646f67782734c5092d8a504b4972b69b4442f56","modified":1573715953802},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1573715953802},{"_id":"public/css/images/setting.jpg","hash":"e56c94251bd37b5ac91de3c8740e360c81af35c0","modified":1573715953802},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1573715953802},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1573715953802},{"_id":"public/css/fonts/FuturaPTBook.otf","hash":"d633453cd20a2fe9bb6ed0067b2188500b3562d3","modified":1573715954407},{"_id":"public/css/fonts/FuturaPTMedium.otf","hash":"b90cbd107617a2648ea088d5cd7cf6e188b90786","modified":1573715954408},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1573715954408},{"_id":"public/css/fonts/FuturaPTBold.otf","hash":"134b9ed86365117365f124c88fbb2698b913cdc7","modified":1573715954408},{"_id":"public/css/fonts/FuturaPTBoldOblique.otf","hash":"146e20605d3fc5a5e1c637fb6158a37b4838cb5c","modified":1573715954408},{"_id":"public/css/fonts/glyphicons-halflings-regular.svg","hash":"4dcf0ab896f5417047f881de91bad10dcbda48c6","modified":1573715954409},{"_id":"public/css/archive.css","hash":"17cc72203cad1b0be66008d662c7494507aaee8b","modified":1573715954432},{"_id":"public/css/header-post.css","hash":"3f6d1f5593a353b4b05a67ee14e04ec9c986db21","modified":1573715954432},{"_id":"public/css/dialog.css","hash":"5e0333adf3f496e0d443767fe228a1d4b1a2bafc","modified":1573715954432},{"_id":"public/css/home.css","hash":"5ebf4341aba092c01a22811f3358b2c722563456","modified":1573715954432},{"_id":"public/css/vdonate.css","hash":"bca2d291a71e7358654c51f23e8bfb467b2bc8b2","modified":1573715954432},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1573715954432},{"_id":"public/js/home.js","hash":"e403c3290d76c5f58571cbfe4414236e41a7ac94","modified":1573715954432},{"_id":"public/js/dialog.js","hash":"01e8b337c1721e0486fd5044f98b233e84ba1985","modified":1573715954432},{"_id":"public/js/scripts.js","hash":"e06a8948375df71cbf77abf8617db438ece811b3","modified":1573715954432},{"_id":"public/js/totop.js","hash":"29bb40144ac238d22b25d59df465aff8dc38bfd0","modified":1573715954432},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1573715954432},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1573715954433},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1573715954433},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1573715954433},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1573715954433},{"_id":"public/css/style.css","hash":"17fe3fcd2800a5f2bf5b1bcd9fac2c6cd047353c","modified":1573715954433},{"_id":"public/css/fonts/FuturaPTBookOblique.otf","hash":"a9af9fc360988d9e1ede642761dc7d0be454574b","modified":1573715954433},{"_id":"public/js/insight.js","hash":"6f565d8edd8463ee3269ba8ad9badf404f0f4b20","modified":1573715954442},{"_id":"public/js/vdonate.js","hash":"5738414c642d30e43943a69287b3d25a0b6be135","modified":1573715954443},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1573715954443},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1573715954459},{"_id":"public/preview/preview-mobile.png","hash":"7679a50aef93fc364cbcee4a52cd84604bf741b1","modified":1573715954476},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1573715954481},{"_id":"public/css/images/pose.jpg","hash":"4d394a662e7d6d2de6a4598688c7cd3dba5c2fa3","modified":1573715954481},{"_id":"public/js/bootstrap.js","hash":"3b965a36a6b08854ad6eddedf85c5319fd392b4a","modified":1573715954483},{"_id":"public/css/images/home-bg.jpg","hash":"e8dcdb6e03bd02d831bae593feccb7028c9dc5e9","modified":1573715954486},{"_id":"public/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1573715954488},{"_id":"public/preview/code-theme.jpg","hash":"8c8512fd04e6106033656d10e92d51de76cca6d8","modified":1573715954491},{"_id":"public/preview/preview-pc.png","hash":"2471e0697938721e4c5d7c66940e165c59a31a0f","modified":1573715954493},{"_id":"public/css/bootstrap.css","hash":"84179f85b2e7c1925dfc78a37b797d17bf2c7c9e","modified":1573715954495}],"Category":[{"name":"JavaScript","_id":"ck2ydufvv00034sefii03bde8"},{"name":"gulp","_id":"ck2ydufw7000f4sefm34m9x3f"},{"name":"vue","parent":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwk000y4sefy6m3pk7m"},{"name":"vue","_id":"ck2ydufy200254sefb2sd74w3"}],"Data":[],"Page":[{"title":"categories","date":"2019-08-29T09:09:19.000Z","layout":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2019-08-29 17:09:19\nlayout: categories\ncomments: false\n---\n","updated":"2019-09-18T01:43:40.014Z","path":"categories/index.html","_id":"ck2ydufvs00014sefzzyop9qy","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2019-08-29T09:09:57.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2019-08-29 17:09:57\nlayout: tags\ncomments: false   #此页评论关闭\n---\n","updated":"2019-09-18T01:43:40.015Z","path":"tags/index.html","_id":"ck2ydufxp001s4sef8xlcm207","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"==的隐式转换","date":"2019-04-28T01:13:40.000Z","author":"胡豪","_content":"\n## 前言\n==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的\n\n## 探究== \n```js\n     对象\n        \\\n        字符串   布尔值\n          \\      /\n            数值\n\n\n1. 对象和布尔值比较\n对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字\n[] == true;  //false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false\n\n2. 对象和字符串比较\n对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。\n[1,2,3] == '1,2,3' // true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;\n\n3. 对象和数字比较\n对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。\n[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true\n\n4. 字符串和数字比较\n字符串和数字进行比较时，字符串转换成数字，二者再比较。\n'1' == 1 // true\n\n5. 字符串和布尔值比较\n字符串和布尔值进行比较时，二者全部转换成数值再比较。\n'1' == true; // true \n\n6. 布尔值和数字比较\n布尔值和数字进行比较时，布尔转换为数字，二者比较。\ntrue == 1 // true\n\n7. other\n来看一个有趣的题\n[] == false;\n![] == false;\n还有一些需要记住的，像：\nundefined == null //true undefined和null 比较返回true，二者和其他值比较返回false\nNumber(null) //0\n```\n\n## 特殊等式\nNaN 和 -0 在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..) (或者polyfill)。而- 0 等于 0 （对于===也是如此），因此我们必须使用isNegZero(..)这样的工具函数。\n\nES6 中新加入一个方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有特殊情况：\n```js\n\nvar a = 2 / \"hello\";\nvar b = -3 * 0;\nObject.is(a,NaN);   //true\nObject.is(b,-0);    //true\nObject.is(b,0);     //false\n\n```\n\n## 小结\n能使用 == 或 === 就尽量不要使用Object.is(..),因为前者效率更高，更为通用。Object.is(..)主要用来处理那些特殊的相等比较。","source":"_posts/==的隐式转换.md","raw":"---\ntitle: ==的隐式转换\ndate: 2019-04-28 09:13:40\nauthor: 胡豪\ncategories: \n- JavaScript \ntags:\n- js基础\n---\n\n## 前言\n==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的\n\n## 探究== \n```js\n     对象\n        \\\n        字符串   布尔值\n          \\      /\n            数值\n\n\n1. 对象和布尔值比较\n对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字\n[] == true;  //false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false\n\n2. 对象和字符串比较\n对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。\n[1,2,3] == '1,2,3' // true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;\n\n3. 对象和数字比较\n对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。\n[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true\n\n4. 字符串和数字比较\n字符串和数字进行比较时，字符串转换成数字，二者再比较。\n'1' == 1 // true\n\n5. 字符串和布尔值比较\n字符串和布尔值进行比较时，二者全部转换成数值再比较。\n'1' == true; // true \n\n6. 布尔值和数字比较\n布尔值和数字进行比较时，布尔转换为数字，二者比较。\ntrue == 1 // true\n\n7. other\n来看一个有趣的题\n[] == false;\n![] == false;\n还有一些需要记住的，像：\nundefined == null //true undefined和null 比较返回true，二者和其他值比较返回false\nNumber(null) //0\n```\n\n## 特殊等式\nNaN 和 -0 在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..) (或者polyfill)。而- 0 等于 0 （对于===也是如此），因此我们必须使用isNegZero(..)这样的工具函数。\n\nES6 中新加入一个方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有特殊情况：\n```js\n\nvar a = 2 / \"hello\";\nvar b = -3 * 0;\nObject.is(a,NaN);   //true\nObject.is(b,-0);    //true\nObject.is(b,0);     //false\n\n```\n\n## 小结\n能使用 == 或 === 就尽量不要使用Object.is(..),因为前者效率更高，更为通用。Object.is(..)主要用来处理那些特殊的相等比较。","slug":"==的隐式转换","published":1,"updated":"2019-09-24T06:10:49.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufvn00004sefpwxm0rmq","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的</p>\n<h2 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究==\"></a>探究==</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     对象</span><br><span class=\"line\">        \\</span><br><span class=\"line\">        字符串   布尔值</span><br><span class=\"line\">          \\      /</span><br><span class=\"line\">            数值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> 对象和布尔值比较</span><br><span class=\"line\">对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字</span><br><span class=\"line\">[] == <span class=\"literal\">true</span>;  <span class=\"comment\">//false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 对象和字符串比较</span><br><span class=\"line\">对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] == <span class=\"string\">'1,2,3'</span> <span class=\"comment\">// true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> 对象和数字比较</span><br><span class=\"line\">对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。</span><br><span class=\"line\">[<span class=\"number\">1</span>] == <span class=\"number\">1</span>;  <span class=\"comment\">// true  `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; '1' =&gt; 1 所以结果为true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span> 字符串和数字比较</span><br><span class=\"line\">字符串和数字进行比较时，字符串转换成数字，二者再比较。</span><br><span class=\"line\"><span class=\"string\">'1'</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> 字符串和布尔值比较</span><br><span class=\"line\">字符串和布尔值进行比较时，二者全部转换成数值再比较。</span><br><span class=\"line\"><span class=\"string\">'1'</span> == <span class=\"literal\">true</span>; <span class=\"comment\">// true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span> 布尔值和数字比较</span><br><span class=\"line\">布尔值和数字进行比较时，布尔转换为数字，二者比较。</span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span> other</span><br><span class=\"line\">来看一个有趣的题</span><br><span class=\"line\">[] == <span class=\"literal\">false</span>;</span><br><span class=\"line\">![] == <span class=\"literal\">false</span>;</span><br><span class=\"line\">还有一些需要记住的，像：</span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">null</span> <span class=\"comment\">//true undefined和null 比较返回true，二者和其他值比较返回false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊等式\"><a href=\"#特殊等式\" class=\"headerlink\" title=\"特殊等式\"></a>特殊等式</h2><p>NaN 和 -0 在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..) (或者polyfill)。而- 0 等于 0 （对于===也是如此），因此我们必须使用isNegZero(..)这样的工具函数。</p>\n<p>ES6 中新加入一个方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有特殊情况：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span> / <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">-3</span> * <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(a,<span class=\"literal\">NaN</span>);   <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(b,<span class=\"number\">-0</span>);    <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(b,<span class=\"number\">0</span>);     <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>能使用 == 或 === 就尽量不要使用Object.is(..),因为前者效率更高，更为通用。Object.is(..)主要用来处理那些特殊的相等比较。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的</p>\n<h2 id=\"探究\"><a href=\"#探究\" class=\"headerlink\" title=\"探究==\"></a>探究==</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     对象</span><br><span class=\"line\">        \\</span><br><span class=\"line\">        字符串   布尔值</span><br><span class=\"line\">          \\      /</span><br><span class=\"line\">            数值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1.</span> 对象和布尔值比较</span><br><span class=\"line\">对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字</span><br><span class=\"line\">[] == <span class=\"literal\">true</span>;  <span class=\"comment\">//false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2.</span> 对象和字符串比较</span><br><span class=\"line\">对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>] == <span class=\"string\">'1,2,3'</span> <span class=\"comment\">// true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3.</span> 对象和数字比较</span><br><span class=\"line\">对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。</span><br><span class=\"line\">[<span class=\"number\">1</span>] == <span class=\"number\">1</span>;  <span class=\"comment\">// true  `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; '1' =&gt; 1 所以结果为true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4.</span> 字符串和数字比较</span><br><span class=\"line\">字符串和数字进行比较时，字符串转换成数字，二者再比较。</span><br><span class=\"line\"><span class=\"string\">'1'</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5.</span> 字符串和布尔值比较</span><br><span class=\"line\">字符串和布尔值进行比较时，二者全部转换成数值再比较。</span><br><span class=\"line\"><span class=\"string\">'1'</span> == <span class=\"literal\">true</span>; <span class=\"comment\">// true </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6.</span> 布尔值和数字比较</span><br><span class=\"line\">布尔值和数字进行比较时，布尔转换为数字，二者比较。</span><br><span class=\"line\"><span class=\"literal\">true</span> == <span class=\"number\">1</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7.</span> other</span><br><span class=\"line\">来看一个有趣的题</span><br><span class=\"line\">[] == <span class=\"literal\">false</span>;</span><br><span class=\"line\">![] == <span class=\"literal\">false</span>;</span><br><span class=\"line\">还有一些需要记住的，像：</span><br><span class=\"line\"><span class=\"literal\">undefined</span> == <span class=\"literal\">null</span> <span class=\"comment\">//true undefined和null 比较返回true，二者和其他值比较返回false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>) <span class=\"comment\">//0</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"特殊等式\"><a href=\"#特殊等式\" class=\"headerlink\" title=\"特殊等式\"></a>特殊等式</h2><p>NaN 和 -0 在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..) (或者polyfill)。而- 0 等于 0 （对于===也是如此），因此我们必须使用isNegZero(..)这样的工具函数。</p>\n<p>ES6 中新加入一个方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有特殊情况：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">2</span> / <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">-3</span> * <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(a,<span class=\"literal\">NaN</span>);   <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(b,<span class=\"number\">-0</span>);    <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.is(b,<span class=\"number\">0</span>);     <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>能使用 == 或 === 就尽量不要使用Object.is(..),因为前者效率更高，更为通用。Object.is(..)主要用来处理那些特殊的相等比较。</p>\n"},{"title":"SPA的前世今生","date":"2019-10-11T07:24:55.000Z","author":"胡豪","_content":"\n## 前言\n\nSPA(Single Page Application)，即单页应用，想必现在的前端对其早已耳熟能详，今天就来说道说道，SPA 的前世今生。\n\n## 多页面应用（MultiPage Application，MPA）\n\n为什么先说多页面，因为传统网站都是多页面的，从大学第一次做网页，到工作使用 JQ 库，一个个 html 页面拼凑而成的网站都是多页面的。<br>\n每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档，这种类型的网站也就是多页网站，也叫做多页应用。<br>\n多页面跳转刷新所有资源，每个公共资源(js、css 等)需选择性重新加载。<br>\n\n![多页面应用](http://tva3.sinaimg.cn/large/b535b7d3ly1g874l3qw95j20j7096dio.jpg)\n\n页面结构如图：\n![多页面应用结构视图](http://tva3.sinaimg.cn/large/b535b7d3ly1g8747ayh6oj20go089gld.jpg)\n\n### 为什么多页应用的首屏时间快？\n\n首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个 html，页面就会展示出来，这个过程只经历了一个 HTTP 请求，所以页面展示的速度非常快。\n\n### 为什么搜索引擎优化效果好（SEO）？\n\n搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 Html 中，所以这种多页应用，seo 排名效果好。\n\n### 但是它也有缺点，就是切换慢\n\n因为每次跳转都需要发出一个 http 请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。  \n新的需求促进新的技术诞生，随着业务量变大功能的复杂，前端对页面性能的要求越来越高，随之而来的就是单页面的应用。\n\n## 单页应用（SinglePage Web Application，SPA）\n\n第一次进入页面的时候会请求一个 html 文件，刷新清除一下。页面切换，也不是传统的请求另一个页面的 html,而是通过路由，改变组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。\n原理是：JS 会感知到 url 的变化，通过这一点，可以用 js 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求 html 文件了。\n\n![单页面应用](http://tva4.sinaimg.cn/large/b535b7d3ly1g874l3vsyyj20ji08i0vd.jpg)\n\n页面结构如图：\n![单页面应用结构图](http://tvax4.sinaimg.cn/large/b535b7d3ly1g878knhv7vj20go08v0se.jpg)\n\n### 为什么页面切换快？\n\n页面每次切换跳转时，并不需要做 html 文件的请求，这样就节约了很多 http 发送时延，我们在切换页面的时候速度很快。\n\n### 缺点：首屏时间慢，SEO 差\n\n单页应用的首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。\nSEO 效果差，因为搜索引擎只认识 html 里的内容，不认识 js 的内容，而单页应用的内容都是靠 js 渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。\n\n### 优缺点，必有解决的对策\n\n比如说服务器端渲染技术(如 SSR)可以解决 SEO 问题，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。\n\n\n## 具体对比分析：\n\n<table>\n  <tr>\n    <th> </th>\n    <th>多页应用模式MPA</th>\n    <th>单页应用模式SPA</th>\n  </tr>\n  <tr>\n    <td>组成</td> \n    <td>多个完整页面构成</td>\n    <td>一个外壳页面和多个页面片段组成</td>\n  </tr>\n  <tr>\n    <td>资源共用(css,js)</td>\n    <td>不共用，每个页面都需要加载</td>\n    <td>共用，只需在外壳部分加载</td> \n  </tr>\n  <tr>\n    <td>刷新方式</td>\n    <td>整页刷新</td>\n    <td>页面局部刷新或更改</td> \n  </tr>\n <tr>\n    <td>URL模式</td>\n    <td>http://xxx/page1.html 和 http://xxx/page2.html</td>\n    <td>http://xxx/shell.html#page1 和 http://xxx/shell.html#page2</td> \n  </tr>\n  <tr>\n    <td>用户体验</td>\n    <td>页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上</td>\n    <td>页面片段间的切换快，用户体验好，包括在移动设备上</td> \n  </tr>\n  <tr>\n    <td>能否实现转场动画</td>\n    <td>无法实现</td>\n    <td>容易实现（手机app动效）</td> \n  </tr>\n  <tr>\n    <td>页面间传递数据</td>\n    <td>依赖URL、cookie或者localstorage，实现麻烦</td>\n    <td>因为在一个页面内，页面间传递数据很容易实现(父子之间传值，或vuex或storage之类)</td> \n  </tr>\n  <tr>\n    <td>搜索引擎优化（SEO）</td>\n    <td>可以直接做</td>\n    <td>不利于SEO检索，可利用SSR来实现</td> \n  </tr>\n  <tr>\n    <td>特别适用的范围</td>\n    <td>需要对搜索引擎友好的网站</td>\n    <td>对体验要求高的应用，特别是移动应用 购物网站</td> \n  </tr>\n</table>\n","source":"_posts/SPA的前世今生.md","raw":"---\ntitle: SPA的前世今生\ndate: 2019-10-11 15:24:55\nauthor: 胡豪\ncategories:\n  - JavaScript\ntags:\n  - js基础\n---\n\n## 前言\n\nSPA(Single Page Application)，即单页应用，想必现在的前端对其早已耳熟能详，今天就来说道说道，SPA 的前世今生。\n\n## 多页面应用（MultiPage Application，MPA）\n\n为什么先说多页面，因为传统网站都是多页面的，从大学第一次做网页，到工作使用 JQ 库，一个个 html 页面拼凑而成的网站都是多页面的。<br>\n每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档，这种类型的网站也就是多页网站，也叫做多页应用。<br>\n多页面跳转刷新所有资源，每个公共资源(js、css 等)需选择性重新加载。<br>\n\n![多页面应用](http://tva3.sinaimg.cn/large/b535b7d3ly1g874l3qw95j20j7096dio.jpg)\n\n页面结构如图：\n![多页面应用结构视图](http://tva3.sinaimg.cn/large/b535b7d3ly1g8747ayh6oj20go089gld.jpg)\n\n### 为什么多页应用的首屏时间快？\n\n首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个 html，页面就会展示出来，这个过程只经历了一个 HTTP 请求，所以页面展示的速度非常快。\n\n### 为什么搜索引擎优化效果好（SEO）？\n\n搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 Html 中，所以这种多页应用，seo 排名效果好。\n\n### 但是它也有缺点，就是切换慢\n\n因为每次跳转都需要发出一个 http 请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。  \n新的需求促进新的技术诞生，随着业务量变大功能的复杂，前端对页面性能的要求越来越高，随之而来的就是单页面的应用。\n\n## 单页应用（SinglePage Web Application，SPA）\n\n第一次进入页面的时候会请求一个 html 文件，刷新清除一下。页面切换，也不是传统的请求另一个页面的 html,而是通过路由，改变组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。\n原理是：JS 会感知到 url 的变化，通过这一点，可以用 js 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求 html 文件了。\n\n![单页面应用](http://tva4.sinaimg.cn/large/b535b7d3ly1g874l3vsyyj20ji08i0vd.jpg)\n\n页面结构如图：\n![单页面应用结构图](http://tvax4.sinaimg.cn/large/b535b7d3ly1g878knhv7vj20go08v0se.jpg)\n\n### 为什么页面切换快？\n\n页面每次切换跳转时，并不需要做 html 文件的请求，这样就节约了很多 http 发送时延，我们在切换页面的时候速度很快。\n\n### 缺点：首屏时间慢，SEO 差\n\n单页应用的首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。\nSEO 效果差，因为搜索引擎只认识 html 里的内容，不认识 js 的内容，而单页应用的内容都是靠 js 渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。\n\n### 优缺点，必有解决的对策\n\n比如说服务器端渲染技术(如 SSR)可以解决 SEO 问题，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。\n\n\n## 具体对比分析：\n\n<table>\n  <tr>\n    <th> </th>\n    <th>多页应用模式MPA</th>\n    <th>单页应用模式SPA</th>\n  </tr>\n  <tr>\n    <td>组成</td> \n    <td>多个完整页面构成</td>\n    <td>一个外壳页面和多个页面片段组成</td>\n  </tr>\n  <tr>\n    <td>资源共用(css,js)</td>\n    <td>不共用，每个页面都需要加载</td>\n    <td>共用，只需在外壳部分加载</td> \n  </tr>\n  <tr>\n    <td>刷新方式</td>\n    <td>整页刷新</td>\n    <td>页面局部刷新或更改</td> \n  </tr>\n <tr>\n    <td>URL模式</td>\n    <td>http://xxx/page1.html 和 http://xxx/page2.html</td>\n    <td>http://xxx/shell.html#page1 和 http://xxx/shell.html#page2</td> \n  </tr>\n  <tr>\n    <td>用户体验</td>\n    <td>页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上</td>\n    <td>页面片段间的切换快，用户体验好，包括在移动设备上</td> \n  </tr>\n  <tr>\n    <td>能否实现转场动画</td>\n    <td>无法实现</td>\n    <td>容易实现（手机app动效）</td> \n  </tr>\n  <tr>\n    <td>页面间传递数据</td>\n    <td>依赖URL、cookie或者localstorage，实现麻烦</td>\n    <td>因为在一个页面内，页面间传递数据很容易实现(父子之间传值，或vuex或storage之类)</td> \n  </tr>\n  <tr>\n    <td>搜索引擎优化（SEO）</td>\n    <td>可以直接做</td>\n    <td>不利于SEO检索，可利用SSR来实现</td> \n  </tr>\n  <tr>\n    <td>特别适用的范围</td>\n    <td>需要对搜索引擎友好的网站</td>\n    <td>对体验要求高的应用，特别是移动应用 购物网站</td> \n  </tr>\n</table>\n","slug":"SPA的前世今生","published":1,"updated":"2019-11-09T06:41:53.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufvt00024sefyj7v5e98","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>SPA(Single Page Application)，即单页应用，想必现在的前端对其早已耳熟能详，今天就来说道说道，SPA 的前世今生。</p>\n<h2 id=\"多页面应用（MultiPage-Application，MPA）\"><a href=\"#多页面应用（MultiPage-Application，MPA）\" class=\"headerlink\" title=\"多页面应用（MultiPage Application，MPA）\"></a>多页面应用（MultiPage Application，MPA）</h2><p>为什么先说多页面，因为传统网站都是多页面的，从大学第一次做网页，到工作使用 JQ 库，一个个 html 页面拼凑而成的网站都是多页面的。<br><br>每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档，这种类型的网站也就是多页网站，也叫做多页应用。<br><br>多页面跳转刷新所有资源，每个公共资源(js、css 等)需选择性重新加载。<br></p>\n<p><img src=\"http://tva3.sinaimg.cn/large/b535b7d3ly1g874l3qw95j20j7096dio.jpg\" alt=\"多页面应用\"></p>\n<p>页面结构如图：<br><img src=\"http://tva3.sinaimg.cn/large/b535b7d3ly1g8747ayh6oj20go089gld.jpg\" alt=\"多页面应用结构视图\"></p>\n<h3 id=\"为什么多页应用的首屏时间快？\"><a href=\"#为什么多页应用的首屏时间快？\" class=\"headerlink\" title=\"为什么多页应用的首屏时间快？\"></a>为什么多页应用的首屏时间快？</h3><p>首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个 html，页面就会展示出来，这个过程只经历了一个 HTTP 请求，所以页面展示的速度非常快。</p>\n<h3 id=\"为什么搜索引擎优化效果好（SEO）？\"><a href=\"#为什么搜索引擎优化效果好（SEO）？\" class=\"headerlink\" title=\"为什么搜索引擎优化效果好（SEO）？\"></a>为什么搜索引擎优化效果好（SEO）？</h3><p>搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 Html 中，所以这种多页应用，seo 排名效果好。</p>\n<h3 id=\"但是它也有缺点，就是切换慢\"><a href=\"#但是它也有缺点，就是切换慢\" class=\"headerlink\" title=\"但是它也有缺点，就是切换慢\"></a>但是它也有缺点，就是切换慢</h3><p>因为每次跳转都需要发出一个 http 请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。<br>新的需求促进新的技术诞生，随着业务量变大功能的复杂，前端对页面性能的要求越来越高，随之而来的就是单页面的应用。</p>\n<h2 id=\"单页应用（SinglePage-Web-Application，SPA）\"><a href=\"#单页应用（SinglePage-Web-Application，SPA）\" class=\"headerlink\" title=\"单页应用（SinglePage Web Application，SPA）\"></a>单页应用（SinglePage Web Application，SPA）</h2><p>第一次进入页面的时候会请求一个 html 文件，刷新清除一下。页面切换，也不是传统的请求另一个页面的 html,而是通过路由，改变组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。<br>原理是：JS 会感知到 url 的变化，通过这一点，可以用 js 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求 html 文件了。</p>\n<p><img src=\"http://tva4.sinaimg.cn/large/b535b7d3ly1g874l3vsyyj20ji08i0vd.jpg\" alt=\"单页面应用\"></p>\n<p>页面结构如图：<br><img src=\"http://tvax4.sinaimg.cn/large/b535b7d3ly1g878knhv7vj20go08v0se.jpg\" alt=\"单页面应用结构图\"></p>\n<h3 id=\"为什么页面切换快？\"><a href=\"#为什么页面切换快？\" class=\"headerlink\" title=\"为什么页面切换快？\"></a>为什么页面切换快？</h3><p>页面每次切换跳转时，并不需要做 html 文件的请求，这样就节约了很多 http 发送时延，我们在切换页面的时候速度很快。</p>\n<h3 id=\"缺点：首屏时间慢，SEO-差\"><a href=\"#缺点：首屏时间慢，SEO-差\" class=\"headerlink\" title=\"缺点：首屏时间慢，SEO 差\"></a>缺点：首屏时间慢，SEO 差</h3><p>单页应用的首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。<br>SEO 效果差，因为搜索引擎只认识 html 里的内容，不认识 js 的内容，而单页应用的内容都是靠 js 渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。</p>\n<h3 id=\"优缺点，必有解决的对策\"><a href=\"#优缺点，必有解决的对策\" class=\"headerlink\" title=\"优缺点，必有解决的对策\"></a>优缺点，必有解决的对策</h3><p>比如说服务器端渲染技术(如 SSR)可以解决 SEO 问题，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。</p>\n<h2 id=\"具体对比分析：\"><a href=\"#具体对比分析：\" class=\"headerlink\" title=\"具体对比分析：\"></a>具体对比分析：</h2><table>\n  <tr>\n    <th> </th>\n    <th>多页应用模式MPA</th>\n    <th>单页应用模式SPA</th>\n  </tr>\n  <tr>\n    <td>组成</td> \n    <td>多个完整页面构成</td>\n    <td>一个外壳页面和多个页面片段组成</td>\n  </tr>\n  <tr>\n    <td>资源共用(css,js)</td>\n    <td>不共用，每个页面都需要加载</td>\n    <td>共用，只需在外壳部分加载</td> \n  </tr>\n  <tr>\n    <td>刷新方式</td>\n    <td>整页刷新</td>\n    <td>页面局部刷新或更改</td> \n  </tr>\n <tr>\n    <td>URL模式</td>\n    <td>http://xxx/page1.html 和 http://xxx/page2.html</td>\n    <td>http://xxx/shell.html#page1 和 http://xxx/shell.html#page2</td> \n  </tr>\n  <tr>\n    <td>用户体验</td>\n    <td>页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上</td>\n    <td>页面片段间的切换快，用户体验好，包括在移动设备上</td> \n  </tr>\n  <tr>\n    <td>能否实现转场动画</td>\n    <td>无法实现</td>\n    <td>容易实现（手机app动效）</td> \n  </tr>\n  <tr>\n    <td>页面间传递数据</td>\n    <td>依赖URL、cookie或者localstorage，实现麻烦</td>\n    <td>因为在一个页面内，页面间传递数据很容易实现(父子之间传值，或vuex或storage之类)</td> \n  </tr>\n  <tr>\n    <td>搜索引擎优化（SEO）</td>\n    <td>可以直接做</td>\n    <td>不利于SEO检索，可利用SSR来实现</td> \n  </tr>\n  <tr>\n    <td>特别适用的范围</td>\n    <td>需要对搜索引擎友好的网站</td>\n    <td>对体验要求高的应用，特别是移动应用 购物网站</td> \n  </tr>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>SPA(Single Page Application)，即单页应用，想必现在的前端对其早已耳熟能详，今天就来说道说道，SPA 的前世今生。</p>\n<h2 id=\"多页面应用（MultiPage-Application，MPA）\"><a href=\"#多页面应用（MultiPage-Application，MPA）\" class=\"headerlink\" title=\"多页面应用（MultiPage Application，MPA）\"></a>多页面应用（MultiPage Application，MPA）</h2><p>为什么先说多页面，因为传统网站都是多页面的，从大学第一次做网页，到工作使用 JQ 库，一个个 html 页面拼凑而成的网站都是多页面的。<br><br>每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档，这种类型的网站也就是多页网站，也叫做多页应用。<br><br>多页面跳转刷新所有资源，每个公共资源(js、css 等)需选择性重新加载。<br></p>\n<p><img src=\"http://tva3.sinaimg.cn/large/b535b7d3ly1g874l3qw95j20j7096dio.jpg\" alt=\"多页面应用\"></p>\n<p>页面结构如图：<br><img src=\"http://tva3.sinaimg.cn/large/b535b7d3ly1g8747ayh6oj20go089gld.jpg\" alt=\"多页面应用结构视图\"></p>\n<h3 id=\"为什么多页应用的首屏时间快？\"><a href=\"#为什么多页应用的首屏时间快？\" class=\"headerlink\" title=\"为什么多页应用的首屏时间快？\"></a>为什么多页应用的首屏时间快？</h3><p>首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个 html，页面就会展示出来，这个过程只经历了一个 HTTP 请求，所以页面展示的速度非常快。</p>\n<h3 id=\"为什么搜索引擎优化效果好（SEO）？\"><a href=\"#为什么搜索引擎优化效果好（SEO）？\" class=\"headerlink\" title=\"为什么搜索引擎优化效果好（SEO）？\"></a>为什么搜索引擎优化效果好（SEO）？</h3><p>搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 Html 中，所以这种多页应用，seo 排名效果好。</p>\n<h3 id=\"但是它也有缺点，就是切换慢\"><a href=\"#但是它也有缺点，就是切换慢\" class=\"headerlink\" title=\"但是它也有缺点，就是切换慢\"></a>但是它也有缺点，就是切换慢</h3><p>因为每次跳转都需要发出一个 http 请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。<br>新的需求促进新的技术诞生，随着业务量变大功能的复杂，前端对页面性能的要求越来越高，随之而来的就是单页面的应用。</p>\n<h2 id=\"单页应用（SinglePage-Web-Application，SPA）\"><a href=\"#单页应用（SinglePage-Web-Application，SPA）\" class=\"headerlink\" title=\"单页应用（SinglePage Web Application，SPA）\"></a>单页应用（SinglePage Web Application，SPA）</h2><p>第一次进入页面的时候会请求一个 html 文件，刷新清除一下。页面切换，也不是传统的请求另一个页面的 html,而是通过路由，改变组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。<br>原理是：JS 会感知到 url 的变化，通过这一点，可以用 js 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求 html 文件了。</p>\n<p><img src=\"http://tva4.sinaimg.cn/large/b535b7d3ly1g874l3vsyyj20ji08i0vd.jpg\" alt=\"单页面应用\"></p>\n<p>页面结构如图：<br><img src=\"http://tvax4.sinaimg.cn/large/b535b7d3ly1g878knhv7vj20go08v0se.jpg\" alt=\"单页面应用结构图\"></p>\n<h3 id=\"为什么页面切换快？\"><a href=\"#为什么页面切换快？\" class=\"headerlink\" title=\"为什么页面切换快？\"></a>为什么页面切换快？</h3><p>页面每次切换跳转时，并不需要做 html 文件的请求，这样就节约了很多 http 发送时延，我们在切换页面的时候速度很快。</p>\n<h3 id=\"缺点：首屏时间慢，SEO-差\"><a href=\"#缺点：首屏时间慢，SEO-差\" class=\"headerlink\" title=\"缺点：首屏时间慢，SEO 差\"></a>缺点：首屏时间慢，SEO 差</h3><p>单页应用的首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。<br>SEO 效果差，因为搜索引擎只认识 html 里的内容，不认识 js 的内容，而单页应用的内容都是靠 js 渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。</p>\n<h3 id=\"优缺点，必有解决的对策\"><a href=\"#优缺点，必有解决的对策\" class=\"headerlink\" title=\"优缺点，必有解决的对策\"></a>优缺点，必有解决的对策</h3><p>比如说服务器端渲染技术(如 SSR)可以解决 SEO 问题，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。</p>\n<h2 id=\"具体对比分析：\"><a href=\"#具体对比分析：\" class=\"headerlink\" title=\"具体对比分析：\"></a>具体对比分析：</h2><table>\n  <tr>\n    <th> </th>\n    <th>多页应用模式MPA</th>\n    <th>单页应用模式SPA</th>\n  </tr>\n  <tr>\n    <td>组成</td> \n    <td>多个完整页面构成</td>\n    <td>一个外壳页面和多个页面片段组成</td>\n  </tr>\n  <tr>\n    <td>资源共用(css,js)</td>\n    <td>不共用，每个页面都需要加载</td>\n    <td>共用，只需在外壳部分加载</td> \n  </tr>\n  <tr>\n    <td>刷新方式</td>\n    <td>整页刷新</td>\n    <td>页面局部刷新或更改</td> \n  </tr>\n <tr>\n    <td>URL模式</td>\n    <td>http://xxx/page1.html 和 http://xxx/page2.html</td>\n    <td>http://xxx/shell.html#page1 和 http://xxx/shell.html#page2</td> \n  </tr>\n  <tr>\n    <td>用户体验</td>\n    <td>页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上</td>\n    <td>页面片段间的切换快，用户体验好，包括在移动设备上</td> \n  </tr>\n  <tr>\n    <td>能否实现转场动画</td>\n    <td>无法实现</td>\n    <td>容易实现（手机app动效）</td> \n  </tr>\n  <tr>\n    <td>页面间传递数据</td>\n    <td>依赖URL、cookie或者localstorage，实现麻烦</td>\n    <td>因为在一个页面内，页面间传递数据很容易实现(父子之间传值，或vuex或storage之类)</td> \n  </tr>\n  <tr>\n    <td>搜索引擎优化（SEO）</td>\n    <td>可以直接做</td>\n    <td>不利于SEO检索，可利用SSR来实现</td> \n  </tr>\n  <tr>\n    <td>特别适用的范围</td>\n    <td>需要对搜索引擎友好的网站</td>\n    <td>对体验要求高的应用，特别是移动应用 购物网站</td> \n  </tr>\n</table>\n"},{"title":"JavaScript中深拷贝与浅拷贝的理解","date":"2019-10-08T01:08:15.000Z","author":"刘涛","_content":"\n## 前言\n之所以会出现了深拷贝和浅拷贝，究其根本是因为JS种的变量包含了不同类型的数据值：基本类型和引用类型；同时其中变量的存储方式也不用Object属于堆内存的储存方式；并且JS的值的传递方式如值传递和址传递的会出现不同，所以才会出现这一系列的问题，因此才会使用深拷贝和浅拷贝来解决这些问题。\n\n\n## 一、理解堆栈，基本数据类型和引用数据类型\n  **1.堆栈**\n    栈（stack）：系统自动分配的内存空间，内存会由系统自动释放，用来存放函数的参数值，局部变量的值等，特点是先进后出。<br>\n    堆堆（heap）：系统动态分配的内存，内存大小不一，内存不会自动释放。一般由程序员分配释放，主要负责像Obejct这种变量类型的存储。<br>\n  **2.基本数据类型**\n    概念：存放在栈内存中的简单数据段，数据大小确定，内存空间大小确定\n    6种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol<br>\n  **3.引用数据类型**\n    概念：存放在堆内存中的数据，如对象、数组、函数等。名存在栈内存，值存在堆内存，栈内存会提供一个引用的地址指向堆内存中的值\n  \n\n## 二、JavaScript浅拷贝\n浅拷贝：只复制一层对象属性，可以理解为，只复制对象的基本属性类型，而基本属性类型是存放在栈内存中的，可以直接修改访问的，所以当浅拷贝时，拷贝的对象只是拷贝了原对象的属性，而值都是指向同一个栈内存中的数据，当对象属性值发生修改时，原对象也会被修改。如下示例：\n```JavaScript\n let arr1 = {\n        color:'red',\n        name:'apple',\n        weight:'100g',\n                detail:{\n                big:'true',\n                eating:'no'\n                }\n      };\n let arr2;\n arr2 = arr1;\n arr2.color = 'black';\n console.log(arr2);  \n console.warn(arr1);\n  ```\n输出值：\n![浅拷贝](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png)\n\n\n## 三、JavaScript深拷贝\n深拷贝：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。这是我从某官网看来的解释，我感觉挺绕的，结合对象来看，深拷贝存在于对象这种引用类型中，而引用类型的数据是存在堆内存上的，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。深拷贝可以看做是在堆内存中新开辟了一个内存空间，复制后的对象的属性所指的指针会指向新开辟的内存空间的地址。所以复制后的对象对属性值进行修改不会影响原对象的属性值。\n\n\n\n## 四、实现深拷贝的方式\n1.借用JSON对象的 parse 和 stringify(接上面的例子)\n```JavaScript\n let arr3 = JSON.parse(JSON.stringify(arr1));\narr3.color=\"balck\";\nconsole.log(arr3);\nconsole.warn(arr1);\n  ```\n  输出结果\n\n![JSON对象的深拷贝](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/json%E6%B7%B1%E6%8B%B7%E8%B4%9D.png)\n\n2.通过for循环递归调用\n```JavaScript\n function deepClone(obj){\n           //判断obj是否是数组\n        let objClone = Array.isArray(obj)?[]:{};  \n        if(obj && typeof obj===\"object\"){\n            for(key in obj){\n                if(obj.hasOwnProperty(key)){\n                    //判断ojb子元素是否为对象，如果是，递归复制\n                    if(obj[key]&&typeof obj[key] ===\"object\"){\n                        objClone[key] = deepClone(obj[key]);\n                    }else{\n                        //如果不是，简单复制\n                        objClone[key] = obj[key];\n                    }\n                }\n            }\n        }\n        return objClone;\n    } \n    var arr4 = deepClone(arr1);\n    arr4.name='bananer';\n    console.log(arr4);\n    console.warn(arr1);\n  ```\n    输出结果\n\n![for循环的深拷贝](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/for%E5%BE%AA%E7%8E%AF%E9%80%92%E5%BD%92%E6%B7%B1%E6%8B%B7%E8%B4%9D.jpg)\n\n3.封装深拷贝函数\n```JavaScript\n function deepClone(obj) {\n    let objClone = Array.isArray(obj) ? [] : {};\n    if(obj && typeof obj === \"object\") {\n        for(key in obj) {\n            if(obj.hasOwnProperty(key)) {\n                 // 判断 obj 是否是对象,如果是，递归复制\n                 if(obj[key] && typeof obj[key] === \"object\") {\n                      objClone[key] = deepClone(obj[key]);\n                 }else{\n                      // 如果不是\n                      objClone[key] = obj[key];\n                 }\n            }\n        }\n    }      \n    return objClone\n}         \n\nlet a = [1,2,3,4],\n     b = deepClone(a);\na[0] = 5;\nconsole.log(a,b)\n  ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/JavaScript中深拷贝与浅拷贝的理解.md","raw":"---\ntitle: JavaScript中深拷贝与浅拷贝的理解\ndate: 2019-10-08 09:08:15\ntags: javascript\nauthor: 刘涛\n---\n\n## 前言\n之所以会出现了深拷贝和浅拷贝，究其根本是因为JS种的变量包含了不同类型的数据值：基本类型和引用类型；同时其中变量的存储方式也不用Object属于堆内存的储存方式；并且JS的值的传递方式如值传递和址传递的会出现不同，所以才会出现这一系列的问题，因此才会使用深拷贝和浅拷贝来解决这些问题。\n\n\n## 一、理解堆栈，基本数据类型和引用数据类型\n  **1.堆栈**\n    栈（stack）：系统自动分配的内存空间，内存会由系统自动释放，用来存放函数的参数值，局部变量的值等，特点是先进后出。<br>\n    堆堆（heap）：系统动态分配的内存，内存大小不一，内存不会自动释放。一般由程序员分配释放，主要负责像Obejct这种变量类型的存储。<br>\n  **2.基本数据类型**\n    概念：存放在栈内存中的简单数据段，数据大小确定，内存空间大小确定\n    6种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol<br>\n  **3.引用数据类型**\n    概念：存放在堆内存中的数据，如对象、数组、函数等。名存在栈内存，值存在堆内存，栈内存会提供一个引用的地址指向堆内存中的值\n  \n\n## 二、JavaScript浅拷贝\n浅拷贝：只复制一层对象属性，可以理解为，只复制对象的基本属性类型，而基本属性类型是存放在栈内存中的，可以直接修改访问的，所以当浅拷贝时，拷贝的对象只是拷贝了原对象的属性，而值都是指向同一个栈内存中的数据，当对象属性值发生修改时，原对象也会被修改。如下示例：\n```JavaScript\n let arr1 = {\n        color:'red',\n        name:'apple',\n        weight:'100g',\n                detail:{\n                big:'true',\n                eating:'no'\n                }\n      };\n let arr2;\n arr2 = arr1;\n arr2.color = 'black';\n console.log(arr2);  \n console.warn(arr1);\n  ```\n输出值：\n![浅拷贝](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png)\n\n\n## 三、JavaScript深拷贝\n深拷贝：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。这是我从某官网看来的解释，我感觉挺绕的，结合对象来看，深拷贝存在于对象这种引用类型中，而引用类型的数据是存在堆内存上的，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。深拷贝可以看做是在堆内存中新开辟了一个内存空间，复制后的对象的属性所指的指针会指向新开辟的内存空间的地址。所以复制后的对象对属性值进行修改不会影响原对象的属性值。\n\n\n\n## 四、实现深拷贝的方式\n1.借用JSON对象的 parse 和 stringify(接上面的例子)\n```JavaScript\n let arr3 = JSON.parse(JSON.stringify(arr1));\narr3.color=\"balck\";\nconsole.log(arr3);\nconsole.warn(arr1);\n  ```\n  输出结果\n\n![JSON对象的深拷贝](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/json%E6%B7%B1%E6%8B%B7%E8%B4%9D.png)\n\n2.通过for循环递归调用\n```JavaScript\n function deepClone(obj){\n           //判断obj是否是数组\n        let objClone = Array.isArray(obj)?[]:{};  \n        if(obj && typeof obj===\"object\"){\n            for(key in obj){\n                if(obj.hasOwnProperty(key)){\n                    //判断ojb子元素是否为对象，如果是，递归复制\n                    if(obj[key]&&typeof obj[key] ===\"object\"){\n                        objClone[key] = deepClone(obj[key]);\n                    }else{\n                        //如果不是，简单复制\n                        objClone[key] = obj[key];\n                    }\n                }\n            }\n        }\n        return objClone;\n    } \n    var arr4 = deepClone(arr1);\n    arr4.name='bananer';\n    console.log(arr4);\n    console.warn(arr1);\n  ```\n    输出结果\n\n![for循环的深拷贝](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/for%E5%BE%AA%E7%8E%AF%E9%80%92%E5%BD%92%E6%B7%B1%E6%8B%B7%E8%B4%9D.jpg)\n\n3.封装深拷贝函数\n```JavaScript\n function deepClone(obj) {\n    let objClone = Array.isArray(obj) ? [] : {};\n    if(obj && typeof obj === \"object\") {\n        for(key in obj) {\n            if(obj.hasOwnProperty(key)) {\n                 // 判断 obj 是否是对象,如果是，递归复制\n                 if(obj[key] && typeof obj[key] === \"object\") {\n                      objClone[key] = deepClone(obj[key]);\n                 }else{\n                      // 如果不是\n                      objClone[key] = obj[key];\n                 }\n            }\n        }\n    }      \n    return objClone\n}         \n\nlet a = [1,2,3,4],\n     b = deepClone(a);\na[0] = 5;\nconsole.log(a,b)\n  ```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"JavaScript中深拷贝与浅拷贝的理解","published":1,"updated":"2019-10-08T02:57:38.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufvx00054sef3ol78ye7","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之所以会出现了深拷贝和浅拷贝，究其根本是因为JS种的变量包含了不同类型的数据值：基本类型和引用类型；同时其中变量的存储方式也不用Object属于堆内存的储存方式；并且JS的值的传递方式如值传递和址传递的会出现不同，所以才会出现这一系列的问题，因此才会使用深拷贝和浅拷贝来解决这些问题。</p>\n<h2 id=\"一、理解堆栈，基本数据类型和引用数据类型\"><a href=\"#一、理解堆栈，基本数据类型和引用数据类型\" class=\"headerlink\" title=\"一、理解堆栈，基本数据类型和引用数据类型\"></a>一、理解堆栈，基本数据类型和引用数据类型</h2><p>  <strong>1.堆栈</strong><br>    栈（stack）：系统自动分配的内存空间，内存会由系统自动释放，用来存放函数的参数值，局部变量的值等，特点是先进后出。<br><br>    堆堆（heap）：系统动态分配的内存，内存大小不一，内存不会自动释放。一般由程序员分配释放，主要负责像Obejct这种变量类型的存储。<br><br>  <strong>2.基本数据类型</strong><br>    概念：存放在栈内存中的简单数据段，数据大小确定，内存空间大小确定<br>    6种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol<br><br>  <strong>3.引用数据类型</strong><br>    概念：存放在堆内存中的数据，如对象、数组、函数等。名存在栈内存，值存在堆内存，栈内存会提供一个引用的地址指向堆内存中的值</p>\n<h2 id=\"二、JavaScript浅拷贝\"><a href=\"#二、JavaScript浅拷贝\" class=\"headerlink\" title=\"二、JavaScript浅拷贝\"></a>二、JavaScript浅拷贝</h2><p>浅拷贝：只复制一层对象属性，可以理解为，只复制对象的基本属性类型，而基本属性类型是存放在栈内存中的，可以直接修改访问的，所以当浅拷贝时，拷贝的对象只是拷贝了原对象的属性，而值都是指向同一个栈内存中的数据，当对象属性值发生修改时，原对象也会被修改。如下示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = &#123;</span><br><span class=\"line\">       color:<span class=\"string\">'red'</span>,</span><br><span class=\"line\">       name:<span class=\"string\">'apple'</span>,</span><br><span class=\"line\">       weight:<span class=\"string\">'100g'</span>,</span><br><span class=\"line\">               detail:&#123;</span><br><span class=\"line\">               big:<span class=\"string\">'true'</span>,</span><br><span class=\"line\">               eating:<span class=\"string\">'no'</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2;</span><br><span class=\"line\">arr2 = arr1;</span><br><span class=\"line\">arr2.color = <span class=\"string\">'black'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(arr1);</span><br></pre></td></tr></table></figure>\n\n<p>输出值：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png\" alt=\"浅拷贝\"></p>\n<h2 id=\"三、JavaScript深拷贝\"><a href=\"#三、JavaScript深拷贝\" class=\"headerlink\" title=\"三、JavaScript深拷贝\"></a>三、JavaScript深拷贝</h2><p>深拷贝：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。这是我从某官网看来的解释，我感觉挺绕的，结合对象来看，深拷贝存在于对象这种引用类型中，而引用类型的数据是存在堆内存上的，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。深拷贝可以看做是在堆内存中新开辟了一个内存空间，复制后的对象的属性所指的指针会指向新开辟的内存空间的地址。所以复制后的对象对属性值进行修改不会影响原对象的属性值。</p>\n<h2 id=\"四、实现深拷贝的方式\"><a href=\"#四、实现深拷贝的方式\" class=\"headerlink\" title=\"四、实现深拷贝的方式\"></a>四、实现深拷贝的方式</h2><p>1.借用JSON对象的 parse 和 stringify(接上面的例子)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">let</span> arr3 = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(arr1));</span><br><span class=\"line\">arr3.color=<span class=\"string\">\"balck\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(arr1);</span><br></pre></td></tr></table></figure>\n\n<p>  输出结果</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/json%E6%B7%B1%E6%8B%B7%E8%B4%9D.png\" alt=\"JSON对象的深拷贝\"></p>\n<p>2.通过for循环递归调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//判断obj是否是数组</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> objClone = <span class=\"built_in\">Array</span>.isArray(obj)?[]:&#123;&#125;;  </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(obj &amp;&amp; <span class=\"keyword\">typeof</span> obj===<span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class=\"line\">                   <span class=\"comment\">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span>(obj[key]&amp;&amp;<span class=\"keyword\">typeof</span> obj[key] ===<span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">                       objClone[key] = deepClone(obj[key]);</span><br><span class=\"line\">                   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                       <span class=\"comment\">//如果不是，简单复制</span></span><br><span class=\"line\">                       objClone[key] = obj[key];</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> objClone;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   <span class=\"keyword\">var</span> arr4 = deepClone(arr1);</span><br><span class=\"line\">   arr4.name=<span class=\"string\">'bananer'</span>;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(arr4);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.warn(arr1);</span><br></pre></td></tr></table></figure>\n\n<pre><code>输出结果</code></pre><p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/for%E5%BE%AA%E7%8E%AF%E9%80%92%E5%BD%92%E6%B7%B1%E6%8B%B7%E8%B4%9D.jpg\" alt=\"for循环的深拷贝\"></p>\n<p>3.封装深拷贝函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objClone = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj &amp;&amp; <span class=\"keyword\">typeof</span> obj === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 判断 obj 是否是对象,如果是，递归复制</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">                      objClone[key] = deepClone(obj[key]);</span><br><span class=\"line\">                 &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 如果不是</span></span><br><span class=\"line\">                      objClone[key] = obj[key];</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objClone</span><br><span class=\"line\">&#125;         </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">     b = deepClone(a);</span><br><span class=\"line\">a[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之所以会出现了深拷贝和浅拷贝，究其根本是因为JS种的变量包含了不同类型的数据值：基本类型和引用类型；同时其中变量的存储方式也不用Object属于堆内存的储存方式；并且JS的值的传递方式如值传递和址传递的会出现不同，所以才会出现这一系列的问题，因此才会使用深拷贝和浅拷贝来解决这些问题。</p>\n<h2 id=\"一、理解堆栈，基本数据类型和引用数据类型\"><a href=\"#一、理解堆栈，基本数据类型和引用数据类型\" class=\"headerlink\" title=\"一、理解堆栈，基本数据类型和引用数据类型\"></a>一、理解堆栈，基本数据类型和引用数据类型</h2><p>  <strong>1.堆栈</strong><br>    栈（stack）：系统自动分配的内存空间，内存会由系统自动释放，用来存放函数的参数值，局部变量的值等，特点是先进后出。<br><br>    堆堆（heap）：系统动态分配的内存，内存大小不一，内存不会自动释放。一般由程序员分配释放，主要负责像Obejct这种变量类型的存储。<br><br>  <strong>2.基本数据类型</strong><br>    概念：存放在栈内存中的简单数据段，数据大小确定，内存空间大小确定<br>    6种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol<br><br>  <strong>3.引用数据类型</strong><br>    概念：存放在堆内存中的数据，如对象、数组、函数等。名存在栈内存，值存在堆内存，栈内存会提供一个引用的地址指向堆内存中的值</p>\n<h2 id=\"二、JavaScript浅拷贝\"><a href=\"#二、JavaScript浅拷贝\" class=\"headerlink\" title=\"二、JavaScript浅拷贝\"></a>二、JavaScript浅拷贝</h2><p>浅拷贝：只复制一层对象属性，可以理解为，只复制对象的基本属性类型，而基本属性类型是存放在栈内存中的，可以直接修改访问的，所以当浅拷贝时，拷贝的对象只是拷贝了原对象的属性，而值都是指向同一个栈内存中的数据，当对象属性值发生修改时，原对象也会被修改。如下示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr1 = &#123;</span><br><span class=\"line\">       color:<span class=\"string\">'red'</span>,</span><br><span class=\"line\">       name:<span class=\"string\">'apple'</span>,</span><br><span class=\"line\">       weight:<span class=\"string\">'100g'</span>,</span><br><span class=\"line\">               detail:&#123;</span><br><span class=\"line\">               big:<span class=\"string\">'true'</span>,</span><br><span class=\"line\">               eating:<span class=\"string\">'no'</span></span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\"><span class=\"keyword\">let</span> arr2;</span><br><span class=\"line\">arr2 = arr1;</span><br><span class=\"line\">arr2.color = <span class=\"string\">'black'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(arr1);</span><br></pre></td></tr></table></figure>\n\n<p>输出值：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B5%85%E6%8B%B7%E8%B4%9D.png\" alt=\"浅拷贝\"></p>\n<h2 id=\"三、JavaScript深拷贝\"><a href=\"#三、JavaScript深拷贝\" class=\"headerlink\" title=\"三、JavaScript深拷贝\"></a>三、JavaScript深拷贝</h2><p>深拷贝：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。这是我从某官网看来的解释，我感觉挺绕的，结合对象来看，深拷贝存在于对象这种引用类型中，而引用类型的数据是存在堆内存上的，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。深拷贝可以看做是在堆内存中新开辟了一个内存空间，复制后的对象的属性所指的指针会指向新开辟的内存空间的地址。所以复制后的对象对属性值进行修改不会影响原对象的属性值。</p>\n<h2 id=\"四、实现深拷贝的方式\"><a href=\"#四、实现深拷贝的方式\" class=\"headerlink\" title=\"四、实现深拷贝的方式\"></a>四、实现深拷贝的方式</h2><p>1.借用JSON对象的 parse 和 stringify(接上面的例子)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">let</span> arr3 = <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(arr1));</span><br><span class=\"line\">arr3.color=<span class=\"string\">\"balck\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.warn(arr1);</span><br></pre></td></tr></table></figure>\n\n<p>  输出结果</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/json%E6%B7%B1%E6%8B%B7%E8%B4%9D.png\" alt=\"JSON对象的深拷贝\"></p>\n<p>2.通过for循环递归调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">          <span class=\"comment\">//判断obj是否是数组</span></span><br><span class=\"line\">       <span class=\"keyword\">let</span> objClone = <span class=\"built_in\">Array</span>.isArray(obj)?[]:&#123;&#125;;  </span><br><span class=\"line\">       <span class=\"keyword\">if</span>(obj &amp;&amp; <span class=\"keyword\">typeof</span> obj===<span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj)&#123;</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(obj.hasOwnProperty(key))&#123;</span><br><span class=\"line\">                   <span class=\"comment\">//判断ojb子元素是否为对象，如果是，递归复制</span></span><br><span class=\"line\">                   <span class=\"keyword\">if</span>(obj[key]&amp;&amp;<span class=\"keyword\">typeof</span> obj[key] ===<span class=\"string\">\"object\"</span>)&#123;</span><br><span class=\"line\">                       objClone[key] = deepClone(obj[key]);</span><br><span class=\"line\">                   &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                       <span class=\"comment\">//如果不是，简单复制</span></span><br><span class=\"line\">                       objClone[key] = obj[key];</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> objClone;</span><br><span class=\"line\">   &#125; </span><br><span class=\"line\">   <span class=\"keyword\">var</span> arr4 = deepClone(arr1);</span><br><span class=\"line\">   arr4.name=<span class=\"string\">'bananer'</span>;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(arr4);</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.warn(arr1);</span><br></pre></td></tr></table></figure>\n\n<pre><code>输出结果</code></pre><p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/for%E5%BE%AA%E7%8E%AF%E9%80%92%E5%BD%92%E6%B7%B1%E6%8B%B7%E8%B4%9D.jpg\" alt=\"for循环的深拷贝\"></p>\n<p>3.封装深拷贝函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> objClone = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(obj &amp;&amp; <span class=\"keyword\">typeof</span> obj === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(obj.hasOwnProperty(key)) &#123;</span><br><span class=\"line\">                 <span class=\"comment\">// 判断 obj 是否是对象,如果是，递归复制</span></span><br><span class=\"line\">                 <span class=\"keyword\">if</span>(obj[key] &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] === <span class=\"string\">\"object\"</span>) &#123;</span><br><span class=\"line\">                      objClone[key] = deepClone(obj[key]);</span><br><span class=\"line\">                 &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                      <span class=\"comment\">// 如果不是</span></span><br><span class=\"line\">                      objClone[key] = obj[key];</span><br><span class=\"line\">                 &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;      </span><br><span class=\"line\">    <span class=\"keyword\">return</span> objClone</span><br><span class=\"line\">&#125;         </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>],</span><br><span class=\"line\">     b = deepClone(a);</span><br><span class=\"line\">a[<span class=\"number\">0</span>] = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a,b)</span><br></pre></td></tr></table></figure>\n\n"},{"layout":"call apply bind","title":"call apply bind的区别和用法","date":"2019-08-22T00:49:23.000Z","_content":"## 前言\n\n在JavaScript中，call、apply和bind是Function对象自带的三个方法，它们最主要的作用是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。\n\n\n## call和applay的共同点\n\n它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。\n\n为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。\n\n改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。\n\n另外，它们的写法也很类似，**调用 call 和 apply 的对象，必须是一个函数 Function。** 接下来，就会说到具体的写法，那也是它们区别的主要体现。\n\n\n## call和apply的区别\n\n它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。\n\n### call的写法\n\n ``` javacript\n Function.call(obj,[param1[,param2[,…[,paramN]]]])\n```\n\n需要注意以下几点：\n\n1. 调用 call 的对象，必须是个函数 Function。<br>\n2. call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。<br>\n3. 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空\n\n ``` javacript\n function func (a,b,c) {}\n\nfunc.call(obj, 1,2,3)\n// func 接收到的参数实际上是 1,2,3\n\nfunc.call(obj, [1,2,3])\n// func 接收到的参数实际上是 [1,2,3],undefined,undefined\n```\n\n### applay的写法\n\n ``` javacript\n Function.apply(obj[,argArray])\n```\n\n需要注意一下几点\n1. 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。<br>\n2. 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。\n\n ``` javacript\nfunc.apply(obj, [1,2,3])\n// func 接收到的参数实际上是 1,2,3\n\nfunc.apply(obj, {\n    0: 1,\n    1: 2,\n    2: 3,\n    length: 3\n})\n// func 接收到的参数实际上是 1,2,3\n```\n\n\n## bind的使用\nbind()函数回创建一个新的函数(称为绑定函数)\n\n* bind是ES5新增的一个方法\n* 传参和call或apply类似\n* 不会执行对应的函数，call或apply会自动执行对应的函数\n* 返回对函数的引用\n  \n\n### bind的写法\n\n ``` javacript\n fun.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\nbind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行。**而 apply 和 call 则是立即调用。\n\n举例说明：\n ``` javacript\n function add (a, b) {\n    return a + b;\n}\n\nfunction sub (a, b) {\n    return a - b;\n}\n\nadd.bind(sub, 5, 3); // 这时，并不会返回 8\nadd.bind(sub, 5, 3)(); // 调用后，返回 8\n```\n如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。\n\n\n## 应用场景：继承\n ``` javacript\n function Animal(name,weight){\n   this.name = name;\n   this.weight = weight;\n}\nfunction Cat(){\n    // 在call中将this作为thisArgs参数传递\n    // Animal方法中的this就指向了Cat中的this\n    // 所以Animal中的this指向的就是cat对象\n    // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性\n    // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的\n    Animal.call(this,'cat','50');\n    //Animal.apply(this,['cat','50']);\n    this.say = function(){\n       console.log(\"I am \" + this.name+\",my weight is \" + this.weight);\n    }\n}\n//当通过new运算符产生了cat时，Cat中的this就指向了cat对象\nvar cat = new Cat();\ncat.say();\n//输出=> I am cat,my weight is 50\n```\n\n## 原型扩展\n在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach\n``` javacript\nfunction test(){\n    // 检测arguments是否为Array的实例\n    console.log(\n        arguments instanceof Array, //false\n        Array.isArray(arguments)  //false\n    );\n    // 判断arguments是否有forEach方法\n    console.log(arguments.forEach); \n    // undefined\n    // 将数组中的forEach应用到arguments上\n    Array.prototype.forEach.call(arguments,function(item){\n        console.log(item); // 1 2 3 4\n    });\n}\ntest(1,2,3,4);\n```\n\n## 总结\ncall 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。\n\nbind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。\n\n关于 call 和 apply 的便捷记忆法：\n```\n猫吃鱼，狗吃肉，奥特曼打小怪兽。\n\n有天狗想吃鱼了\n\n猫.吃鱼.call(狗，鱼)\n\n狗就吃到鱼了\n\n猫成精了，想打怪兽\n\n奥特曼.打小怪兽.call(猫，小怪兽)\n\n猫也可以打小怪兽了\n```","source":"_posts/call apply bind的区别和用法.md","raw":"---\nlayout: call apply bind\ntitle: call apply bind的区别和用法\ndate: 2019-08-22 08:49:23\ntags:\n---\n## 前言\n\n在JavaScript中，call、apply和bind是Function对象自带的三个方法，它们最主要的作用是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。\n\n\n## call和applay的共同点\n\n它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。\n\n为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。\n\n改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。\n\n另外，它们的写法也很类似，**调用 call 和 apply 的对象，必须是一个函数 Function。** 接下来，就会说到具体的写法，那也是它们区别的主要体现。\n\n\n## call和apply的区别\n\n它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。\n\n### call的写法\n\n ``` javacript\n Function.call(obj,[param1[,param2[,…[,paramN]]]])\n```\n\n需要注意以下几点：\n\n1. 调用 call 的对象，必须是个函数 Function。<br>\n2. call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。<br>\n3. 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空\n\n ``` javacript\n function func (a,b,c) {}\n\nfunc.call(obj, 1,2,3)\n// func 接收到的参数实际上是 1,2,3\n\nfunc.call(obj, [1,2,3])\n// func 接收到的参数实际上是 [1,2,3],undefined,undefined\n```\n\n### applay的写法\n\n ``` javacript\n Function.apply(obj[,argArray])\n```\n\n需要注意一下几点\n1. 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。<br>\n2. 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。\n\n ``` javacript\nfunc.apply(obj, [1,2,3])\n// func 接收到的参数实际上是 1,2,3\n\nfunc.apply(obj, {\n    0: 1,\n    1: 2,\n    2: 3,\n    length: 3\n})\n// func 接收到的参数实际上是 1,2,3\n```\n\n\n## bind的使用\nbind()函数回创建一个新的函数(称为绑定函数)\n\n* bind是ES5新增的一个方法\n* 传参和call或apply类似\n* 不会执行对应的函数，call或apply会自动执行对应的函数\n* 返回对函数的引用\n  \n\n### bind的写法\n\n ``` javacript\n fun.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\nbind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行。**而 apply 和 call 则是立即调用。\n\n举例说明：\n ``` javacript\n function add (a, b) {\n    return a + b;\n}\n\nfunction sub (a, b) {\n    return a - b;\n}\n\nadd.bind(sub, 5, 3); // 这时，并不会返回 8\nadd.bind(sub, 5, 3)(); // 调用后，返回 8\n```\n如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。\n\n\n## 应用场景：继承\n ``` javacript\n function Animal(name,weight){\n   this.name = name;\n   this.weight = weight;\n}\nfunction Cat(){\n    // 在call中将this作为thisArgs参数传递\n    // Animal方法中的this就指向了Cat中的this\n    // 所以Animal中的this指向的就是cat对象\n    // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性\n    // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的\n    Animal.call(this,'cat','50');\n    //Animal.apply(this,['cat','50']);\n    this.say = function(){\n       console.log(\"I am \" + this.name+\",my weight is \" + this.weight);\n    }\n}\n//当通过new运算符产生了cat时，Cat中的this就指向了cat对象\nvar cat = new Cat();\ncat.say();\n//输出=> I am cat,my weight is 50\n```\n\n## 原型扩展\n在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach\n``` javacript\nfunction test(){\n    // 检测arguments是否为Array的实例\n    console.log(\n        arguments instanceof Array, //false\n        Array.isArray(arguments)  //false\n    );\n    // 判断arguments是否有forEach方法\n    console.log(arguments.forEach); \n    // undefined\n    // 将数组中的forEach应用到arguments上\n    Array.prototype.forEach.call(arguments,function(item){\n        console.log(item); // 1 2 3 4\n    });\n}\ntest(1,2,3,4);\n```\n\n## 总结\ncall 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。\n\nbind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。\n\n关于 call 和 apply 的便捷记忆法：\n```\n猫吃鱼，狗吃肉，奥特曼打小怪兽。\n\n有天狗想吃鱼了\n\n猫.吃鱼.call(狗，鱼)\n\n狗就吃到鱼了\n\n猫成精了，想打怪兽\n\n奥特曼.打小怪兽.call(猫，小怪兽)\n\n猫也可以打小怪兽了\n```","slug":"call apply bind的区别和用法","published":1,"updated":"2019-09-18T01:43:40.008Z","comments":1,"photos":[],"link":"","_id":"ck2ydufvz00064sefrqlg0nw5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，它们最主要的作用是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。</p>\n<h2 id=\"call和applay的共同点\"><a href=\"#call和applay的共同点\" class=\"headerlink\" title=\"call和applay的共同点\"></a>call和applay的共同点</h2><p>它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p>\n<p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p>\n<p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p>\n<p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function。</strong> 接下来，就会说到具体的写法，那也是它们区别的主要体现。</p>\n<h2 id=\"call和apply的区别\"><a href=\"#call和apply的区别\" class=\"headerlink\" title=\"call和apply的区别\"></a>call和apply的区别</h2><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p>\n<h3 id=\"call的写法\"><a href=\"#call的写法\" class=\"headerlink\" title=\"call的写法\"></a>call的写法</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.call(obj,[param1[,param2[,…[,paramN]]]])</span><br></pre></td></tr></table></figure>\n\n<p>需要注意以下几点：</p>\n<ol>\n<li><p>调用 call 的对象，必须是个函数 Function。<br></p>\n</li>\n<li><p>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。<br></p>\n</li>\n<li><p>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function func (a,b,c) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(obj, 1,2,3)</span><br><span class=\"line\">// func 接收到的参数实际上是 1,2,3</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(obj, [1,2,3])</span><br><span class=\"line\">// func 接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"applay的写法\"><a href=\"#applay的写法\" class=\"headerlink\" title=\"applay的写法\"></a>applay的写法</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure>\n\n<p>需要注意一下几点</p>\n<ol>\n<li><p>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。<br></p>\n</li>\n<li><p>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(obj, [1,2,3])</span><br><span class=\"line\">// func 接收到的参数实际上是 1,2,3</span><br><span class=\"line\"></span><br><span class=\"line\">func.apply(obj, &#123;</span><br><span class=\"line\">    0: 1,</span><br><span class=\"line\">    1: 2,</span><br><span class=\"line\">    2: 3,</span><br><span class=\"line\">    length: 3</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"bind的使用\"><a href=\"#bind的使用\" class=\"headerlink\" title=\"bind的使用\"></a>bind的使用</h2><p>bind()函数回创建一个新的函数(称为绑定函数)</p>\n<ul>\n<li>bind是ES5新增的一个方法</li>\n<li>传参和call或apply类似</li>\n<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>\n<li>返回对函数的引用</li>\n</ul>\n<h3 id=\"bind的写法\"><a href=\"#bind的写法\" class=\"headerlink\" title=\"bind的写法\"></a>bind的写法</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>\n\n<p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，<strong>bind 方法的返回值是函数，并且需要稍后调用，才会执行。</strong>而 apply 和 call 则是立即调用。</p>\n<p>举例说明：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function add (a, b) &#123;</span><br><span class=\"line\">    return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sub (a, b) &#123;</span><br><span class=\"line\">    return a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add.bind(sub, 5, 3); // 这时，并不会返回 8</span><br><span class=\"line\">add.bind(sub, 5, 3)(); // 调用后，返回 8</span><br></pre></td></tr></table></figure></p>\n<p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p>\n<h2 id=\"应用场景：继承\"><a href=\"#应用场景：继承\" class=\"headerlink\" title=\"应用场景：继承\"></a>应用场景：继承</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function Animal(name,weight)&#123;</span><br><span class=\"line\">   this.name = name;</span><br><span class=\"line\">   this.weight = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Cat()&#123;</span><br><span class=\"line\">    // 在call中将this作为thisArgs参数传递</span><br><span class=\"line\">    // Animal方法中的this就指向了Cat中的this</span><br><span class=\"line\">    // 所以Animal中的this指向的就是cat对象</span><br><span class=\"line\">    // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性</span><br><span class=\"line\">    // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的</span><br><span class=\"line\">    Animal.call(this,&apos;cat&apos;,&apos;50&apos;);</span><br><span class=\"line\">    //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]);</span><br><span class=\"line\">    this.say = function()&#123;</span><br><span class=\"line\">       console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//当通过new运算符产生了cat时，Cat中的this就指向了cat对象</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">cat.say();</span><br><span class=\"line\">//输出=&gt; I am cat,my weight is 50</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型扩展\"><a href=\"#原型扩展\" class=\"headerlink\" title=\"原型扩展\"></a>原型扩展</h2><p>在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    // 检测arguments是否为Array的实例</span><br><span class=\"line\">    console.log(</span><br><span class=\"line\">        arguments instanceof Array, //false</span><br><span class=\"line\">        Array.isArray(arguments)  //false</span><br><span class=\"line\">    );</span><br><span class=\"line\">    // 判断arguments是否有forEach方法</span><br><span class=\"line\">    console.log(arguments.forEach); </span><br><span class=\"line\">    // undefined</span><br><span class=\"line\">    // 将数组中的forEach应用到arguments上</span><br><span class=\"line\">    Array.prototype.forEach.call(arguments,function(item)&#123;</span><br><span class=\"line\">        console.log(item); // 1 2 3 4</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(1,2,3,4);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>\n<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>\n<p>关于 call 和 apply 的便捷记忆法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">猫吃鱼，狗吃肉，奥特曼打小怪兽。</span><br><span class=\"line\"></span><br><span class=\"line\">有天狗想吃鱼了</span><br><span class=\"line\"></span><br><span class=\"line\">猫.吃鱼.call(狗，鱼)</span><br><span class=\"line\"></span><br><span class=\"line\">狗就吃到鱼了</span><br><span class=\"line\"></span><br><span class=\"line\">猫成精了，想打怪兽</span><br><span class=\"line\"></span><br><span class=\"line\">奥特曼.打小怪兽.call(猫，小怪兽)</span><br><span class=\"line\"></span><br><span class=\"line\">猫也可以打小怪兽了</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在JavaScript中，call、apply和bind是Function对象自带的三个方法，它们最主要的作用是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。</p>\n<h2 id=\"call和applay的共同点\"><a href=\"#call和applay的共同点\" class=\"headerlink\" title=\"call和applay的共同点\"></a>call和applay的共同点</h2><p>它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。</p>\n<p>为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</p>\n<p>改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。</p>\n<p>另外，它们的写法也很类似，<strong>调用 call 和 apply 的对象，必须是一个函数 Function。</strong> 接下来，就会说到具体的写法，那也是它们区别的主要体现。</p>\n<h2 id=\"call和apply的区别\"><a href=\"#call和apply的区别\" class=\"headerlink\" title=\"call和apply的区别\"></a>call和apply的区别</h2><p>它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。</p>\n<h3 id=\"call的写法\"><a href=\"#call的写法\" class=\"headerlink\" title=\"call的写法\"></a>call的写法</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.call(obj,[param1[,param2[,…[,paramN]]]])</span><br></pre></td></tr></table></figure>\n\n<p>需要注意以下几点：</p>\n<ol>\n<li><p>调用 call 的对象，必须是个函数 Function。<br></p>\n</li>\n<li><p>call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。<br></p>\n</li>\n<li><p>第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function func (a,b,c) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(obj, 1,2,3)</span><br><span class=\"line\">// func 接收到的参数实际上是 1,2,3</span><br><span class=\"line\"></span><br><span class=\"line\">func.call(obj, [1,2,3])</span><br><span class=\"line\">// func 接收到的参数实际上是 [1,2,3],undefined,undefined</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h3 id=\"applay的写法\"><a href=\"#applay的写法\" class=\"headerlink\" title=\"applay的写法\"></a>applay的写法</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Function.apply(obj[,argArray])</span><br></pre></td></tr></table></figure>\n\n<p>需要注意一下几点</p>\n<ol>\n<li><p>它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。<br></p>\n</li>\n<li><p>第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(obj, [1,2,3])</span><br><span class=\"line\">// func 接收到的参数实际上是 1,2,3</span><br><span class=\"line\"></span><br><span class=\"line\">func.apply(obj, &#123;</span><br><span class=\"line\">    0: 1,</span><br><span class=\"line\">    1: 2,</span><br><span class=\"line\">    2: 3,</span><br><span class=\"line\">    length: 3</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// func 接收到的参数实际上是 1,2,3</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<h2 id=\"bind的使用\"><a href=\"#bind的使用\" class=\"headerlink\" title=\"bind的使用\"></a>bind的使用</h2><p>bind()函数回创建一个新的函数(称为绑定函数)</p>\n<ul>\n<li>bind是ES5新增的一个方法</li>\n<li>传参和call或apply类似</li>\n<li>不会执行对应的函数，call或apply会自动执行对应的函数</li>\n<li>返回对函数的引用</li>\n</ul>\n<h3 id=\"bind的写法\"><a href=\"#bind的写法\" class=\"headerlink\" title=\"bind的写法\"></a>bind的写法</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fun.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>\n\n<p>bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，<strong>bind 方法的返回值是函数，并且需要稍后调用，才会执行。</strong>而 apply 和 call 则是立即调用。</p>\n<p>举例说明：<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function add (a, b) &#123;</span><br><span class=\"line\">    return a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function sub (a, b) &#123;</span><br><span class=\"line\">    return a - b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add.bind(sub, 5, 3); // 这时，并不会返回 8</span><br><span class=\"line\">add.bind(sub, 5, 3)(); // 调用后，返回 8</span><br></pre></td></tr></table></figure></p>\n<p>如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。</p>\n<h2 id=\"应用场景：继承\"><a href=\"#应用场景：继承\" class=\"headerlink\" title=\"应用场景：继承\"></a>应用场景：继承</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function Animal(name,weight)&#123;</span><br><span class=\"line\">   this.name = name;</span><br><span class=\"line\">   this.weight = weight;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Cat()&#123;</span><br><span class=\"line\">    // 在call中将this作为thisArgs参数传递</span><br><span class=\"line\">    // Animal方法中的this就指向了Cat中的this</span><br><span class=\"line\">    // 所以Animal中的this指向的就是cat对象</span><br><span class=\"line\">    // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性</span><br><span class=\"line\">    // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的</span><br><span class=\"line\">    Animal.call(this,&apos;cat&apos;,&apos;50&apos;);</span><br><span class=\"line\">    //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]);</span><br><span class=\"line\">    this.say = function()&#123;</span><br><span class=\"line\">       console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//当通过new运算符产生了cat时，Cat中的this就指向了cat对象</span><br><span class=\"line\">var cat = new Cat();</span><br><span class=\"line\">cat.say();</span><br><span class=\"line\">//输出=&gt; I am cat,my weight is 50</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"原型扩展\"><a href=\"#原型扩展\" class=\"headerlink\" title=\"原型扩展\"></a>原型扩展</h2><p>在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    // 检测arguments是否为Array的实例</span><br><span class=\"line\">    console.log(</span><br><span class=\"line\">        arguments instanceof Array, //false</span><br><span class=\"line\">        Array.isArray(arguments)  //false</span><br><span class=\"line\">    );</span><br><span class=\"line\">    // 判断arguments是否有forEach方法</span><br><span class=\"line\">    console.log(arguments.forEach); </span><br><span class=\"line\">    // undefined</span><br><span class=\"line\">    // 将数组中的forEach应用到arguments上</span><br><span class=\"line\">    Array.prototype.forEach.call(arguments,function(item)&#123;</span><br><span class=\"line\">        console.log(item); // 1 2 3 4</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(1,2,3,4);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。</p>\n<p>bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。</p>\n<p>关于 call 和 apply 的便捷记忆法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">猫吃鱼，狗吃肉，奥特曼打小怪兽。</span><br><span class=\"line\"></span><br><span class=\"line\">有天狗想吃鱼了</span><br><span class=\"line\"></span><br><span class=\"line\">猫.吃鱼.call(狗，鱼)</span><br><span class=\"line\"></span><br><span class=\"line\">狗就吃到鱼了</span><br><span class=\"line\"></span><br><span class=\"line\">猫成精了，想打怪兽</span><br><span class=\"line\"></span><br><span class=\"line\">奥特曼.打小怪兽.call(猫，小怪兽)</span><br><span class=\"line\"></span><br><span class=\"line\">猫也可以打小怪兽了</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","date":"2019-08-06T02:40:30.000Z","_content":"\n\n## 前言\n前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。\n\n## 使用方式\n### cookie：\n **保存cookie值** \n\n ``` javacript\n\n var dataCookie='110';\n    document.cookie = 'token' + \"=\" +dataCookie;\n\n```\n\n**获取指定名称的cookie值**\n``` javacript  \n\n  function getCookie(name) { //获取指定名称的cookie值\n// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；\nvar arr = document.cookie.match(new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"));\nif(arr != null) {\n  console.log(arr);\n  return unescape(arr[2]);\n}\nreturn null;\n}\n var cookieData=getCookie('token'); //cookie赋值给变量。\n\n```\n\n### localStorage和sessionStorage：\n**localStorage和sessionStorage所使用的方法是一样的,** 下面以sessionStorage为例子：\n\n``` javacript\n\nvar name='sessionData';\nvar num=120;\nsessionStorage.setItem(name,num);//存储数据\nsessionStorage.setItem('value2',119);\nlet dataAll=sessionStorage.valueOf();//获取全部数据\nconsole.log(dataAll,'获取全部数据');\nvar dataSession=sessionStorage.getItem(name);//获取指定键名数据\nvar dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值\n console.log(dataSession,dataSession2,'获取指定键名数据');\nsessionStorage.removeItem(name); //删除指定键名数据\n  console.log(dataAll,'获取全部数据1');\n sessionStorage.clear();//清空缓存数据：localStorage.clear();\n  console.log(dataAll,'获取全部数据2'); \n\n```\n\n## 三者的异同：\n\n### 生命周期：\n * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\n\n * localStorage：除非被手动清除，否则将会永久保存。\n\n * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。\n\n### 存放数据大小：\n * cookie：4kb左右 \n\n * localStorage和sessionStorage：可以保存5MB的信息\n\n### http请求：\n * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n\n * localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n## 应用场景：\n从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。\n\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。\n\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\n\n## 浏览器的支持情况:\n * localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。\n ![storage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"storage\")\n\n * cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：\n\n ``` javacript\n\nif(navigator.cookieEnabled) {\n  alert(\"你的浏览器支持cookie功能\");//提示浏览器支持cookie  \n} else {\n  alert(\"你的浏览器不支持cookie\");//提示浏览器不支持cookie   }\n\n\n```\n\n### 数据存放处：\n ![dataStorage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"dataStorage\")<center><font color=gray size=2>Cookie、localStorage、sessionStorage数据存放处</font></center>\n\n ### 各浏览器Cookie大小、个数的限制\n  **1. 浏览器允许每个域名所包含的cookie数：**\n\n     Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\n     Firefox每个域名cookie限制为50个。\n\n     Opera每个域名cookie限制为30个。\n\n     Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n     注：“每个域名cookie限制为20个”将不再正确！\n\n  **2. 当很多的cookie被设置，浏览器如何去响应：**\n\n     除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n     最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\n     Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。\n\n  **3. 不同浏览器间cookie总大小也不同：**\n\n     Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\n     Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\n     Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n     注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。\n\n\n## 最后：\n不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。\n","source":"_posts/cookie、localstorage和sessionstorage三者之间的区别以及使用方式.md","raw":"---\nlayout: post\ntitle: cookie、localstorage和sessionstorage三者之间的区别以及使用方式\ndate: 2019-08-06 10:40:30\ntags:\n---\n\n\n## 前言\n前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。\n\n## 使用方式\n### cookie：\n **保存cookie值** \n\n ``` javacript\n\n var dataCookie='110';\n    document.cookie = 'token' + \"=\" +dataCookie;\n\n```\n\n**获取指定名称的cookie值**\n``` javacript  \n\n  function getCookie(name) { //获取指定名称的cookie值\n// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；\nvar arr = document.cookie.match(new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"));\nif(arr != null) {\n  console.log(arr);\n  return unescape(arr[2]);\n}\nreturn null;\n}\n var cookieData=getCookie('token'); //cookie赋值给变量。\n\n```\n\n### localStorage和sessionStorage：\n**localStorage和sessionStorage所使用的方法是一样的,** 下面以sessionStorage为例子：\n\n``` javacript\n\nvar name='sessionData';\nvar num=120;\nsessionStorage.setItem(name,num);//存储数据\nsessionStorage.setItem('value2',119);\nlet dataAll=sessionStorage.valueOf();//获取全部数据\nconsole.log(dataAll,'获取全部数据');\nvar dataSession=sessionStorage.getItem(name);//获取指定键名数据\nvar dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值\n console.log(dataSession,dataSession2,'获取指定键名数据');\nsessionStorage.removeItem(name); //删除指定键名数据\n  console.log(dataAll,'获取全部数据1');\n sessionStorage.clear();//清空缓存数据：localStorage.clear();\n  console.log(dataAll,'获取全部数据2'); \n\n```\n\n## 三者的异同：\n\n### 生命周期：\n * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\n\n * localStorage：除非被手动清除，否则将会永久保存。\n\n * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。\n\n### 存放数据大小：\n * cookie：4kb左右 \n\n * localStorage和sessionStorage：可以保存5MB的信息\n\n### http请求：\n * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n\n * localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n## 应用场景：\n从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。\n\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。\n\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\n\n## 浏览器的支持情况:\n * localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。\n ![storage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"storage\")\n\n * cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：\n\n ``` javacript\n\nif(navigator.cookieEnabled) {\n  alert(\"你的浏览器支持cookie功能\");//提示浏览器支持cookie  \n} else {\n  alert(\"你的浏览器不支持cookie\");//提示浏览器不支持cookie   }\n\n\n```\n\n### 数据存放处：\n ![dataStorage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"dataStorage\")<center><font color=gray size=2>Cookie、localStorage、sessionStorage数据存放处</font></center>\n\n ### 各浏览器Cookie大小、个数的限制\n  **1. 浏览器允许每个域名所包含的cookie数：**\n\n     Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\n     Firefox每个域名cookie限制为50个。\n\n     Opera每个域名cookie限制为30个。\n\n     Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n     注：“每个域名cookie限制为20个”将不再正确！\n\n  **2. 当很多的cookie被设置，浏览器如何去响应：**\n\n     除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n     最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\n     Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。\n\n  **3. 不同浏览器间cookie总大小也不同：**\n\n     Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\n     Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\n     Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n     注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。\n\n\n## 最后：\n不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。\n","slug":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","published":1,"updated":"2019-09-18T01:43:40.009Z","comments":1,"photos":[],"link":"","_id":"ck2ydufw000074sefqh1k7zrm","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"cookie：\"><a href=\"#cookie：\" class=\"headerlink\" title=\"cookie：\"></a>cookie：</h3><p> <strong>保存cookie值</strong> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var dataCookie=&apos;110&apos;;</span><br><span class=\"line\">   document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取指定名称的cookie值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  function getCookie(name) &#123; //获取指定名称的cookie值</span><br><span class=\"line\">// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；</span><br><span class=\"line\">var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class=\"line\">if(arr != null) &#123;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">  return unescape(arr[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage和sessionStorage：\"><a href=\"#localStorage和sessionStorage：\" class=\"headerlink\" title=\"localStorage和sessionStorage：\"></a>localStorage和sessionStorage：</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的,</strong> 下面以sessionStorage为例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var name=&apos;sessionData&apos;;</span><br><span class=\"line\">var num=120;</span><br><span class=\"line\">sessionStorage.setItem(name,num);//存储数据</span><br><span class=\"line\">sessionStorage.setItem(&apos;value2&apos;,119);</span><br><span class=\"line\">let dataAll=sessionStorage.valueOf();//获取全部数据</span><br><span class=\"line\">console.log(dataAll,&apos;获取全部数据&apos;);</span><br><span class=\"line\">var dataSession=sessionStorage.getItem(name);//获取指定键名数据</span><br><span class=\"line\">var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值</span><br><span class=\"line\"> console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);</span><br><span class=\"line\">sessionStorage.removeItem(name); //删除指定键名数据</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据1&apos;);</span><br><span class=\"line\"> sessionStorage.clear();//清空缓存数据：localStorage.clear();</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据2&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三者的异同：\"><a href=\"#三者的异同：\" class=\"headerlink\" title=\"三者的异同：\"></a>三者的异同：</h2><h3 id=\"生命周期：\"><a href=\"#生命周期：\" class=\"headerlink\" title=\"生命周期：\"></a>生命周期：</h3><ul>\n<li><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p>\n</li>\n<li><p>localStorage：除非被手动清除，否则将会永久保存。</p>\n</li>\n<li><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p>\n</li>\n</ul>\n<h3 id=\"存放数据大小：\"><a href=\"#存放数据大小：\" class=\"headerlink\" title=\"存放数据大小：\"></a>存放数据大小：</h3><ul>\n<li><p>cookie：4kb左右 </p>\n</li>\n<li><p>localStorage和sessionStorage：可以保存5MB的信息</p>\n</li>\n</ul>\n<h3 id=\"http请求：\"><a href=\"#http请求：\" class=\"headerlink\" title=\"http请求：\"></a>http请求：</h3><ul>\n<li><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</li>\n<li><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>\n</li>\n</ul>\n<h2 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p>\n<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。</p>\n<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p>\n<h2 id=\"浏览器的支持情况\"><a href=\"#浏览器的支持情况\" class=\"headerlink\" title=\"浏览器的支持情况:\"></a>浏览器的支持情况:</h2><ul>\n<li><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。<br><img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"storage\" title=\"storage\"></p>\n</li>\n<li><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(navigator.cookieEnabled) &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  </span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"数据存放处：\"><a href=\"#数据存放处：\" class=\"headerlink\" title=\"数据存放处：\"></a>数据存放处：</h3><p> <img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"dataStorage\" title=\"dataStorage\"><center><font color=\"gray\" size=\"2\">Cookie、localStorage、sessionStorage数据存放处</font></center></p>\n<h3 id=\"各浏览器Cookie大小、个数的限制\"><a href=\"#各浏览器Cookie大小、个数的限制\" class=\"headerlink\" title=\"各浏览器Cookie大小、个数的限制\"></a>各浏览器Cookie大小、个数的限制</h3><p>  <strong>1. 浏览器允许每个域名所包含的cookie数：</strong></p>\n<pre><code>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\nFirefox每个域名cookie限制为50个。\n\nOpera每个域名cookie限制为30个。\n\nSafari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n注：“每个域名cookie限制为20个”将不再正确！</code></pre><p>  <strong>2. 当很多的cookie被设置，浏览器如何去响应：</strong></p>\n<pre><code>除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\nFirefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</code></pre><p>  <strong>3. 不同浏览器间cookie总大小也不同：</strong></p>\n<pre><code>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\nOpera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\nInternet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</code></pre><h2 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h2><p>不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"cookie：\"><a href=\"#cookie：\" class=\"headerlink\" title=\"cookie：\"></a>cookie：</h3><p> <strong>保存cookie值</strong> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var dataCookie=&apos;110&apos;;</span><br><span class=\"line\">   document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取指定名称的cookie值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  function getCookie(name) &#123; //获取指定名称的cookie值</span><br><span class=\"line\">// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；</span><br><span class=\"line\">var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class=\"line\">if(arr != null) &#123;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">  return unescape(arr[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage和sessionStorage：\"><a href=\"#localStorage和sessionStorage：\" class=\"headerlink\" title=\"localStorage和sessionStorage：\"></a>localStorage和sessionStorage：</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的,</strong> 下面以sessionStorage为例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var name=&apos;sessionData&apos;;</span><br><span class=\"line\">var num=120;</span><br><span class=\"line\">sessionStorage.setItem(name,num);//存储数据</span><br><span class=\"line\">sessionStorage.setItem(&apos;value2&apos;,119);</span><br><span class=\"line\">let dataAll=sessionStorage.valueOf();//获取全部数据</span><br><span class=\"line\">console.log(dataAll,&apos;获取全部数据&apos;);</span><br><span class=\"line\">var dataSession=sessionStorage.getItem(name);//获取指定键名数据</span><br><span class=\"line\">var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值</span><br><span class=\"line\"> console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);</span><br><span class=\"line\">sessionStorage.removeItem(name); //删除指定键名数据</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据1&apos;);</span><br><span class=\"line\"> sessionStorage.clear();//清空缓存数据：localStorage.clear();</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据2&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三者的异同：\"><a href=\"#三者的异同：\" class=\"headerlink\" title=\"三者的异同：\"></a>三者的异同：</h2><h3 id=\"生命周期：\"><a href=\"#生命周期：\" class=\"headerlink\" title=\"生命周期：\"></a>生命周期：</h3><ul>\n<li><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p>\n</li>\n<li><p>localStorage：除非被手动清除，否则将会永久保存。</p>\n</li>\n<li><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p>\n</li>\n</ul>\n<h3 id=\"存放数据大小：\"><a href=\"#存放数据大小：\" class=\"headerlink\" title=\"存放数据大小：\"></a>存放数据大小：</h3><ul>\n<li><p>cookie：4kb左右 </p>\n</li>\n<li><p>localStorage和sessionStorage：可以保存5MB的信息</p>\n</li>\n</ul>\n<h3 id=\"http请求：\"><a href=\"#http请求：\" class=\"headerlink\" title=\"http请求：\"></a>http请求：</h3><ul>\n<li><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</li>\n<li><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>\n</li>\n</ul>\n<h2 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p>\n<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。</p>\n<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p>\n<h2 id=\"浏览器的支持情况\"><a href=\"#浏览器的支持情况\" class=\"headerlink\" title=\"浏览器的支持情况:\"></a>浏览器的支持情况:</h2><ul>\n<li><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。<br><img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"storage\" title=\"storage\"></p>\n</li>\n<li><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(navigator.cookieEnabled) &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  </span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"数据存放处：\"><a href=\"#数据存放处：\" class=\"headerlink\" title=\"数据存放处：\"></a>数据存放处：</h3><p> <img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"dataStorage\" title=\"dataStorage\"><center><font color=\"gray\" size=\"2\">Cookie、localStorage、sessionStorage数据存放处</font></center></p>\n<h3 id=\"各浏览器Cookie大小、个数的限制\"><a href=\"#各浏览器Cookie大小、个数的限制\" class=\"headerlink\" title=\"各浏览器Cookie大小、个数的限制\"></a>各浏览器Cookie大小、个数的限制</h3><p>  <strong>1. 浏览器允许每个域名所包含的cookie数：</strong></p>\n<pre><code>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\nFirefox每个域名cookie限制为50个。\n\nOpera每个域名cookie限制为30个。\n\nSafari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n注：“每个域名cookie限制为20个”将不再正确！</code></pre><p>  <strong>2. 当很多的cookie被设置，浏览器如何去响应：</strong></p>\n<pre><code>除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\nFirefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</code></pre><p>  <strong>3. 不同浏览器间cookie总大小也不同：</strong></p>\n<pre><code>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\nOpera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\nInternet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</code></pre><h2 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h2><p>不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p>\n"},{"title":"gulp入门(三)","date":"2019-11-13T05:52:14.000Z","author":"胡豪","_content":"\n## gulp3改造gulp4\ngulp3与gulp4的写法存在区别，此篇用来对比整个项目gulpfile.js文件的异同。\n如果你安装的是gulp3，想升级使用gulp4，可以使用命令`npm install gulp@4.0`\n\n如果你安装的是gulp4，想h回退使用gulp3，可以使用命令`npm install gulp@3.9.1 `\n\n### gulp@3.9.1版本\n```js\nconst gulp = require(\"gulp\");//全局gulp\nconst uglify = require(\"gulp-uglify\"); //压缩js\nconst gulpif = require(\"gulp-if\");//if条件\nconst cssUglify = require('gulp-minify-css');\nconst gulpclean = require(\"gulp-clean\");//清除文件\n\n//过滤条件\nvar conditionJs = function(f) { \n  if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) {\n    return false;\n  } \n  return true;\n};\nvar conditionCss = function(f) { \n  if (f.path.indexOf(\".min.css\", f.path.length - \".min.css\".length) !== -1) {\n    return false;\n  } \n  return true;\n};\n\n\ngulp.task('clean' , function(){\n  gulp.src([\n     //'dist', //删除dist整个文件夹\n     'dist/*', //删除dist下的test写任意子文件夹里的文件\n     '!package.json'  //不删除package.json文件\n    ] ).pipe(gulpclean());\n});\n\ngulp.task('html', function () {\n  gulp.src([\"src/*.html\",\"src/favicon.ico\"])\n      .pipe(gulp.dest(\"dist/\"))\n})\n\ngulp.task('css',function(){\n  gulp.src('src/css/*.css')\n      .pipe(gulpif(conditionCss, cssUglify())) \n      .pipe(gulp.dest('dist/css'))\n})\ngulp.task('cssmin',['css'], function () {\n  gulp.src('src/css/font/*')\n      .pipe(gulp.dest(\"dist/css/font\"));\n})\n\n//压缩js文件\ngulp.task(\"js\", function() {\n  //找到文件\n  gulp.src(\"src/js/*.js\") \n      //压缩文件\n      .pipe(gulpif(conditionJs, uglify()))\n      //保存压缩后的文件 \n      .pipe(gulp.dest(\"dist/js\"));\n});\n//拷贝不需要处理js的文件\ngulp.task('jsmin',['js'], function () {\n  gulp.src('src/js/layer/**')\n      .pipe(gulp.dest(\"dist/js/layer\"));\n})\n\ngulp.task('copyImage',['js'], function () {\n  gulp.src('src/img/**/* ') \n      .pipe(gulp.dest(\"dist/img\"));\n})\n\ngulp.task(\"build\", [\"html\",\"cssmin\",\"jsmin\",\"copyImage\"]);\n```\n\n### gulp@4版本\n","source":"_posts/gulp入门（三）.md","raw":"---\ntitle: gulp入门(三)\ndate: 2019-11-13 13:52:14\nauthor: 胡豪\ncategories:\n  - gulp\ntags:\n  - gulp\n---\n\n## gulp3改造gulp4\ngulp3与gulp4的写法存在区别，此篇用来对比整个项目gulpfile.js文件的异同。\n如果你安装的是gulp3，想升级使用gulp4，可以使用命令`npm install gulp@4.0`\n\n如果你安装的是gulp4，想h回退使用gulp3，可以使用命令`npm install gulp@3.9.1 `\n\n### gulp@3.9.1版本\n```js\nconst gulp = require(\"gulp\");//全局gulp\nconst uglify = require(\"gulp-uglify\"); //压缩js\nconst gulpif = require(\"gulp-if\");//if条件\nconst cssUglify = require('gulp-minify-css');\nconst gulpclean = require(\"gulp-clean\");//清除文件\n\n//过滤条件\nvar conditionJs = function(f) { \n  if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) {\n    return false;\n  } \n  return true;\n};\nvar conditionCss = function(f) { \n  if (f.path.indexOf(\".min.css\", f.path.length - \".min.css\".length) !== -1) {\n    return false;\n  } \n  return true;\n};\n\n\ngulp.task('clean' , function(){\n  gulp.src([\n     //'dist', //删除dist整个文件夹\n     'dist/*', //删除dist下的test写任意子文件夹里的文件\n     '!package.json'  //不删除package.json文件\n    ] ).pipe(gulpclean());\n});\n\ngulp.task('html', function () {\n  gulp.src([\"src/*.html\",\"src/favicon.ico\"])\n      .pipe(gulp.dest(\"dist/\"))\n})\n\ngulp.task('css',function(){\n  gulp.src('src/css/*.css')\n      .pipe(gulpif(conditionCss, cssUglify())) \n      .pipe(gulp.dest('dist/css'))\n})\ngulp.task('cssmin',['css'], function () {\n  gulp.src('src/css/font/*')\n      .pipe(gulp.dest(\"dist/css/font\"));\n})\n\n//压缩js文件\ngulp.task(\"js\", function() {\n  //找到文件\n  gulp.src(\"src/js/*.js\") \n      //压缩文件\n      .pipe(gulpif(conditionJs, uglify()))\n      //保存压缩后的文件 \n      .pipe(gulp.dest(\"dist/js\"));\n});\n//拷贝不需要处理js的文件\ngulp.task('jsmin',['js'], function () {\n  gulp.src('src/js/layer/**')\n      .pipe(gulp.dest(\"dist/js/layer\"));\n})\n\ngulp.task('copyImage',['js'], function () {\n  gulp.src('src/img/**/* ') \n      .pipe(gulp.dest(\"dist/img\"));\n})\n\ngulp.task(\"build\", [\"html\",\"cssmin\",\"jsmin\",\"copyImage\"]);\n```\n\n### gulp@4版本\n","slug":"gulp入门（三）","published":1,"updated":"2019-11-14T07:17:34.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufw3000b4seflxes8tlg","content":"<h2 id=\"gulp3改造gulp4\"><a href=\"#gulp3改造gulp4\" class=\"headerlink\" title=\"gulp3改造gulp4\"></a>gulp3改造gulp4</h2><p>gulp3与gulp4的写法存在区别，此篇用来对比整个项目gulpfile.js文件的异同。<br>如果你安装的是gulp3，想升级使用gulp4，可以使用命令<code>npm install gulp@4.0</code></p>\n<p>如果你安装的是gulp4，想h回退使用gulp3，可以使用命令<code>npm install gulp@3.9.1</code></p>\n<h3 id=\"gulp-3-9-1版本\"><a href=\"#gulp-3-9-1版本\" class=\"headerlink\" title=\"gulp@3.9.1版本\"></a><a href=\"mailto:gulp@3.9.1\" target=\"_blank\" rel=\"noopener\">gulp@3.9.1</a>版本</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);<span class=\"comment\">//全局gulp</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-uglify\"</span>); <span class=\"comment\">//压缩js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gulpif = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-if\"</span>);<span class=\"comment\">//if条件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cssUglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-minify-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> gulpclean = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-clean\"</span>);<span class=\"comment\">//清除文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//过滤条件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> conditionJs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f.path.indexOf(<span class=\"string\">\".min.js\"</span>, f.path.length - <span class=\"string\">\".min.js\"</span>.length) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> conditionCss = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f.path.indexOf(<span class=\"string\">\".min.css\"</span>, f.path.length - <span class=\"string\">\".min.css\"</span>.length) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'clean'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  gulp.src([</span><br><span class=\"line\">     <span class=\"comment\">//'dist', //删除dist整个文件夹</span></span><br><span class=\"line\">     <span class=\"string\">'dist/*'</span>, <span class=\"comment\">//删除dist下的test写任意子文件夹里的文件</span></span><br><span class=\"line\">     <span class=\"string\">'!package.json'</span>  <span class=\"comment\">//不删除package.json文件</span></span><br><span class=\"line\">    ] ).pipe(gulpclean());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src([<span class=\"string\">\"src/*.html\"</span>,<span class=\"string\">\"src/favicon.ico\"</span>])</span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'css'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/css/*.css'</span>)</span><br><span class=\"line\">      .pipe(gulpif(conditionCss, cssUglify())) </span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">gulp.task(<span class=\"string\">'cssmin'</span>,[<span class=\"string\">'css'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/css/font/*'</span>)</span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/css/font\"</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  gulp.src(<span class=\"string\">\"src/js/*.js\"</span>) </span><br><span class=\"line\">      <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">      .pipe(gulpif(conditionJs, uglify()))</span><br><span class=\"line\">      <span class=\"comment\">//保存压缩后的文件 </span></span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//拷贝不需要处理js的文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'jsmin'</span>,[<span class=\"string\">'js'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/js/layer/**'</span>)</span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/js/layer\"</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'copyImage'</span>,[<span class=\"string\">'js'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/img/**/* '</span>) </span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/img\"</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"build\"</span>, [<span class=\"string\">\"html\"</span>,<span class=\"string\">\"cssmin\"</span>,<span class=\"string\">\"jsmin\"</span>,<span class=\"string\">\"copyImage\"</span>]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"gulp-4版本\"><a href=\"#gulp-4版本\" class=\"headerlink\" title=\"gulp@4版本\"></a>gulp@4版本</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"gulp3改造gulp4\"><a href=\"#gulp3改造gulp4\" class=\"headerlink\" title=\"gulp3改造gulp4\"></a>gulp3改造gulp4</h2><p>gulp3与gulp4的写法存在区别，此篇用来对比整个项目gulpfile.js文件的异同。<br>如果你安装的是gulp3，想升级使用gulp4，可以使用命令<code>npm install gulp@4.0</code></p>\n<p>如果你安装的是gulp4，想h回退使用gulp3，可以使用命令<code>npm install gulp@3.9.1</code></p>\n<h3 id=\"gulp-3-9-1版本\"><a href=\"#gulp-3-9-1版本\" class=\"headerlink\" title=\"gulp@3.9.1版本\"></a><a href=\"mailto:gulp@3.9.1\" target=\"_blank\" rel=\"noopener\">gulp@3.9.1</a>版本</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);<span class=\"comment\">//全局gulp</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-uglify\"</span>); <span class=\"comment\">//压缩js</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> gulpif = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-if\"</span>);<span class=\"comment\">//if条件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> cssUglify = <span class=\"built_in\">require</span>(<span class=\"string\">'gulp-minify-css'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> gulpclean = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-clean\"</span>);<span class=\"comment\">//清除文件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//过滤条件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> conditionJs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f.path.indexOf(<span class=\"string\">\".min.js\"</span>, f.path.length - <span class=\"string\">\".min.js\"</span>.length) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> conditionCss = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f.path.indexOf(<span class=\"string\">\".min.css\"</span>, f.path.length - <span class=\"string\">\".min.css\"</span>.length) !== <span class=\"number\">-1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'clean'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  gulp.src([</span><br><span class=\"line\">     <span class=\"comment\">//'dist', //删除dist整个文件夹</span></span><br><span class=\"line\">     <span class=\"string\">'dist/*'</span>, <span class=\"comment\">//删除dist下的test写任意子文件夹里的文件</span></span><br><span class=\"line\">     <span class=\"string\">'!package.json'</span>  <span class=\"comment\">//不删除package.json文件</span></span><br><span class=\"line\">    ] ).pipe(gulpclean());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'html'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src([<span class=\"string\">\"src/*.html\"</span>,<span class=\"string\">\"src/favicon.ico\"</span>])</span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/\"</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'css'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/css/*.css'</span>)</span><br><span class=\"line\">      .pipe(gulpif(conditionCss, cssUglify())) </span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">'dist/css'</span>))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">gulp.task(<span class=\"string\">'cssmin'</span>,[<span class=\"string\">'css'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/css/font/*'</span>)</span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/css/font\"</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"js\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  gulp.src(<span class=\"string\">\"src/js/*.js\"</span>) </span><br><span class=\"line\">      <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">      .pipe(gulpif(conditionJs, uglify()))</span><br><span class=\"line\">      <span class=\"comment\">//保存压缩后的文件 </span></span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">//拷贝不需要处理js的文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">'jsmin'</span>,[<span class=\"string\">'js'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/js/layer/**'</span>)</span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/js/layer\"</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">'copyImage'</span>,[<span class=\"string\">'js'</span>], <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  gulp.src(<span class=\"string\">'src/img/**/* '</span>) </span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/img\"</span>));</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"build\"</span>, [<span class=\"string\">\"html\"</span>,<span class=\"string\">\"cssmin\"</span>,<span class=\"string\">\"jsmin\"</span>,<span class=\"string\">\"copyImage\"</span>]);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"gulp-4版本\"><a href=\"#gulp-4版本\" class=\"headerlink\" title=\"gulp@4版本\"></a>gulp@4版本</h3>"},{"title":"gulp入门(一)","date":"2019-11-07T05:31:50.000Z","author":"胡豪","_content":"\n## 前言\n说到前端常见的构建工具，有Webpack/Grunt/Gulp  \n这里简述一下它们都是干什么的：  \nGrunt 和 Gulp 是非常相似的东西，能实现的功能是一样的，当然你可能 Gulp 听的 Grunt 多，通俗的讲，可以把 Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。  \nWebpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块(JavaScript、CSS、SCSS、图片、模板)，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。使用Vue的小伙伴再熟悉不过，Webpack 专注于构建模块化项目。Webpack的缺点也很明显是只能用于采用模块化开发的项目。  \n今天重点讲gulp；\n\n\n## Gulp是什么？\n\nGulp是前端自动化的工具，它能用来做很多很多繁琐的事情，大大便利了前端开发工作流程\n\n1. 搭建web服务器\n2. 使用预处理器Sass，Less\n3. 压缩优化，可以压缩JS CSS Html 图片\n4. 自动将更新变化的代码实时显示在浏览器\n5. 前端测试  \n...... \n\n## 快速入门\nGulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5种个方法就可以胜任几乎所有构建场景：\n\n- 通过 gulp.task 注册一个任务；\n- 通过 gulp.run 执行任务；\n- 通过 gulp.watch 监听文件变化；\n- 通过 gulp.src 读取文件；\n- 通过 gulp.dest 写文件。\n\n### 简单语法\n1. gulp.task(name[,deps],fn)\n说明：定义一个gulp任务\nname: 类型(必填)：String 指定任务的名称（不应该有空格）\ndeps:类型(可选)：StringArray，该任务依赖的任务（执行name任务要先去执行的任务）\n```js\ngulp.task('A' , function(){\n   console.log('A') \n});\ngulp.task('B' , ['A'] , function(){ //运行B之前先去运行A\n   console.log('B')\n});\n```\n\n2. gulp.src(globs[, options])\n说明：src方法指定需要处理的源文件路径，返回当前文件流至可用插件  \n\nglobs: 类型(必填)：String/StringArray  需要处理的源文件匹配符路径  \n\n通配符路径匹配示例：\n　　“src/a.js”：指定具体文件；  \n　　“*”：匹配所有文件    例：src/*.js(包含src下的所有js文件)；  \n　　“**”：匹配0个或多个子文件夹    例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；  \n　　“{}”：匹配多个属性    例：src/{a,b}.js(包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；  \n　　“!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；  \n\noptions:类型(可选)：Object 三个属性 buffer read base  \n　　options.buffer：类型：Boolean  默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；  \n　　options.read：  类型：Boolean  默认：true 设置false，将不执行读取文件操作，返回null；  \n　　options.base：  类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接\n```js\ngulp.src('client/js/**/*.js') \n  .pipe(minify())\n  .pipe(gulp.dest('build'));   \n \ngulp.src('client/js/**/*.js', { base: 'client' })\n  .pipe(minify())\n  .pipe(gulp.dest('build'));   \n```\n\n3. gulp.dest(path[,options])  \n说明：watch方法用于监听文件变化，一被变化就执行指定任务  \nglob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；  \nopts：  类型(可选)：Object 具体参看https://github.com/shama/gaze；  \ntasks：  类型(必填)：StringArray 需要执行的任务的名称数组；  \ncb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；\n```js\n.pipe(gulp.dest('build')); \n```\n\n4. gulp.watch(glob[,opts],tasks) or gulp.task(glob [,opts ,cd])  \n说明：watch方法用于监听文件变化，一被变化就执行指定任务  \nglob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；  \nopts：  类型(可选)：Object 具体参看https://github.com/shama/gaze；  \ntasks：  类型(必填)：StringArray 需要执行的任务的名称数组；  \ncb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；\n\n\n## 如何写\n首先创建 gulpfile 文件  \n利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件  \n各个API就不讲了，官网都有，[Gulp官网直通车](https://www.gulpjs.com.cn/docs/api/concepts/) \n\n\n1. 项目初始化 `npm init` \n2. 安装全局gulp \n```js\nnpm install gulp -g //全局安装\nnpm install gulp --save-dev //本地安装并加入package.json\n```\n3. 这里用了一个gulp插件 gulp-uglify，安装 `npm i gulp-uglify -D`\n4. 定义一个gulp任务`gulp.task(name[,deps],fn)`   \n\n就先写个压缩 js 吧\n```js\nconst gulp = require(\"gulp\");//全局gulp\nconst uglify = require(\"gulp-uglify\"); //压缩js\n\n  //压缩js文件\n  gulp.task(\"script\", function() {\n    //找到文件\n    gulp\n      .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\"));\n  });\n```\n5. 运行gulp\ngulpfile统计目录下终端运行`gulp.script`\n\n\n\n","source":"_posts/gulp入门（一）.md","raw":"---\ntitle: gulp入门(一)\ndate: 2019-11-07 13:31:50\nauthor: 胡豪\ncategories:\n  - gulp\ntags:\n  - gulp\n---\n\n## 前言\n说到前端常见的构建工具，有Webpack/Grunt/Gulp  \n这里简述一下它们都是干什么的：  \nGrunt 和 Gulp 是非常相似的东西，能实现的功能是一样的，当然你可能 Gulp 听的 Grunt 多，通俗的讲，可以把 Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。  \nWebpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块(JavaScript、CSS、SCSS、图片、模板)，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。使用Vue的小伙伴再熟悉不过，Webpack 专注于构建模块化项目。Webpack的缺点也很明显是只能用于采用模块化开发的项目。  \n今天重点讲gulp；\n\n\n## Gulp是什么？\n\nGulp是前端自动化的工具，它能用来做很多很多繁琐的事情，大大便利了前端开发工作流程\n\n1. 搭建web服务器\n2. 使用预处理器Sass，Less\n3. 压缩优化，可以压缩JS CSS Html 图片\n4. 自动将更新变化的代码实时显示在浏览器\n5. 前端测试  \n...... \n\n## 快速入门\nGulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5种个方法就可以胜任几乎所有构建场景：\n\n- 通过 gulp.task 注册一个任务；\n- 通过 gulp.run 执行任务；\n- 通过 gulp.watch 监听文件变化；\n- 通过 gulp.src 读取文件；\n- 通过 gulp.dest 写文件。\n\n### 简单语法\n1. gulp.task(name[,deps],fn)\n说明：定义一个gulp任务\nname: 类型(必填)：String 指定任务的名称（不应该有空格）\ndeps:类型(可选)：StringArray，该任务依赖的任务（执行name任务要先去执行的任务）\n```js\ngulp.task('A' , function(){\n   console.log('A') \n});\ngulp.task('B' , ['A'] , function(){ //运行B之前先去运行A\n   console.log('B')\n});\n```\n\n2. gulp.src(globs[, options])\n说明：src方法指定需要处理的源文件路径，返回当前文件流至可用插件  \n\nglobs: 类型(必填)：String/StringArray  需要处理的源文件匹配符路径  \n\n通配符路径匹配示例：\n　　“src/a.js”：指定具体文件；  \n　　“*”：匹配所有文件    例：src/*.js(包含src下的所有js文件)；  \n　　“**”：匹配0个或多个子文件夹    例：src/**/*.js(包含src的0个或多个子文件夹下的js文件)；  \n　　“{}”：匹配多个属性    例：src/{a,b}.js(包含a.js和b.js文件)  src/*.{jpg,png,gif}(src下的所有jpg/png/gif文件)；  \n　　“!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；  \n\noptions:类型(可选)：Object 三个属性 buffer read base  \n　　options.buffer：类型：Boolean  默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；  \n　　options.read：  类型：Boolean  默认：true 设置false，将不执行读取文件操作，返回null；  \n　　options.base：  类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接\n```js\ngulp.src('client/js/**/*.js') \n  .pipe(minify())\n  .pipe(gulp.dest('build'));   \n \ngulp.src('client/js/**/*.js', { base: 'client' })\n  .pipe(minify())\n  .pipe(gulp.dest('build'));   \n```\n\n3. gulp.dest(path[,options])  \n说明：watch方法用于监听文件变化，一被变化就执行指定任务  \nglob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；  \nopts：  类型(可选)：Object 具体参看https://github.com/shama/gaze；  \ntasks：  类型(必填)：StringArray 需要执行的任务的名称数组；  \ncb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；\n```js\n.pipe(gulp.dest('build')); \n```\n\n4. gulp.watch(glob[,opts],tasks) or gulp.task(glob [,opts ,cd])  \n说明：watch方法用于监听文件变化，一被变化就执行指定任务  \nglob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；  \nopts：  类型(可选)：Object 具体参看https://github.com/shama/gaze；  \ntasks：  类型(必填)：StringArray 需要执行的任务的名称数组；  \ncb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；\n\n\n## 如何写\n首先创建 gulpfile 文件  \n利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件  \n各个API就不讲了，官网都有，[Gulp官网直通车](https://www.gulpjs.com.cn/docs/api/concepts/) \n\n\n1. 项目初始化 `npm init` \n2. 安装全局gulp \n```js\nnpm install gulp -g //全局安装\nnpm install gulp --save-dev //本地安装并加入package.json\n```\n3. 这里用了一个gulp插件 gulp-uglify，安装 `npm i gulp-uglify -D`\n4. 定义一个gulp任务`gulp.task(name[,deps],fn)`   \n\n就先写个压缩 js 吧\n```js\nconst gulp = require(\"gulp\");//全局gulp\nconst uglify = require(\"gulp-uglify\"); //压缩js\n\n  //压缩js文件\n  gulp.task(\"script\", function() {\n    //找到文件\n    gulp\n      .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\"));\n  });\n```\n5. 运行gulp\ngulpfile统计目录下终端运行`gulp.script`\n\n\n\n","slug":"gulp入门（一）","published":1,"updated":"2019-11-14T07:17:34.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufw5000c4sefw8spq7v5","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>说到前端常见的构建工具，有Webpack/Grunt/Gulp<br>这里简述一下它们都是干什么的：<br>Grunt 和 Gulp 是非常相似的东西，能实现的功能是一样的，当然你可能 Gulp 听的 Grunt 多，通俗的讲，可以把 Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。<br>Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块(JavaScript、CSS、SCSS、图片、模板)，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。使用Vue的小伙伴再熟悉不过，Webpack 专注于构建模块化项目。Webpack的缺点也很明显是只能用于采用模块化开发的项目。<br>今天重点讲gulp；</p>\n<h2 id=\"Gulp是什么？\"><a href=\"#Gulp是什么？\" class=\"headerlink\" title=\"Gulp是什么？\"></a>Gulp是什么？</h2><p>Gulp是前端自动化的工具，它能用来做很多很多繁琐的事情，大大便利了前端开发工作流程</p>\n<ol>\n<li>搭建web服务器</li>\n<li>使用预处理器Sass，Less</li>\n<li>压缩优化，可以压缩JS CSS Html 图片</li>\n<li>自动将更新变化的代码实时显示在浏览器</li>\n<li>前端测试<br>…… </li>\n</ol>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p>Gulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5种个方法就可以胜任几乎所有构建场景：</p>\n<ul>\n<li>通过 gulp.task 注册一个任务；</li>\n<li>通过 gulp.run 执行任务；</li>\n<li>通过 gulp.watch 监听文件变化；</li>\n<li>通过 gulp.src 读取文件；</li>\n<li>通过 gulp.dest 写文件。</li>\n</ul>\n<h3 id=\"简单语法\"><a href=\"#简单语法\" class=\"headerlink\" title=\"简单语法\"></a>简单语法</h3><ol>\n<li><p>gulp.task(name[,deps],fn)<br>说明：定义一个gulp任务<br>name: 类型(必填)：String 指定任务的名称（不应该有空格）<br>deps:类型(可选)：StringArray，该任务依赖的任务（执行name任务要先去执行的任务）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'A'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>) </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(<span class=\"string\">'B'</span> , [<span class=\"string\">'A'</span>] , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//运行B之前先去运行A</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gulp.src(globs[, options])<br>说明：src方法指定需要处理的源文件路径，返回当前文件流至可用插件  </p>\n</li>\n</ol>\n<p>globs: 类型(必填)：String/StringArray  需要处理的源文件匹配符路径  </p>\n<p>通配符路径匹配示例：<br>　　“src/a.js”：指定具体文件；<br>　　“<em>”：匹配所有文件    例：src/</em>.js(包含src下的所有js文件)；<br>　　“<strong>”：匹配0个或多个子文件夹    例：src/</strong>/<em>.js(包含src的0个或多个子文件夹下的js文件)；<br>　　“{}”：匹配多个属性    例：src/{a,b}.js(包含a.js和b.js文件)  src/</em>.{jpg,png,gif}(src下的所有jpg/png/gif文件)；<br>　　“!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；  </p>\n<p>options:类型(可选)：Object 三个属性 buffer read base<br>　　options.buffer：类型：Boolean  默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；<br>　　options.read：  类型：Boolean  默认：true 设置false，将不执行读取文件操作，返回null；<br>　　options.base：  类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(<span class=\"string\">'client/js/**/*.js'</span>) </span><br><span class=\"line\">  .pipe(minify())</span><br><span class=\"line\">  .pipe(gulp.dest(<span class=\"string\">'build'</span>));   </span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.src(<span class=\"string\">'client/js/**/*.js'</span>, &#123; <span class=\"attr\">base</span>: <span class=\"string\">'client'</span> &#125;)</span><br><span class=\"line\">  .pipe(minify())</span><br><span class=\"line\">  .pipe(gulp.dest(<span class=\"string\">'build'</span>));</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>gulp.dest(path[,options])<br>说明：watch方法用于监听文件变化，一被变化就执行指定任务<br>glob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；<br>opts：  类型(可选)：Object 具体参看<a href=\"https://github.com/shama/gaze；\" target=\"_blank\" rel=\"noopener\">https://github.com/shama/gaze；</a><br>tasks：  类型(必填)：StringArray 需要执行的任务的名称数组；<br>cb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(gulp.dest(<span class=\"string\">'build'</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gulp.watch(glob[,opts],tasks) or gulp.task(glob [,opts ,cd])<br>说明：watch方法用于监听文件变化，一被变化就执行指定任务<br>glob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；<br>opts：  类型(可选)：Object 具体参看<a href=\"https://github.com/shama/gaze；\" target=\"_blank\" rel=\"noopener\">https://github.com/shama/gaze；</a><br>tasks：  类型(必填)：StringArray 需要执行的任务的名称数组；<br>cb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；</p>\n</li>\n</ol>\n<h2 id=\"如何写\"><a href=\"#如何写\" class=\"headerlink\" title=\"如何写\"></a>如何写</h2><p>首先创建 gulpfile 文件<br>利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件<br>各个API就不讲了，官网都有，<a href=\"https://www.gulpjs.com.cn/docs/api/concepts/\" target=\"_blank\" rel=\"noopener\">Gulp官网直通车</a> </p>\n<ol>\n<li><p>项目初始化 <code>npm init</code> </p>\n</li>\n<li><p>安装全局gulp </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp -g <span class=\"comment\">//全局安装</span></span><br><span class=\"line\">npm install gulp --save-dev <span class=\"comment\">//本地安装并加入package.json</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这里用了一个gulp插件 gulp-uglify，安装 <code>npm i gulp-uglify -D</code></p>\n</li>\n<li><p>定义一个gulp任务<code>gulp.task(name[,deps],fn)</code>   </p>\n</li>\n</ol>\n<p>就先写个压缩 js 吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);<span class=\"comment\">//全局gulp</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-uglify\"</span>); <span class=\"comment\">//压缩js</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">  gulp.task(<span class=\"string\">\"script\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">    gulp</span><br><span class=\"line\">      .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">      .pipe(uglify())</span><br><span class=\"line\">      <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>运行gulp<br>gulpfile统计目录下终端运行<code>gulp.script</code></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>说到前端常见的构建工具，有Webpack/Grunt/Gulp<br>这里简述一下它们都是干什么的：<br>Grunt 和 Gulp 是非常相似的东西，能实现的功能是一样的，当然你可能 Gulp 听的 Grunt 多，通俗的讲，可以把 Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。<br>Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块(JavaScript、CSS、SCSS、图片、模板)，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。使用Vue的小伙伴再熟悉不过，Webpack 专注于构建模块化项目。Webpack的缺点也很明显是只能用于采用模块化开发的项目。<br>今天重点讲gulp；</p>\n<h2 id=\"Gulp是什么？\"><a href=\"#Gulp是什么？\" class=\"headerlink\" title=\"Gulp是什么？\"></a>Gulp是什么？</h2><p>Gulp是前端自动化的工具，它能用来做很多很多繁琐的事情，大大便利了前端开发工作流程</p>\n<ol>\n<li>搭建web服务器</li>\n<li>使用预处理器Sass，Less</li>\n<li>压缩优化，可以压缩JS CSS Html 图片</li>\n<li>自动将更新变化的代码实时显示在浏览器</li>\n<li>前端测试<br>…… </li>\n</ol>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p>Gulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5种个方法就可以胜任几乎所有构建场景：</p>\n<ul>\n<li>通过 gulp.task 注册一个任务；</li>\n<li>通过 gulp.run 执行任务；</li>\n<li>通过 gulp.watch 监听文件变化；</li>\n<li>通过 gulp.src 读取文件；</li>\n<li>通过 gulp.dest 写文件。</li>\n</ul>\n<h3 id=\"简单语法\"><a href=\"#简单语法\" class=\"headerlink\" title=\"简单语法\"></a>简单语法</h3><ol>\n<li><p>gulp.task(name[,deps],fn)<br>说明：定义一个gulp任务<br>name: 类型(必填)：String 指定任务的名称（不应该有空格）<br>deps:类型(可选)：StringArray，该任务依赖的任务（执行name任务要先去执行的任务）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'A'</span> , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'A'</span>) </span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">gulp.task(<span class=\"string\">'B'</span> , [<span class=\"string\">'A'</span>] , <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"comment\">//运行B之前先去运行A</span></span><br><span class=\"line\">   <span class=\"built_in\">console</span>.log(<span class=\"string\">'B'</span>)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gulp.src(globs[, options])<br>说明：src方法指定需要处理的源文件路径，返回当前文件流至可用插件  </p>\n</li>\n</ol>\n<p>globs: 类型(必填)：String/StringArray  需要处理的源文件匹配符路径  </p>\n<p>通配符路径匹配示例：<br>　　“src/a.js”：指定具体文件；<br>　　“<em>”：匹配所有文件    例：src/</em>.js(包含src下的所有js文件)；<br>　　“<strong>”：匹配0个或多个子文件夹    例：src/</strong>/<em>.js(包含src的0个或多个子文件夹下的js文件)；<br>　　“{}”：匹配多个属性    例：src/{a,b}.js(包含a.js和b.js文件)  src/</em>.{jpg,png,gif}(src下的所有jpg/png/gif文件)；<br>　　“!”：排除文件    例：!src/a.js(不包含src下的a.js文件)；  </p>\n<p>options:类型(可选)：Object 三个属性 buffer read base<br>　　options.buffer：类型：Boolean  默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用；<br>　　options.read：  类型：Boolean  默认：true 设置false，将不执行读取文件操作，返回null；<br>　　options.base：  类型：String  设置输出路径以某个路径的某个组成部分为基础向后拼接</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.src(<span class=\"string\">'client/js/**/*.js'</span>) </span><br><span class=\"line\">  .pipe(minify())</span><br><span class=\"line\">  .pipe(gulp.dest(<span class=\"string\">'build'</span>));   </span><br><span class=\"line\"> </span><br><span class=\"line\">gulp.src(<span class=\"string\">'client/js/**/*.js'</span>, &#123; <span class=\"attr\">base</span>: <span class=\"string\">'client'</span> &#125;)</span><br><span class=\"line\">  .pipe(minify())</span><br><span class=\"line\">  .pipe(gulp.dest(<span class=\"string\">'build'</span>));</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><p>gulp.dest(path[,options])<br>说明：watch方法用于监听文件变化，一被变化就执行指定任务<br>glob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；<br>opts：  类型(可选)：Object 具体参看<a href=\"https://github.com/shama/gaze；\" target=\"_blank\" rel=\"noopener\">https://github.com/shama/gaze；</a><br>tasks：  类型(必填)：StringArray 需要执行的任务的名称数组；<br>cb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.pipe(gulp.dest(<span class=\"string\">'build'</span>));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gulp.watch(glob[,opts],tasks) or gulp.task(glob [,opts ,cd])<br>说明：watch方法用于监听文件变化，一被变化就执行指定任务<br>glob：  需要处理的源文件匹配符路径。类型(必填)：String or StringArray；<br>opts：  类型(可选)：Object 具体参看<a href=\"https://github.com/shama/gaze；\" target=\"_blank\" rel=\"noopener\">https://github.com/shama/gaze；</a><br>tasks：  类型(必填)：StringArray 需要执行的任务的名称数组；<br>cb(event)：  类型(可选)：Function 每个文件变化执行的回调函数；</p>\n</li>\n</ol>\n<h2 id=\"如何写\"><a href=\"#如何写\" class=\"headerlink\" title=\"如何写\"></a>如何写</h2><p>首先创建 gulpfile 文件<br>利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件<br>各个API就不讲了，官网都有，<a href=\"https://www.gulpjs.com.cn/docs/api/concepts/\" target=\"_blank\" rel=\"noopener\">Gulp官网直通车</a> </p>\n<ol>\n<li><p>项目初始化 <code>npm init</code> </p>\n</li>\n<li><p>安装全局gulp </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install gulp -g <span class=\"comment\">//全局安装</span></span><br><span class=\"line\">npm install gulp --save-dev <span class=\"comment\">//本地安装并加入package.json</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>这里用了一个gulp插件 gulp-uglify，安装 <code>npm i gulp-uglify -D</code></p>\n</li>\n<li><p>定义一个gulp任务<code>gulp.task(name[,deps],fn)</code>   </p>\n</li>\n</ol>\n<p>就先写个压缩 js 吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> gulp = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp\"</span>);<span class=\"comment\">//全局gulp</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> uglify = <span class=\"built_in\">require</span>(<span class=\"string\">\"gulp-uglify\"</span>); <span class=\"comment\">//压缩js</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">  gulp.task(<span class=\"string\">\"script\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">    gulp</span><br><span class=\"line\">      .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">      <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">      .pipe(uglify())</span><br><span class=\"line\">      <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">      .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>运行gulp<br>gulpfile统计目录下终端运行<code>gulp.script</code></li>\n</ol>\n"},{"title":"gulp入门(二)","date":"2019-11-11T08:54:02.000Z","author":"胡豪","_content":"\n## 实践过程遇到的问题\n\n- ### 压缩js \n  gulp 压缩遇到已经压缩过的 min.js 文件无法再继续压缩会报错跳除压缩程序;  \n  解决方法一：先把压缩过的js文件提前剪切到dist/js文件下;执行完gulp要记得吧dist里的js覆盖原项目js文件夹  \n  当然这种手动的方法比较麻烦，使用gulp插件自动化处理更加优雅\n  解决方法二：添加gulp-if判断\n  ```js\n  var condition = function(f) {\n    //这里网上用的是endsWith()方法虽然方便，但是是es6的方法，es5下使用indexOf也同样可以实现\n    if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) { \n      return false;\n    } \n    return true;\n  };\n\n  //压缩js文件\n  gulp.task(\"jsmin\", function() {\n    //找到文件\n    return gulp.src(\"src/js/*.js\") \n      //压缩文件\n      .pipe(gulpif(condition, uglify()))\n      //保存压缩后的文件 \n      .pipe(gulp.dest(\"dist/js\"));\n  });\n  ```\n  * 知识补充：\n  includes()：返回布尔值，表示是否找到了参数字符串；\n  startsWith()：返回布尔值，表示参数字符串是否在查找字符串的头部；\n  endsWith()：返回布尔值，表示参数字符串是否在查找字符串的尾部。\n  ```js\n  let str = 'Hello world!';\n \n  str.startsWith('Hello') // true\n  str.endsWith('!') // true\n  str.includes('o') // true\n  ```\n  同时这三个方法都支持第二个参数，表示开始搜索的位置。endsWith 的行为与其他两个方法有所不同，它针对的是前n个字符,其他两个方法都是针对从第n个位置（不包含n）直到字符串结束。\n  ```js\n  let str = 'Hello world!';\n \n  str.startsWith('world', 6) // true\n  str.endsWith('Hello', 5) // true\n  str.includes('Hello', 6) // false\n  ```\n\n- ### gulp4与gulp3\n\n  gulp3的写法运行遇到运行报错  \n  ```js\n    The following tasks did not complete: script\n    Did you forget to signal async completion?\n  ```\n  主要原因是一开始装的gulp是gulp4版本，gulp3版本使用原代码就行\n\n  原代码：\n\n  ```js\n  //压缩js文件\n  gulp.task(\"script\", function() {\n    //找到文件\n    gulp\n      .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\"));\n  });\n  ```\n\n  解决方法一：\n\n  ```js\n  //压缩js文件\n  gulp.task(\"script\", done => {\n    //找到文件\n    gulp \n      .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\"));\n    done();\n  });\n  ```\n\n  解决方法二：\n\n  ```js\n  //压缩js文件\n  gulp.task(\"script\", function() {\n    //找到文件\n    return gulp .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\")); \n  });\n  ```\n\n  关于gulp3与gulp4版本对于写串行方式运行任务也有不同\n  1. gulp3\n  ```js\n  gulp.task(\"build\", [\"html\",\"cssmin\",\"jsmin\",\"copyImage\"]);\n  ```\n  2. gulp4  \n  ```js\n  gulp.task('build',gulp.series(gulp.parallel('html','cssmin','jsmin','copyImage')));\n  ```\n\n- ### 压缩图片报错\n待解决。。。\n暂时拷贝所有原图片  ","source":"_posts/gulp入门（二）.md","raw":"---\ntitle: gulp入门(二)\ndate: 2019-11-11 16:54:02\nauthor: 胡豪\ncategories:\n  - gulp\ntags:\n  - gulp\n---\n\n## 实践过程遇到的问题\n\n- ### 压缩js \n  gulp 压缩遇到已经压缩过的 min.js 文件无法再继续压缩会报错跳除压缩程序;  \n  解决方法一：先把压缩过的js文件提前剪切到dist/js文件下;执行完gulp要记得吧dist里的js覆盖原项目js文件夹  \n  当然这种手动的方法比较麻烦，使用gulp插件自动化处理更加优雅\n  解决方法二：添加gulp-if判断\n  ```js\n  var condition = function(f) {\n    //这里网上用的是endsWith()方法虽然方便，但是是es6的方法，es5下使用indexOf也同样可以实现\n    if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) { \n      return false;\n    } \n    return true;\n  };\n\n  //压缩js文件\n  gulp.task(\"jsmin\", function() {\n    //找到文件\n    return gulp.src(\"src/js/*.js\") \n      //压缩文件\n      .pipe(gulpif(condition, uglify()))\n      //保存压缩后的文件 \n      .pipe(gulp.dest(\"dist/js\"));\n  });\n  ```\n  * 知识补充：\n  includes()：返回布尔值，表示是否找到了参数字符串；\n  startsWith()：返回布尔值，表示参数字符串是否在查找字符串的头部；\n  endsWith()：返回布尔值，表示参数字符串是否在查找字符串的尾部。\n  ```js\n  let str = 'Hello world!';\n \n  str.startsWith('Hello') // true\n  str.endsWith('!') // true\n  str.includes('o') // true\n  ```\n  同时这三个方法都支持第二个参数，表示开始搜索的位置。endsWith 的行为与其他两个方法有所不同，它针对的是前n个字符,其他两个方法都是针对从第n个位置（不包含n）直到字符串结束。\n  ```js\n  let str = 'Hello world!';\n \n  str.startsWith('world', 6) // true\n  str.endsWith('Hello', 5) // true\n  str.includes('Hello', 6) // false\n  ```\n\n- ### gulp4与gulp3\n\n  gulp3的写法运行遇到运行报错  \n  ```js\n    The following tasks did not complete: script\n    Did you forget to signal async completion?\n  ```\n  主要原因是一开始装的gulp是gulp4版本，gulp3版本使用原代码就行\n\n  原代码：\n\n  ```js\n  //压缩js文件\n  gulp.task(\"script\", function() {\n    //找到文件\n    gulp\n      .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\"));\n  });\n  ```\n\n  解决方法一：\n\n  ```js\n  //压缩js文件\n  gulp.task(\"script\", done => {\n    //找到文件\n    gulp \n      .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\"));\n    done();\n  });\n  ```\n\n  解决方法二：\n\n  ```js\n  //压缩js文件\n  gulp.task(\"script\", function() {\n    //找到文件\n    return gulp .src(\"js/*.js\")\n      //压缩文件\n      .pipe(uglify())\n      //保存压缩后的文件\n      .pipe(gulp.dest(\"dist/js\")); \n  });\n  ```\n\n  关于gulp3与gulp4版本对于写串行方式运行任务也有不同\n  1. gulp3\n  ```js\n  gulp.task(\"build\", [\"html\",\"cssmin\",\"jsmin\",\"copyImage\"]);\n  ```\n  2. gulp4  \n  ```js\n  gulp.task('build',gulp.series(gulp.parallel('html','cssmin','jsmin','copyImage')));\n  ```\n\n- ### 压缩图片报错\n待解决。。。\n暂时拷贝所有原图片  ","slug":"gulp入门（二）","published":1,"updated":"2019-11-14T07:17:34.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufw7000h4sef4tqs1rdw","content":"<h2 id=\"实践过程遇到的问题\"><a href=\"#实践过程遇到的问题\" class=\"headerlink\" title=\"实践过程遇到的问题\"></a>实践过程遇到的问题</h2><ul>\n<li><h3 id=\"压缩js\"><a href=\"#压缩js\" class=\"headerlink\" title=\"压缩js\"></a>压缩js</h3><p>gulp 压缩遇到已经压缩过的 min.js 文件无法再继续压缩会报错跳除压缩程序;<br>解决方法一：先把压缩过的js文件提前剪切到dist/js文件下;执行完gulp要记得吧dist里的js覆盖原项目js文件夹<br>当然这种手动的方法比较麻烦，使用gulp插件自动化处理更加优雅<br>解决方法二：添加gulp-if判断</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> condition = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里网上用的是endsWith()方法虽然方便，但是是es6的方法，es5下使用indexOf也同样可以实现</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f.path.indexOf(<span class=\"string\">\".min.js\"</span>, f.path.length - <span class=\"string\">\".min.js\"</span>.length) !== <span class=\"number\">-1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"jsmin\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/js/*.js\"</span>) </span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(gulpif(condition, uglify()))</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件 </span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>知识补充：<br>includes()：返回布尔值，表示是否找到了参数字符串；<br>startsWith()：返回布尔值，表示参数字符串是否在查找字符串的头部；<br>endsWith()：返回布尔值，表示参数字符串是否在查找字符串的尾部。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'Hello world!'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">str.startsWith(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.endsWith(<span class=\"string\">'!'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.includes(<span class=\"string\">'o'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>同时这三个方法都支持第二个参数，表示开始搜索的位置。endsWith 的行为与其他两个方法有所不同，它针对的是前n个字符,其他两个方法都是针对从第n个位置（不包含n）直到字符串结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'Hello world!'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">str.startsWith(<span class=\"string\">'world'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.endsWith(<span class=\"string\">'Hello'</span>, <span class=\"number\">5</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.includes(<span class=\"string\">'Hello'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h3 id=\"gulp4与gulp3\"><a href=\"#gulp4与gulp3\" class=\"headerlink\" title=\"gulp4与gulp3\"></a>gulp4与gulp3</h3><p>gulp3的写法运行遇到运行报错  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The following tasks did not complete: script</span><br><span class=\"line\">Did you forget to signal <span class=\"keyword\">async</span> completion?</span><br></pre></td></tr></table></figure>\n\n<p>主要原因是一开始装的gulp是gulp4版本，gulp3版本使用原代码就行</p>\n<p>原代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"script\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  gulp</span><br><span class=\"line\">    .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>解决方法一：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"script\"</span>, done =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  gulp </span><br><span class=\"line\">    .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">  done();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>解决方法二：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"script\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>)); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>关于gulp3与gulp4版本对于写串行方式运行任务也有不同</p>\n<ol>\n<li><p>gulp3</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">\"build\"</span>, [<span class=\"string\">\"html\"</span>,<span class=\"string\">\"cssmin\"</span>,<span class=\"string\">\"jsmin\"</span>,<span class=\"string\">\"copyImage\"</span>]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gulp4  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'build'</span>,gulp.series(gulp.parallel(<span class=\"string\">'html'</span>,<span class=\"string\">'cssmin'</span>,<span class=\"string\">'jsmin'</span>,<span class=\"string\">'copyImage'</span>)));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><h3 id=\"压缩图片报错\"><a href=\"#压缩图片报错\" class=\"headerlink\" title=\"压缩图片报错\"></a>压缩图片报错</h3><p>待解决。。。<br>暂时拷贝所有原图片  </p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"实践过程遇到的问题\"><a href=\"#实践过程遇到的问题\" class=\"headerlink\" title=\"实践过程遇到的问题\"></a>实践过程遇到的问题</h2><ul>\n<li><h3 id=\"压缩js\"><a href=\"#压缩js\" class=\"headerlink\" title=\"压缩js\"></a>压缩js</h3><p>gulp 压缩遇到已经压缩过的 min.js 文件无法再继续压缩会报错跳除压缩程序;<br>解决方法一：先把压缩过的js文件提前剪切到dist/js文件下;执行完gulp要记得吧dist里的js覆盖原项目js文件夹<br>当然这种手动的方法比较麻烦，使用gulp插件自动化处理更加优雅<br>解决方法二：添加gulp-if判断</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> condition = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里网上用的是endsWith()方法虽然方便，但是是es6的方法，es5下使用indexOf也同样可以实现</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f.path.indexOf(<span class=\"string\">\".min.js\"</span>, f.path.length - <span class=\"string\">\".min.js\"</span>.length) !== <span class=\"number\">-1</span>) &#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125; </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"jsmin\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp.src(<span class=\"string\">\"src/js/*.js\"</span>) </span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(gulpif(condition, uglify()))</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件 </span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>知识补充：<br>includes()：返回布尔值，表示是否找到了参数字符串；<br>startsWith()：返回布尔值，表示参数字符串是否在查找字符串的头部；<br>endsWith()：返回布尔值，表示参数字符串是否在查找字符串的尾部。<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'Hello world!'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">str.startsWith(<span class=\"string\">'Hello'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.endsWith(<span class=\"string\">'!'</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.includes(<span class=\"string\">'o'</span>) <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>同时这三个方法都支持第二个参数，表示开始搜索的位置。endsWith 的行为与其他两个方法有所不同，它针对的是前n个字符,其他两个方法都是针对从第n个位置（不包含n）直到字符串结束。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> str = <span class=\"string\">'Hello world!'</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\">str.startsWith(<span class=\"string\">'world'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.endsWith(<span class=\"string\">'Hello'</span>, <span class=\"number\">5</span>) <span class=\"comment\">// true</span></span><br><span class=\"line\">str.includes(<span class=\"string\">'Hello'</span>, <span class=\"number\">6</span>) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><h3 id=\"gulp4与gulp3\"><a href=\"#gulp4与gulp3\" class=\"headerlink\" title=\"gulp4与gulp3\"></a>gulp4与gulp3</h3><p>gulp3的写法运行遇到运行报错  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The following tasks did not complete: script</span><br><span class=\"line\">Did you forget to signal <span class=\"keyword\">async</span> completion?</span><br></pre></td></tr></table></figure>\n\n<p>主要原因是一开始装的gulp是gulp4版本，gulp3版本使用原代码就行</p>\n<p>原代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"script\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  gulp</span><br><span class=\"line\">    .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>解决方法一：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"script\"</span>, done =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  gulp </span><br><span class=\"line\">    .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>));</span><br><span class=\"line\">  done();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>解决方法二：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//压缩js文件</span></span><br><span class=\"line\">gulp.task(<span class=\"string\">\"script\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//找到文件</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> gulp .src(<span class=\"string\">\"js/*.js\"</span>)</span><br><span class=\"line\">    <span class=\"comment\">//压缩文件</span></span><br><span class=\"line\">    .pipe(uglify())</span><br><span class=\"line\">    <span class=\"comment\">//保存压缩后的文件</span></span><br><span class=\"line\">    .pipe(gulp.dest(<span class=\"string\">\"dist/js\"</span>)); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>关于gulp3与gulp4版本对于写串行方式运行任务也有不同</p>\n<ol>\n<li><p>gulp3</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">\"build\"</span>, [<span class=\"string\">\"html\"</span>,<span class=\"string\">\"cssmin\"</span>,<span class=\"string\">\"jsmin\"</span>,<span class=\"string\">\"copyImage\"</span>]);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>gulp4  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gulp.task(<span class=\"string\">'build'</span>,gulp.series(gulp.parallel(<span class=\"string\">'html'</span>,<span class=\"string\">'cssmin'</span>,<span class=\"string\">'jsmin'</span>,<span class=\"string\">'copyImage'</span>)));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n</li>\n<li><h3 id=\"压缩图片报错\"><a href=\"#压缩图片报错\" class=\"headerlink\" title=\"压缩图片报错\"></a>压缩图片报错</h3><p>待解决。。。<br>暂时拷贝所有原图片  </p>\n</li>\n</ul>\n"},{"title":"vue双向数据绑定原理","date":"2019-10-30T05:57:52.000Z","author":"胡豪","_content":"\n## 首先我们要了解Object.defineProperty()\n\n\n一、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性\n\n1.1 属性描述符\n通过Object.defineProperty()为对象定义属性，有两种形式，且不能混合使用，分别为数据描述符，存取描述符，下面分别描述下两者的区别：\n\n数据描述符 --特有的两个属性（value,writable）\n\n```js\nlet Person = {}\nObject.defineProperty(Person, 'name', {\n   value: 'jack',\n   writable: true // 是否可以改变\n})\n```\n\n属性名 | 默认值 \n-|-\nvalue | undefined \nget | undefined \nset | undefined \nwritable | false \nenumerable | false \nconfigurable | false\n\n\n二、什么是 getter 和 setter  \ngetter 是一种获得属性值的方法，setter 是一种设置属性值的方法\ngetter 负责查询值，它不带任何参数，setter 则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的 return 都是无效的\nget/set 访问器不是对象的属性，而是属性的特性，特性只有内部才用，因此在 javaScript 中不能直接访问他们，为了表示特性是内部值用两队中括号括起来表示如[[Value]]\n对象的属性又可分为对象属性和访问器属性\n\n## set/get\n\n```js\nvar person = {\n  _name: \"\",\n  get name() {\n    return this._name;\n  },\n  set name(n) {\n    this._name = n;\n  }\n};\n\n// 测试\nperson.name; // 输出 --> ''\nperson.name = \"xiaoming\";\nperson.name; // 输出 --> xiaoming\n```\n\n## 存取描述符 --是由一对 getter、setter 函数功能来描述的属性\nget：一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。\nset：一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。 \n```\nvar person = function() {\n    var _name = ' ';\n    var obj = {};\n    Object.defineProperty(obj, 'name', {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            return _name;\n        },\n        set: function(n) {\n            _name = n;\n        }\n    })\n    return obj;\n}();\nperson.name = \"xiaoming\";\nperson.name // 输出 --> xiaoming\n```\n\n## vue 的双项数据绑定原理\n\nvue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。我们先来看 Object.defineProperty()这个方法：\n\n```js\nvar obj = {};\nObject.defineProperty(obj, \"name\", {\n  get: function() {\n    console.log(\"我被获取了\");\n    return val;\n  },\n  set: function(newVal) {\n    console.log(\"我被设置了\");\n  }\n});\nobj.name = \"fei\"; //在给obj设置name属性的时候，触发了set这个方法\nvar val = obj.name; //在得到obj的name属性，会触发get方法\n```\n\nvue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 Object.defineProperty()来实现对属性的劫持，那么在设置或者获取的时候我们就可以在 get 或者 set 方法里假如其他的触发函数，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。\n\n## 实现最简单的双向绑定\n\n通过 Object.defineProperty()可以实现数据劫持，是的属性在赋值的时候触发 set 方法\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"demo\"></div>\n    <input type=\"text\" id=\"inp\">\n    <script>\n        var obj  = {};\n        var demo = document.querySelector('#demo')\n        var inp = document.querySelector('#inp')\n        Object.defineProperty(obj, 'name', {\n            get: function() {\n                return val;\n            },\n            set: function (newVal) {//当该属性被赋值的时候触发\n                inp.value = newVal;\n                demo.innerHTML = newVal;\n            }\n        })\n        inp.addEventListener('input', function(e) {\n            // 给obj的name属性赋值，进而触发该属性的set方法\n            obj.name = e.target.value;\n        });\n        obj.name = 'changme';//在给obj设置name属性的时候，触发了set这个方法\n    </script>\n</body>\n</html>\n```\n\n## vue 代码实现\n\nobserver 实现，主要是给每个 vue 的属性用 Object.defineProperty()，代码如下\n\n```js\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n  Object.defineProperty(obj, key, {\n    get: function() {\n      //添加订阅者watcher到主题对象Dep\n      if (Dep.target) {\n        // JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用\n        dep.addSub(Dep.target);\n      }\n      return val;\n    },\n    set: function(newVal) {\n      if (newVal === val) return;\n      val = newVal;\n      console.log(val);\n      // 作为发布者发出通知\n      dep.notify(); //通知后dep会循环调用各自的update方法更新视图\n    }\n  });\n}\nfunction observe(obj, vm) {\n  Object.keys(obj).forEach(function(key) {\n    defineReactive(vm, key, obj[key]);\n  });\n}\n```\n未完，待续、、、","source":"_posts/vue双向数据绑定原理.md","raw":"---\ntitle: vue双向数据绑定原理\ndate: 2019-10-30 13:57:52\nauthor: 胡豪\ncategories:\n  - JavaScript\n  - vue\ntags:\n  - vue \n---\n\n## 首先我们要了解Object.defineProperty()\n\n\n一、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性\n\n1.1 属性描述符\n通过Object.defineProperty()为对象定义属性，有两种形式，且不能混合使用，分别为数据描述符，存取描述符，下面分别描述下两者的区别：\n\n数据描述符 --特有的两个属性（value,writable）\n\n```js\nlet Person = {}\nObject.defineProperty(Person, 'name', {\n   value: 'jack',\n   writable: true // 是否可以改变\n})\n```\n\n属性名 | 默认值 \n-|-\nvalue | undefined \nget | undefined \nset | undefined \nwritable | false \nenumerable | false \nconfigurable | false\n\n\n二、什么是 getter 和 setter  \ngetter 是一种获得属性值的方法，setter 是一种设置属性值的方法\ngetter 负责查询值，它不带任何参数，setter 则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的 return 都是无效的\nget/set 访问器不是对象的属性，而是属性的特性，特性只有内部才用，因此在 javaScript 中不能直接访问他们，为了表示特性是内部值用两队中括号括起来表示如[[Value]]\n对象的属性又可分为对象属性和访问器属性\n\n## set/get\n\n```js\nvar person = {\n  _name: \"\",\n  get name() {\n    return this._name;\n  },\n  set name(n) {\n    this._name = n;\n  }\n};\n\n// 测试\nperson.name; // 输出 --> ''\nperson.name = \"xiaoming\";\nperson.name; // 输出 --> xiaoming\n```\n\n## 存取描述符 --是由一对 getter、setter 函数功能来描述的属性\nget：一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。\nset：一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。 \n```\nvar person = function() {\n    var _name = ' ';\n    var obj = {};\n    Object.defineProperty(obj, 'name', {\n        configurable: true,\n        enumerable: true,\n        get: function() {\n            return _name;\n        },\n        set: function(n) {\n            _name = n;\n        }\n    })\n    return obj;\n}();\nperson.name = \"xiaoming\";\nperson.name // 输出 --> xiaoming\n```\n\n## vue 的双项数据绑定原理\n\nvue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。我们先来看 Object.defineProperty()这个方法：\n\n```js\nvar obj = {};\nObject.defineProperty(obj, \"name\", {\n  get: function() {\n    console.log(\"我被获取了\");\n    return val;\n  },\n  set: function(newVal) {\n    console.log(\"我被设置了\");\n  }\n});\nobj.name = \"fei\"; //在给obj设置name属性的时候，触发了set这个方法\nvar val = obj.name; //在得到obj的name属性，会触发get方法\n```\n\nvue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 Object.defineProperty()来实现对属性的劫持，那么在设置或者获取的时候我们就可以在 get 或者 set 方法里假如其他的触发函数，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。\n\n## 实现最简单的双向绑定\n\n通过 Object.defineProperty()可以实现数据劫持，是的属性在赋值的时候触发 set 方法\n\n```js\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    <div id=\"demo\"></div>\n    <input type=\"text\" id=\"inp\">\n    <script>\n        var obj  = {};\n        var demo = document.querySelector('#demo')\n        var inp = document.querySelector('#inp')\n        Object.defineProperty(obj, 'name', {\n            get: function() {\n                return val;\n            },\n            set: function (newVal) {//当该属性被赋值的时候触发\n                inp.value = newVal;\n                demo.innerHTML = newVal;\n            }\n        })\n        inp.addEventListener('input', function(e) {\n            // 给obj的name属性赋值，进而触发该属性的set方法\n            obj.name = e.target.value;\n        });\n        obj.name = 'changme';//在给obj设置name属性的时候，触发了set这个方法\n    </script>\n</body>\n</html>\n```\n\n## vue 代码实现\n\nobserver 实现，主要是给每个 vue 的属性用 Object.defineProperty()，代码如下\n\n```js\nfunction defineReactive(obj, key, val) {\n  var dep = new Dep();\n  Object.defineProperty(obj, key, {\n    get: function() {\n      //添加订阅者watcher到主题对象Dep\n      if (Dep.target) {\n        // JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用\n        dep.addSub(Dep.target);\n      }\n      return val;\n    },\n    set: function(newVal) {\n      if (newVal === val) return;\n      val = newVal;\n      console.log(val);\n      // 作为发布者发出通知\n      dep.notify(); //通知后dep会循环调用各自的update方法更新视图\n    }\n  });\n}\nfunction observe(obj, vm) {\n  Object.keys(obj).forEach(function(key) {\n    defineReactive(vm, key, obj[key]);\n  });\n}\n```\n未完，待续、、、","slug":"vue双向数据绑定原理","published":1,"updated":"2019-11-09T06:41:53.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufw9000i4sef7s10hh3g","content":"<h2 id=\"首先我们要了解Object-defineProperty\"><a href=\"#首先我们要了解Object-defineProperty\" class=\"headerlink\" title=\"首先我们要了解Object.defineProperty()\"></a>首先我们要了解Object.defineProperty()</h2><p>一、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性</p>\n<p>1.1 属性描述符<br>通过Object.defineProperty()为对象定义属性，有两种形式，且不能混合使用，分别为数据描述符，存取描述符，下面分别描述下两者的区别：</p>\n<p>数据描述符 –特有的两个属性（value,writable）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Person = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">   value: <span class=\"string\">'jack'</span>,</span><br><span class=\"line\">   writable: <span class=\"literal\">true</span> <span class=\"comment\">// 是否可以改变</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>value</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>get</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>set</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>false</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>false</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<p>二、什么是 getter 和 setter<br>getter 是一种获得属性值的方法，setter 是一种设置属性值的方法<br>getter 负责查询值，它不带任何参数，setter 则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的 return 都是无效的<br>get/set 访问器不是对象的属性，而是属性的特性，特性只有内部才用，因此在 javaScript 中不能直接访问他们，为了表示特性是内部值用两队中括号括起来表示如[[Value]]<br>对象的属性又可分为对象属性和访问器属性</p>\n<h2 id=\"set-get\"><a href=\"#set-get\" class=\"headerlink\" title=\"set/get\"></a>set/get</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  _name: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> name(n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._name = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\">person.name; <span class=\"comment\">// 输出 --&gt; ''</span></span><br><span class=\"line\">person.name = <span class=\"string\">\"xiaoming\"</span>;</span><br><span class=\"line\">person.name; <span class=\"comment\">// 输出 --&gt; xiaoming</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存取描述符-–是由一对-getter、setter-函数功能来描述的属性\"><a href=\"#存取描述符-–是由一对-getter、setter-函数功能来描述的属性\" class=\"headerlink\" title=\"存取描述符 –是由一对 getter、setter 函数功能来描述的属性\"></a>存取描述符 –是由一对 getter、setter 函数功能来描述的属性</h2><p>get：一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。<br>set：一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = function() &#123;</span><br><span class=\"line\">    var _name = &apos; &apos;;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class=\"line\">        configurable: true,</span><br><span class=\"line\">        enumerable: true,</span><br><span class=\"line\">        get: function() &#123;</span><br><span class=\"line\">            return _name;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: function(n) &#123;</span><br><span class=\"line\">            _name = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\">person.name = &quot;xiaoming&quot;;</span><br><span class=\"line\">person.name // 输出 --&gt; xiaoming</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"vue-的双项数据绑定原理\"><a href=\"#vue-的双项数据绑定原理\" class=\"headerlink\" title=\"vue 的双项数据绑定原理\"></a>vue 的双项数据绑定原理</h2><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。我们先来看 Object.defineProperty()这个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"我被获取了\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(newVal) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"我被设置了\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">obj.name = <span class=\"string\">\"fei\"</span>; <span class=\"comment\">//在给obj设置name属性的时候，触发了set这个方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> val = obj.name; <span class=\"comment\">//在得到obj的name属性，会触发get方法</span></span><br></pre></td></tr></table></figure>\n\n<p>vue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 Object.defineProperty()来实现对属性的劫持，那么在设置或者获取的时候我们就可以在 get 或者 set 方法里假如其他的触发函数，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。</p>\n<h2 id=\"实现最简单的双向绑定\"><a href=\"#实现最简单的双向绑定\" class=\"headerlink\" title=\"实现最简单的双向绑定\"></a>实现最简单的双向绑定</h2><p>通过 Object.defineProperty()可以实现数据劫持，是的属性在赋值的时候触发 set 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"demo\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &lt;input type=<span class=\"string\">\"text\"</span> id=<span class=\"string\">\"inp\"</span>&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> obj  = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#demo'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> inp = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#inp'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>: function (newVal) &#123;<span class=\"comment\">//当该属性被赋值的时候触发</span></span><br><span class=\"line\">                inp.value = newVal;</span><br><span class=\"line\">                demo.innerHTML = newVal;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        inp.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 给obj的name属性赋值，进而触发该属性的set方法</span></span><br><span class=\"line\">            obj.name = e.target.value;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        obj.name = <span class=\"string\">'changme'</span>;<span class=\"comment\">//在给obj设置name属性的时候，触发了set这个方法</span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"vue-代码实现\"><a href=\"#vue-代码实现\" class=\"headerlink\" title=\"vue 代码实现\"></a>vue 代码实现</h2><p>observer 实现，主要是给每个 vue 的属性用 Object.defineProperty()，代码如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep();</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//添加订阅者watcher到主题对象Dep</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用</span></span><br><span class=\"line\">        dep.addSub(Dep.target);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(newVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      val = newVal;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">      <span class=\"comment\">// 作为发布者发出通知</span></span><br><span class=\"line\">      dep.notify(); <span class=\"comment\">//通知后dep会循环调用各自的update方法更新视图</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">obj, vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    defineReactive(vm, key, obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>未完，待续、、、</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"首先我们要了解Object-defineProperty\"><a href=\"#首先我们要了解Object-defineProperty\" class=\"headerlink\" title=\"首先我们要了解Object.defineProperty()\"></a>首先我们要了解Object.defineProperty()</h2><p>一、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性</p>\n<p>1.1 属性描述符<br>通过Object.defineProperty()为对象定义属性，有两种形式，且不能混合使用，分别为数据描述符，存取描述符，下面分别描述下两者的区别：</p>\n<p>数据描述符 –特有的两个属性（value,writable）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> Person = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(Person, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">   value: <span class=\"string\">'jack'</span>,</span><br><span class=\"line\">   writable: <span class=\"literal\">true</span> <span class=\"comment\">// 是否可以改变</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>value</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>get</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>set</td>\n<td>undefined</td>\n</tr>\n<tr>\n<td>writable</td>\n<td>false</td>\n</tr>\n<tr>\n<td>enumerable</td>\n<td>false</td>\n</tr>\n<tr>\n<td>configurable</td>\n<td>false</td>\n</tr>\n</tbody></table>\n<p>二、什么是 getter 和 setter<br>getter 是一种获得属性值的方法，setter 是一种设置属性值的方法<br>getter 负责查询值，它不带任何参数，setter 则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的 return 都是无效的<br>get/set 访问器不是对象的属性，而是属性的特性，特性只有内部才用，因此在 javaScript 中不能直接访问他们，为了表示特性是内部值用两队中括号括起来表示如[[Value]]<br>对象的属性又可分为对象属性和访问器属性</p>\n<h2 id=\"set-get\"><a href=\"#set-get\" class=\"headerlink\" title=\"set/get\"></a>set/get</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> person = &#123;</span><br><span class=\"line\">  _name: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">  <span class=\"keyword\">get</span> name() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._name;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span> name(n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>._name = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试</span></span><br><span class=\"line\">person.name; <span class=\"comment\">// 输出 --&gt; ''</span></span><br><span class=\"line\">person.name = <span class=\"string\">\"xiaoming\"</span>;</span><br><span class=\"line\">person.name; <span class=\"comment\">// 输出 --&gt; xiaoming</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"存取描述符-–是由一对-getter、setter-函数功能来描述的属性\"><a href=\"#存取描述符-–是由一对-getter、setter-函数功能来描述的属性\" class=\"headerlink\" title=\"存取描述符 –是由一对 getter、setter 函数功能来描述的属性\"></a>存取描述符 –是由一对 getter、setter 函数功能来描述的属性</h2><p>get：一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。<br>set：一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var person = function() &#123;</span><br><span class=\"line\">    var _name = &apos; &apos;;</span><br><span class=\"line\">    var obj = &#123;&#125;;</span><br><span class=\"line\">    Object.defineProperty(obj, &apos;name&apos;, &#123;</span><br><span class=\"line\">        configurable: true,</span><br><span class=\"line\">        enumerable: true,</span><br><span class=\"line\">        get: function() &#123;</span><br><span class=\"line\">            return _name;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set: function(n) &#123;</span><br><span class=\"line\">            _name = n;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return obj;</span><br><span class=\"line\">&#125;();</span><br><span class=\"line\">person.name = &quot;xiaoming&quot;;</span><br><span class=\"line\">person.name // 输出 --&gt; xiaoming</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"vue-的双项数据绑定原理\"><a href=\"#vue-的双项数据绑定原理\" class=\"headerlink\" title=\"vue 的双项数据绑定原理\"></a>vue 的双项数据绑定原理</h2><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。我们先来看 Object.defineProperty()这个方法：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"我被获取了\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"keyword\">set</span>: function(newVal) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"我被设置了\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">obj.name = <span class=\"string\">\"fei\"</span>; <span class=\"comment\">//在给obj设置name属性的时候，触发了set这个方法</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> val = obj.name; <span class=\"comment\">//在得到obj的name属性，会触发get方法</span></span><br></pre></td></tr></table></figure>\n\n<p>vue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 Object.defineProperty()来实现对属性的劫持，那么在设置或者获取的时候我们就可以在 get 或者 set 方法里假如其他的触发函数，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。</p>\n<h2 id=\"实现最简单的双向绑定\"><a href=\"#实现最简单的双向绑定\" class=\"headerlink\" title=\"实现最简单的双向绑定\"></a>实现最简单的双向绑定</h2><p>通过 Object.defineProperty()可以实现数据劫持，是的属性在赋值的时候触发 set 方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=<span class=\"string\">\"en\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;meta charset=<span class=\"string\">\"UTF-8\"</span>&gt;</span><br><span class=\"line\">    &lt;title&gt;Document&lt;<span class=\"regexp\">/title&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>head&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div id=<span class=\"string\">\"demo\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">    &lt;input type=<span class=\"string\">\"text\"</span> id=<span class=\"string\">\"inp\"</span>&gt;</span><br><span class=\"line\">    &lt;script&gt;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> obj  = &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> demo = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#demo'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> inp = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#inp'</span>)</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(obj, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">            <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            <span class=\"keyword\">set</span>: function (newVal) &#123;<span class=\"comment\">//当该属性被赋值的时候触发</span></span><br><span class=\"line\">                inp.value = newVal;</span><br><span class=\"line\">                demo.innerHTML = newVal;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        inp.addEventListener(<span class=\"string\">'input'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">// 给obj的name属性赋值，进而触发该属性的set方法</span></span><br><span class=\"line\">            obj.name = e.target.value;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        obj.name = <span class=\"string\">'changme'</span>;<span class=\"comment\">//在给obj设置name属性的时候，触发了set这个方法</span></span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"vue-代码实现\"><a href=\"#vue-代码实现\" class=\"headerlink\" title=\"vue 代码实现\"></a>vue 代码实现</h2><p>observer 实现，主要是给每个 vue 的属性用 Object.defineProperty()，代码如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">defineReactive</span>(<span class=\"params\">obj, key, val</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> dep = <span class=\"keyword\">new</span> Dep();</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.defineProperty(obj, key, &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>: function() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//添加订阅者watcher到主题对象Dep</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (Dep.target) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用</span></span><br><span class=\"line\">        dep.addSub(Dep.target);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> val;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">set</span>: function(newVal) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (newVal === val) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">      val = newVal;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(val);</span><br><span class=\"line\">      <span class=\"comment\">// 作为发布者发出通知</span></span><br><span class=\"line\">      dep.notify(); <span class=\"comment\">//通知后dep会循环调用各自的update方法更新视图</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">obj, vm</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(obj).forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">    defineReactive(vm, key, obj[key]);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>未完，待续、、、</p>\n"},{"title":"什么是BFC","date":"2019-09-18T01:48:56.000Z","author":"刘涛","_content":"\n\n## 前言\n对于BFC的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。\n\n## 什么是BFC\nBFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。\n\n\n## 触发BFC\n1. float的值不能为none\n2. overflow的值不能为visible\n3. display的值为table-cell, table-caption, inline-block中的任何一个\n4. position的值不为relative和static \n\n\n## BFC的约束条件\n1. 内部的Box会在垂直方向上一个接一个的放置\n2. 垂直方向的距离有margin决定(属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关)\n3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此\n4. BFC的区域不会与float的元素区域重叠\n5. 计算BFC的高度时，浮动子元素也参与计算\n6. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然\n\n\n## BFC的特性\n### 特性1：BFC会阻止垂直外边距折叠\n  **按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠**，这个包括相邻元素或者嵌套元素，只要他们之间没有阻挡（**比如边框、非空内容、padding等**）就会发生margin重叠。\n\n  #### ①相邻兄弟元素margin重叠问题\n  ```css\n  <style>\n  p{\n     color: #fff;\n     background: #888;\n     width: 200px;\n     line-height: 100px;\n     text-align:center;\n     margin: 100px;\n    }\n  </style>\n<body>\n    <p>ABC</p>\n    <p>abc</p>\n</body>\n  ```\n  ![相邻兄弟元素margin重叠问题](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc1.jpg)\n\n  上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？**只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。**\n\n  **解决方案**\n   ```css\n  <style>\n  p{\n     color: #fff;\n     background: #888;\n     width: 200px;\n     line-height: 100px;\n     text-align:center;\n     margin: 100px;\n    }\n  .wrap{\n    overflow:hidden;\n  }\n  </style>\n<body>\n   <p>ABC</p>\n  <div class=\"wrap\">\n    <p>abc</p>\n  </div>\n</body>\n  ```\n  ![相邻兄弟元素margin重叠问题的解决方案](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc2.jpg)\n\n  #### ②父子元素margin重叠问题\n   ```css\n    <style>\n     .box{\n        width:100px;\n        height:100px;\n        background:#ccc;\n        }\n     .wrap {\n       background:yellow;\n       }\n     .wrap h1{\n        background:pink;\n        margin:40px;\n        }\n    </style>\n<body>\n<div class=\"box\">box</div>\n<div class=\"wrap\">\n  <h1>h1</h1>\n</div>\n</body>\n  ```\n  ![父子元素margin重叠问题](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc3.jpg)\n\n  **解决方案**\n   上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？处理方法其实有很多，**在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；**这些都可以有效解决父子元素margin重叠问题。\n![父子元素margin重叠问题解决方案](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc4.jpg)\n\n\n### 特性2：BFC不会重叠浮动元素\n如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子\n\n``` css\n<style>\n.box1{\n  height: 100px;\n  width: 100px;\n  float: left;\n  background: lightblue;\n}\n.box2{width: 200px;\n  height: 200px;\n  background: #eee;\n}\n</style>\n<body>\n<div class=\"box1\">我是一个左浮动的元素</div>\n<div class=\"box2\">喂喂喂!大家不要生气嘛，生气会犯嗔戒的。悟空你也太调皮了，\n我跟你说过叫你不要乱扔东西，你怎么又……你看，我还没说完你就把棍子给扔掉了!\n月光宝盒是宝物，你把它扔掉会污染环境，要是砸到小朋友怎么办，就算砸不到小朋友，\n砸到花花草草也是不对的。</div>\n</body>\n```\n![BFC不会重叠浮动元素1](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc5.jpg)\n\n上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以**为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。**\n\n![BFC不会重叠浮动元素2](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc6.jpg)\n\n这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！\n\n### 特性3：BFC可以包含浮动----清除浮动\n我们都知道浮动会脱离文档流，接下来我们看看下面的例子：\n\n``` css\n<style>\n    .par {\n        border: 5px solid #fcc;\n        width: 300px;\n    }\n\n    .child {\n        border: 5px solid #f66;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n</style>\n<body>\n    <div class=\"par\">\n        <div class=\"child\"></div>\n        <div class=\"child\"></div>\n    </div>\n</body>\n```\n![清除浮动1](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc7.jpg)\n\n由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden\n\n![清除浮动2](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc8.jpg)\n\n","source":"_posts/什么是BFC.md","raw":"---\ntitle: 什么是BFC\ndate: 2019-09-18 09:48:56\ntags: css\nauthor: 刘涛\n---\n\n\n## 前言\n对于BFC的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。\n\n## 什么是BFC\nBFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。\n\n\n## 触发BFC\n1. float的值不能为none\n2. overflow的值不能为visible\n3. display的值为table-cell, table-caption, inline-block中的任何一个\n4. position的值不为relative和static \n\n\n## BFC的约束条件\n1. 内部的Box会在垂直方向上一个接一个的放置\n2. 垂直方向的距离有margin决定(属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关)\n3. 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此\n4. BFC的区域不会与float的元素区域重叠\n5. 计算BFC的高度时，浮动子元素也参与计算\n6. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然\n\n\n## BFC的特性\n### 特性1：BFC会阻止垂直外边距折叠\n  **按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠**，这个包括相邻元素或者嵌套元素，只要他们之间没有阻挡（**比如边框、非空内容、padding等**）就会发生margin重叠。\n\n  #### ①相邻兄弟元素margin重叠问题\n  ```css\n  <style>\n  p{\n     color: #fff;\n     background: #888;\n     width: 200px;\n     line-height: 100px;\n     text-align:center;\n     margin: 100px;\n    }\n  </style>\n<body>\n    <p>ABC</p>\n    <p>abc</p>\n</body>\n  ```\n  ![相邻兄弟元素margin重叠问题](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc1.jpg)\n\n  上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？**只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。**\n\n  **解决方案**\n   ```css\n  <style>\n  p{\n     color: #fff;\n     background: #888;\n     width: 200px;\n     line-height: 100px;\n     text-align:center;\n     margin: 100px;\n    }\n  .wrap{\n    overflow:hidden;\n  }\n  </style>\n<body>\n   <p>ABC</p>\n  <div class=\"wrap\">\n    <p>abc</p>\n  </div>\n</body>\n  ```\n  ![相邻兄弟元素margin重叠问题的解决方案](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc2.jpg)\n\n  #### ②父子元素margin重叠问题\n   ```css\n    <style>\n     .box{\n        width:100px;\n        height:100px;\n        background:#ccc;\n        }\n     .wrap {\n       background:yellow;\n       }\n     .wrap h1{\n        background:pink;\n        margin:40px;\n        }\n    </style>\n<body>\n<div class=\"box\">box</div>\n<div class=\"wrap\">\n  <h1>h1</h1>\n</div>\n</body>\n  ```\n  ![父子元素margin重叠问题](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc3.jpg)\n\n  **解决方案**\n   上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？处理方法其实有很多，**在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；**这些都可以有效解决父子元素margin重叠问题。\n![父子元素margin重叠问题解决方案](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc4.jpg)\n\n\n### 特性2：BFC不会重叠浮动元素\n如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子\n\n``` css\n<style>\n.box1{\n  height: 100px;\n  width: 100px;\n  float: left;\n  background: lightblue;\n}\n.box2{width: 200px;\n  height: 200px;\n  background: #eee;\n}\n</style>\n<body>\n<div class=\"box1\">我是一个左浮动的元素</div>\n<div class=\"box2\">喂喂喂!大家不要生气嘛，生气会犯嗔戒的。悟空你也太调皮了，\n我跟你说过叫你不要乱扔东西，你怎么又……你看，我还没说完你就把棍子给扔掉了!\n月光宝盒是宝物，你把它扔掉会污染环境，要是砸到小朋友怎么办，就算砸不到小朋友，\n砸到花花草草也是不对的。</div>\n</body>\n```\n![BFC不会重叠浮动元素1](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc5.jpg)\n\n上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以**为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。**\n\n![BFC不会重叠浮动元素2](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc6.jpg)\n\n这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！\n\n### 特性3：BFC可以包含浮动----清除浮动\n我们都知道浮动会脱离文档流，接下来我们看看下面的例子：\n\n``` css\n<style>\n    .par {\n        border: 5px solid #fcc;\n        width: 300px;\n    }\n\n    .child {\n        border: 5px solid #f66;\n        width:100px;\n        height: 100px;\n        float: left;\n    }\n</style>\n<body>\n    <div class=\"par\">\n        <div class=\"child\"></div>\n        <div class=\"child\"></div>\n    </div>\n</body>\n```\n![清除浮动1](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc7.jpg)\n\n由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden\n\n![清除浮动2](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc8.jpg)\n\n","slug":"什么是BFC","published":1,"updated":"2019-10-03T05:57:31.166Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufwb000l4sefzkknzyfg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于BFC的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。</p>\n<h2 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h2><p>BFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。</p>\n<h2 id=\"触发BFC\"><a href=\"#触发BFC\" class=\"headerlink\" title=\"触发BFC\"></a>触发BFC</h2><ol>\n<li>float的值不能为none</li>\n<li>overflow的值不能为visible</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个</li>\n<li>position的值不为relative和static </li>\n</ol>\n<h2 id=\"BFC的约束条件\"><a href=\"#BFC的约束条件\" class=\"headerlink\" title=\"BFC的约束条件\"></a>BFC的约束条件</h2><ol>\n<li>内部的Box会在垂直方向上一个接一个的放置</li>\n<li>垂直方向的距离有margin决定(属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关)</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li>\n<li>BFC的区域不会与float的元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li>\n</ol>\n<h2 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h2><h3 id=\"特性1：BFC会阻止垂直外边距折叠\"><a href=\"#特性1：BFC会阻止垂直外边距折叠\" class=\"headerlink\" title=\"特性1：BFC会阻止垂直外边距折叠\"></a>特性1：BFC会阻止垂直外边距折叠</h3><p>  <strong>按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠</strong>，这个包括相邻元素或者嵌套元素，只要他们之间没有阻挡（<strong>比如边框、非空内容、padding等</strong>）就会发生margin重叠。</p>\n<h4 id=\"①相邻兄弟元素margin重叠问题\"><a href=\"#①相邻兄弟元素margin重叠问题\" class=\"headerlink\" title=\"①相邻兄弟元素margin重叠问题\"></a>①相邻兄弟元素margin重叠问题</h4>  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">  <span class=\"selector-tag\">p</span>&#123;</span><br><span class=\"line\">     <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: <span class=\"number\">#888</span>;</span><br><span class=\"line\">     <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">     <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;ABC&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;abc&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc1.jpg\" alt=\"相邻兄弟元素margin重叠问题\"></p>\n<p>  上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？<strong>只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。</strong></p>\n<p>  <strong>解决方案</strong><br>   <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">  <span class=\"selector-tag\">p</span>&#123;</span><br><span class=\"line\">     <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: <span class=\"number\">#888</span>;</span><br><span class=\"line\">     <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">     <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">   &lt;p&gt;ABC&lt;/p&gt;</span><br><span class=\"line\">  &lt;div class=\"wrap\"&gt;</span><br><span class=\"line\">    &lt;p&gt;abc&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc2.jpg\" alt=\"相邻兄弟元素margin重叠问题的解决方案\"></p>\n<h4 id=\"②父子元素margin重叠问题\"><a href=\"#②父子元素margin重叠问题\" class=\"headerlink\" title=\"②父子元素margin重叠问题\"></a>②父子元素margin重叠问题</h4>   <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">     <span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>:<span class=\"number\">#ccc</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"selector-class\">.wrap</span> &#123;</span><br><span class=\"line\">       <span class=\"attribute\">background</span>:yellow;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"selector-class\">.wrap</span> <span class=\"selector-tag\">h1</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>:pink;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>:<span class=\"number\">40px</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">&lt;div class=\"box\"&gt;box&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=\"wrap\"&gt;</span><br><span class=\"line\">  &lt;h1&gt;h1&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc3.jpg\" alt=\"父子元素margin重叠问题\"></p>\n<p>  <strong>解决方案</strong><br>   上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？处理方法其实有很多，<strong>在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；</strong>这些都可以有效解决父子元素margin重叠问题。<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc4.jpg\" alt=\"父子元素margin重叠问题解决方案\"></p>\n<h3 id=\"特性2：BFC不会重叠浮动元素\"><a href=\"#特性2：BFC不会重叠浮动元素\" class=\"headerlink\" title=\"特性2：BFC不会重叠浮动元素\"></a>特性2：BFC不会重叠浮动元素</h3><p>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\"><span class=\"selector-class\">.box1</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box2</span>&#123;<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">&lt;div class=\"box1\"&gt;我是一个左浮动的元素&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=\"box2\"&gt;喂喂喂!大家不要生气嘛，生气会犯嗔戒的。悟空你也太调皮了，</span><br><span class=\"line\">我跟你说过叫你不要乱扔东西，你怎么又……你看，我还没说完你就把棍子给扔掉了!</span><br><span class=\"line\">月光宝盒是宝物，你把它扔掉会污染环境，要是砸到小朋友怎么办，就算砸不到小朋友，</span><br><span class=\"line\">砸到花花草草也是不对的。&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc5.jpg\" alt=\"BFC不会重叠浮动元素1\"></p>\n<p>上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以<strong>为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。</strong></p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc6.jpg\" alt=\"BFC不会重叠浮动元素2\"></p>\n<p>这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！</p>\n<h3 id=\"特性3：BFC可以包含浮动—-清除浮动\"><a href=\"#特性3：BFC可以包含浮动—-清除浮动\" class=\"headerlink\" title=\"特性3：BFC可以包含浮动—-清除浮动\"></a>特性3：BFC可以包含浮动—-清除浮动</h3><p>我们都知道浮动会脱离文档流，接下来我们看看下面的例子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">    <span class=\"selector-class\">.par</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#fcc</span>;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#f66</span>;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">    &lt;div class=\"par\"&gt;</span><br><span class=\"line\">        &lt;div class=\"child\"&gt;&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=\"child\"&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc7.jpg\" alt=\"清除浮动1\"></p>\n<p>由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc8.jpg\" alt=\"清除浮动2\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于BFC的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。</p>\n<h2 id=\"什么是BFC\"><a href=\"#什么是BFC\" class=\"headerlink\" title=\"什么是BFC\"></a>什么是BFC</h2><p>BFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。</p>\n<h2 id=\"触发BFC\"><a href=\"#触发BFC\" class=\"headerlink\" title=\"触发BFC\"></a>触发BFC</h2><ol>\n<li>float的值不能为none</li>\n<li>overflow的值不能为visible</li>\n<li>display的值为table-cell, table-caption, inline-block中的任何一个</li>\n<li>position的值不为relative和static </li>\n</ol>\n<h2 id=\"BFC的约束条件\"><a href=\"#BFC的约束条件\" class=\"headerlink\" title=\"BFC的约束条件\"></a>BFC的约束条件</h2><ol>\n<li>内部的Box会在垂直方向上一个接一个的放置</li>\n<li>垂直方向的距离有margin决定(属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关)</li>\n<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此</li>\n<li>BFC的区域不会与float的元素区域重叠</li>\n<li>计算BFC的高度时，浮动子元素也参与计算</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然</li>\n</ol>\n<h2 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h2><h3 id=\"特性1：BFC会阻止垂直外边距折叠\"><a href=\"#特性1：BFC会阻止垂直外边距折叠\" class=\"headerlink\" title=\"特性1：BFC会阻止垂直外边距折叠\"></a>特性1：BFC会阻止垂直外边距折叠</h3><p>  <strong>按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠</strong>，这个包括相邻元素或者嵌套元素，只要他们之间没有阻挡（<strong>比如边框、非空内容、padding等</strong>）就会发生margin重叠。</p>\n<h4 id=\"①相邻兄弟元素margin重叠问题\"><a href=\"#①相邻兄弟元素margin重叠问题\" class=\"headerlink\" title=\"①相邻兄弟元素margin重叠问题\"></a>①相邻兄弟元素margin重叠问题</h4>  <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">  <span class=\"selector-tag\">p</span>&#123;</span><br><span class=\"line\">     <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: <span class=\"number\">#888</span>;</span><br><span class=\"line\">     <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">     <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;ABC&lt;/p&gt;</span><br><span class=\"line\">    &lt;p&gt;abc&lt;/p&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc1.jpg\" alt=\"相邻兄弟元素margin重叠问题\"></p>\n<p>  上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？<strong>只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。</strong></p>\n<p>  <strong>解决方案</strong><br>   <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  &lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">  <span class=\"selector-tag\">p</span>&#123;</span><br><span class=\"line\">     <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">     <span class=\"attribute\">background</span>: <span class=\"number\">#888</span>;</span><br><span class=\"line\">     <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">line-height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">     <span class=\"attribute\">text-align</span>:center;</span><br><span class=\"line\">     <span class=\"attribute\">margin</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"selector-class\">.wrap</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>:hidden;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">   &lt;p&gt;ABC&lt;/p&gt;</span><br><span class=\"line\">  &lt;div class=\"wrap\"&gt;</span><br><span class=\"line\">    &lt;p&gt;abc&lt;/p&gt;</span><br><span class=\"line\">  &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>\n<p>  <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc2.jpg\" alt=\"相邻兄弟元素margin重叠问题的解决方案\"></p>\n<h4 id=\"②父子元素margin重叠问题\"><a href=\"#②父子元素margin重叠问题\" class=\"headerlink\" title=\"②父子元素margin重叠问题\"></a>②父子元素margin重叠问题</h4>   <figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    &lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">     <span class=\"selector-class\">.box</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>:<span class=\"number\">#ccc</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"selector-class\">.wrap</span> &#123;</span><br><span class=\"line\">       <span class=\"attribute\">background</span>:yellow;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     <span class=\"selector-class\">.wrap</span> <span class=\"selector-tag\">h1</span>&#123;</span><br><span class=\"line\">        <span class=\"attribute\">background</span>:pink;</span><br><span class=\"line\">        <span class=\"attribute\">margin</span>:<span class=\"number\">40px</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">&lt;div class=\"box\"&gt;box&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=\"wrap\"&gt;</span><br><span class=\"line\">  &lt;h1&gt;h1&lt;/h1&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p>  <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc3.jpg\" alt=\"父子元素margin重叠问题\"></p>\n<p>  <strong>解决方案</strong><br>   上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？处理方法其实有很多，<strong>在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；</strong>这些都可以有效解决父子元素margin重叠问题。<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc4.jpg\" alt=\"父子元素margin重叠问题解决方案\"></p>\n<h3 id=\"特性2：BFC不会重叠浮动元素\"><a href=\"#特性2：BFC不会重叠浮动元素\" class=\"headerlink\" title=\"特性2：BFC不会重叠浮动元素\"></a>特性2：BFC不会重叠浮动元素</h3><p>如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\"><span class=\"selector-class\">.box1</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: lightblue;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.box2</span>&#123;<span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">200px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">background</span>: <span class=\"number\">#eee</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">&lt;div class=\"box1\"&gt;我是一个左浮动的元素&lt;/div&gt;</span><br><span class=\"line\">&lt;div class=\"box2\"&gt;喂喂喂!大家不要生气嘛，生气会犯嗔戒的。悟空你也太调皮了，</span><br><span class=\"line\">我跟你说过叫你不要乱扔东西，你怎么又……你看，我还没说完你就把棍子给扔掉了!</span><br><span class=\"line\">月光宝盒是宝物，你把它扔掉会污染环境，要是砸到小朋友怎么办，就算砸不到小朋友，</span><br><span class=\"line\">砸到花花草草也是不对的。&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc5.jpg\" alt=\"BFC不会重叠浮动元素1\"></p>\n<p>上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以<strong>为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。</strong></p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc6.jpg\" alt=\"BFC不会重叠浮动元素2\"></p>\n<p>这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！</p>\n<h3 id=\"特性3：BFC可以包含浮动—-清除浮动\"><a href=\"#特性3：BFC可以包含浮动—-清除浮动\" class=\"headerlink\" title=\"特性3：BFC可以包含浮动—-清除浮动\"></a>特性3：BFC可以包含浮动—-清除浮动</h3><p>我们都知道浮动会脱离文档流，接下来我们看看下面的例子：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;<span class=\"selector-tag\">style</span>&gt;</span><br><span class=\"line\">    <span class=\"selector-class\">.par</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#fcc</span>;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>: <span class=\"number\">300px</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"selector-class\">.child</span> &#123;</span><br><span class=\"line\">        <span class=\"attribute\">border</span>: <span class=\"number\">5px</span> solid <span class=\"number\">#f66</span>;</span><br><span class=\"line\">        <span class=\"attribute\">width</span>:<span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">        <span class=\"attribute\">float</span>: left;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;<span class=\"selector-tag\">body</span>&gt;</span><br><span class=\"line\">    &lt;div class=\"par\"&gt;</span><br><span class=\"line\">        &lt;div class=\"child\"&gt;&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=\"child\"&gt;&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc7.jpg\" alt=\"清除浮动1\"></p>\n<p>由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/BFC/bfc8.jpg\" alt=\"清除浮动2\"></p>\n"},{"title":"使用console进行 性能测试 和 计算代码运行时间","date":"2019-09-17T06:42:09.000Z","author":"胡豪","_content":"\n## 前言\n对于前端开发人员，在开发过程中经常需要监控某些表达式或变量的值，如果使用用 debugger 会显得过于笨重，最常用的方法是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。\n\n\n## trace\n\n`console.trace()`用来追踪函数的调用过程。\n\n在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，`console.trace()`方法可以将函数的被调用过程清楚地输出到控制台上。\n```html\n<button onclick=\"myFunction()\">跟踪轨迹</button>\n```\n\n```js \n\nfunction myFunction() {\n  console.log(1)\n  myOtherFunction();\n  console.log(2)\n}\n\nfunction myOtherFunction() {\n  console.log(3);\n  myOtherFunction2();\n  console.log(4);\n}\nfunction myOtherFunction2() {\n  console.trace();\n}\n```\n打印结果：\n![console.trace](https://tvax4.sinaimg.cn/large/b535b7d3ly1g7ua23a4x5j20w107bjrt.jpg)\n\n\n## table\n\n使用console将对象以表格呈现\n\n可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。\n```js\nvar Teletubbies = {\n  Tinky:{ \n    name: 'Tinky',\n    age: '3'\n  },\n  lala: {\n    name: 'lala',\n    age: '6'\n  },\n  Daisy: {\n    name: 'Daisy',\n    age: '4'\n  },\n  po:{\n    name:'po',\n    age:'5'\n  }\n};\nconsole.table(Teletubbies);\n```\n打印结果：\n![console.table](https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23dxjij20v1064gls.jpg)\n\n\n## console.time进行时间计算\n\n计算程序的执行时间\n\n可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上\n```js\nconsole.time('计时器');\nfor (var i = 0; i < 1000; i++) {\n  for (var j = 0; j < 1000; j++) {}\n}\nconsole.timeEnd('计时器');\n```\n以上代码可以计算出`console.time('计时器')`和`console.timeEnd('计时器')`之间的代码块所需要的时间。\n\n\n## 还可以console.log配合Date对象计算\n除了console.time()还可以用console.log配合Date对象计算\n```js\nvar beginTime = +new Date();\n  for (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 1000; j++) {}\n  }\nvar endTime = +new Date();\nconsole.log(\"用时共计\"+(endTime-beginTime)+\"ms\");\n\n\n//或者\nvar beginTime  = new Date().getTime() \nfor (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 1000; j++) {}\n  }\nvar endTime  = new Date().getTime()\nconsole.log(\"用时共计\"+(endTime-beginTime)+\"ms\");\n\n//或者\nvar beginTime  = Date.now()\nfor (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 1000; j++) {}\n  }\nvar endTime  = Date.now()\nconsole.log(\"用时共计\"+(endTime-beginTime)+\"ms\");\n```\n那么聪明的你肯定会问这三者的的区别\n\n### Date.now()与 new Date().getTime() 的区别\n它们都可以获取时间戳，但是实际上性能是不一样的（虽然差别不大，但是也算是一种性能的追求），可以做个测试\n```js\n  console.time('+new Date()')\n  for(var i = 0; i < 100000; i++) {\n    var o = + new Date()\n  }\n  console.timeEnd('+new Date()')\n\n  console.time('new Date().getTime:')\n  for(var j = 0; j < 100000; j++) {\n    var p = new Date().getTime();\n  }\n  console.timeEnd('new Date().getTime:')\n\n  console.time('Date.now()')\n  for(var k = 0; k < 100000; k++) {\n    var q = Date.now()\n  }\n  console.timeEnd('Date.now()') \n\n  //输出\n  +new Date(): 42.31396484375ms\n  new Date().getTime:: 33.93408203125ms\n  Date.now(): 24.561767578125ms\n```\n测试用例[https://jsperf.com/date-now-vs-new-date]\n\n![测试用例](https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23h8toj20r20m6mxz.jpg)\n\n## profile\n\n使用`console.profile`测试程序性能\n\n开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。\n\n```js\nfunction parent() {\n      for (var i = 0; i < 10000; i++) {\n            childA()\n      }\n}\n\nfunction childA() {\n      for (var i = 0; i < 2000; i++) {}\n}\n\nconsole.profile('性能分析');\nparent();\nconsole.profileEnd('性能分析');\n\n//执行后\n//Profile '性能分析' started.\n//Profile '性能分析' finished.\n```\n![console.profile](https://tva3.sinaimg.cn/large/b535b7d3ly1g7ua23n1qvj210105uaad.jpg)\n","source":"_posts/使用console进行-性能测试-和-计算代码运行时间.md","raw":"---\ntitle: 使用console进行 性能测试 和 计算代码运行时间\ndate: 2019-09-17 14:42:09\nauthor: 胡豪\ncategories: \n- JavaScript \ntags:\n- 性能测试 \n---\n\n## 前言\n对于前端开发人员，在开发过程中经常需要监控某些表达式或变量的值，如果使用用 debugger 会显得过于笨重，最常用的方法是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。\n\n\n## trace\n\n`console.trace()`用来追踪函数的调用过程。\n\n在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，`console.trace()`方法可以将函数的被调用过程清楚地输出到控制台上。\n```html\n<button onclick=\"myFunction()\">跟踪轨迹</button>\n```\n\n```js \n\nfunction myFunction() {\n  console.log(1)\n  myOtherFunction();\n  console.log(2)\n}\n\nfunction myOtherFunction() {\n  console.log(3);\n  myOtherFunction2();\n  console.log(4);\n}\nfunction myOtherFunction2() {\n  console.trace();\n}\n```\n打印结果：\n![console.trace](https://tvax4.sinaimg.cn/large/b535b7d3ly1g7ua23a4x5j20w107bjrt.jpg)\n\n\n## table\n\n使用console将对象以表格呈现\n\n可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。\n```js\nvar Teletubbies = {\n  Tinky:{ \n    name: 'Tinky',\n    age: '3'\n  },\n  lala: {\n    name: 'lala',\n    age: '6'\n  },\n  Daisy: {\n    name: 'Daisy',\n    age: '4'\n  },\n  po:{\n    name:'po',\n    age:'5'\n  }\n};\nconsole.table(Teletubbies);\n```\n打印结果：\n![console.table](https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23dxjij20v1064gls.jpg)\n\n\n## console.time进行时间计算\n\n计算程序的执行时间\n\n可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上\n```js\nconsole.time('计时器');\nfor (var i = 0; i < 1000; i++) {\n  for (var j = 0; j < 1000; j++) {}\n}\nconsole.timeEnd('计时器');\n```\n以上代码可以计算出`console.time('计时器')`和`console.timeEnd('计时器')`之间的代码块所需要的时间。\n\n\n## 还可以console.log配合Date对象计算\n除了console.time()还可以用console.log配合Date对象计算\n```js\nvar beginTime = +new Date();\n  for (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 1000; j++) {}\n  }\nvar endTime = +new Date();\nconsole.log(\"用时共计\"+(endTime-beginTime)+\"ms\");\n\n\n//或者\nvar beginTime  = new Date().getTime() \nfor (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 1000; j++) {}\n  }\nvar endTime  = new Date().getTime()\nconsole.log(\"用时共计\"+(endTime-beginTime)+\"ms\");\n\n//或者\nvar beginTime  = Date.now()\nfor (var i = 0; i < 1000; i++) {\n    for (var j = 0; j < 1000; j++) {}\n  }\nvar endTime  = Date.now()\nconsole.log(\"用时共计\"+(endTime-beginTime)+\"ms\");\n```\n那么聪明的你肯定会问这三者的的区别\n\n### Date.now()与 new Date().getTime() 的区别\n它们都可以获取时间戳，但是实际上性能是不一样的（虽然差别不大，但是也算是一种性能的追求），可以做个测试\n```js\n  console.time('+new Date()')\n  for(var i = 0; i < 100000; i++) {\n    var o = + new Date()\n  }\n  console.timeEnd('+new Date()')\n\n  console.time('new Date().getTime:')\n  for(var j = 0; j < 100000; j++) {\n    var p = new Date().getTime();\n  }\n  console.timeEnd('new Date().getTime:')\n\n  console.time('Date.now()')\n  for(var k = 0; k < 100000; k++) {\n    var q = Date.now()\n  }\n  console.timeEnd('Date.now()') \n\n  //输出\n  +new Date(): 42.31396484375ms\n  new Date().getTime:: 33.93408203125ms\n  Date.now(): 24.561767578125ms\n```\n测试用例[https://jsperf.com/date-now-vs-new-date]\n\n![测试用例](https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23h8toj20r20m6mxz.jpg)\n\n## profile\n\n使用`console.profile`测试程序性能\n\n开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。\n\n```js\nfunction parent() {\n      for (var i = 0; i < 10000; i++) {\n            childA()\n      }\n}\n\nfunction childA() {\n      for (var i = 0; i < 2000; i++) {}\n}\n\nconsole.profile('性能分析');\nparent();\nconsole.profileEnd('性能分析');\n\n//执行后\n//Profile '性能分析' started.\n//Profile '性能分析' finished.\n```\n![console.profile](https://tva3.sinaimg.cn/large/b535b7d3ly1g7ua23n1qvj210105uaad.jpg)\n","slug":"使用console进行-性能测试-和-计算代码运行时间","published":1,"updated":"2019-10-22T12:09:19.569Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufwd000o4sef61kkbj2n","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于前端开发人员，在开发过程中经常需要监控某些表达式或变量的值，如果使用用 debugger 会显得过于笨重，最常用的方法是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。</p>\n<h2 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h2><p><code>console.trace()</code>用来追踪函数的调用过程。</p>\n<p>在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，<code>console.trace()</code>方法可以将函数的被调用过程清楚地输出到控制台上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>跟踪轨迹<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  myOtherFunction();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myOtherFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">  myOtherFunction2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myOtherFunction2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.trace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：<br><img src=\"https://tvax4.sinaimg.cn/large/b535b7d3ly1g7ua23a4x5j20w107bjrt.jpg\" alt=\"console.trace\"></p>\n<h2 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h2><p>使用console将对象以表格呈现</p>\n<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Teletubbies = &#123;</span><br><span class=\"line\">  Tinky:&#123; </span><br><span class=\"line\">    name: <span class=\"string\">'Tinky'</span>,</span><br><span class=\"line\">    age: <span class=\"string\">'3'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  lala: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'lala'</span>,</span><br><span class=\"line\">    age: <span class=\"string\">'6'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  Daisy: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Daisy'</span>,</span><br><span class=\"line\">    age: <span class=\"string\">'4'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  po:&#123;</span><br><span class=\"line\">    name:<span class=\"string\">'po'</span>,</span><br><span class=\"line\">    age:<span class=\"string\">'5'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.table(Teletubbies);</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：<br><img src=\"https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23dxjij20v1064gls.jpg\" alt=\"console.table\"></p>\n<h2 id=\"console-time进行时间计算\"><a href=\"#console-time进行时间计算\" class=\"headerlink\" title=\"console.time进行时间计算\"></a>console.time进行时间计算</h2><p>计算程序的执行时间</p>\n<p>可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'计时器'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'计时器'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上代码可以计算出<code>console.time(&#39;计时器&#39;)</code>和<code>console.timeEnd(&#39;计时器&#39;)</code>之间的代码块所需要的时间。</p>\n<h2 id=\"还可以console-log配合Date对象计算\"><a href=\"#还可以console-log配合Date对象计算\" class=\"headerlink\" title=\"还可以console.log配合Date对象计算\"></a>还可以console.log配合Date对象计算</h2><p>除了console.time()还可以用console.log配合Date对象计算</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> beginTime = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"用时共计\"</span>+(endTime-beginTime)+<span class=\"string\">\"ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> beginTime  = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime  = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"用时共计\"</span>+(endTime-beginTime)+<span class=\"string\">\"ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> beginTime  = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime  = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"用时共计\"</span>+(endTime-beginTime)+<span class=\"string\">\"ms\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么聪明的你肯定会问这三者的的区别</p>\n<h3 id=\"Date-now-与-new-Date-getTime-的区别\"><a href=\"#Date-now-与-new-Date-getTime-的区别\" class=\"headerlink\" title=\"Date.now()与 new Date().getTime() 的区别\"></a>Date.now()与 new Date().getTime() 的区别</h3><p>它们都可以获取时间戳，但是实际上性能是不一样的（虽然差别不大，但是也算是一种性能的追求），可以做个测试</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'+new Date()'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'+new Date()'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'new Date().getTime:'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">100000</span>; j++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'new Date().getTime:'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'Date.now()'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">100000</span>; k++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'Date.now()'</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(): <span class=\"number\">42.31396484375</span>ms</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime:: <span class=\"number\">33.93408203125</span>ms</span><br><span class=\"line\"><span class=\"built_in\">Date</span>.now(): <span class=\"number\">24.561767578125</span>ms</span><br></pre></td></tr></table></figure>\n\n<p>测试用例[<a href=\"https://jsperf.com/date-now-vs-new-date]\" target=\"_blank\" rel=\"noopener\">https://jsperf.com/date-now-vs-new-date]</a></p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23h8toj20r20m6mxz.jpg\" alt=\"测试用例\"></p>\n<h2 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h2><p>使用<code>console.profile</code>测试程序性能</p>\n<p>开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            childA()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">childA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2000</span>; i++) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.profile(<span class=\"string\">'性能分析'</span>);</span><br><span class=\"line\">parent();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.profileEnd(<span class=\"string\">'性能分析'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行后</span></span><br><span class=\"line\"><span class=\"comment\">//Profile '性能分析' started.</span></span><br><span class=\"line\"><span class=\"comment\">//Profile '性能分析' finished.</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva3.sinaimg.cn/large/b535b7d3ly1g7ua23n1qvj210105uaad.jpg\" alt=\"console.profile\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于前端开发人员，在开发过程中经常需要监控某些表达式或变量的值，如果使用用 debugger 会显得过于笨重，最常用的方法是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。</p>\n<h2 id=\"trace\"><a href=\"#trace\" class=\"headerlink\" title=\"trace\"></a>trace</h2><p><code>console.trace()</code>用来追踪函数的调用过程。</p>\n<p>在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，<code>console.trace()</code>方法可以将函数的被调用过程清楚地输出到控制台上。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">onclick</span>=<span class=\"string\">\"myFunction()\"</span>&gt;</span>跟踪轨迹<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">  myOtherFunction();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myOtherFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">  myOtherFunction2();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myOtherFunction2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.trace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：<br><img src=\"https://tvax4.sinaimg.cn/large/b535b7d3ly1g7ua23a4x5j20w107bjrt.jpg\" alt=\"console.trace\"></p>\n<h2 id=\"table\"><a href=\"#table\" class=\"headerlink\" title=\"table\"></a>table</h2><p>使用console将对象以表格呈现</p>\n<p>可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Teletubbies = &#123;</span><br><span class=\"line\">  Tinky:&#123; </span><br><span class=\"line\">    name: <span class=\"string\">'Tinky'</span>,</span><br><span class=\"line\">    age: <span class=\"string\">'3'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  lala: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'lala'</span>,</span><br><span class=\"line\">    age: <span class=\"string\">'6'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  Daisy: &#123;</span><br><span class=\"line\">    name: <span class=\"string\">'Daisy'</span>,</span><br><span class=\"line\">    age: <span class=\"string\">'4'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  po:&#123;</span><br><span class=\"line\">    name:<span class=\"string\">'po'</span>,</span><br><span class=\"line\">    age:<span class=\"string\">'5'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.table(Teletubbies);</span><br></pre></td></tr></table></figure>\n\n<p>打印结果：<br><img src=\"https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23dxjij20v1064gls.jpg\" alt=\"console.table\"></p>\n<h2 id=\"console-time进行时间计算\"><a href=\"#console-time进行时间计算\" class=\"headerlink\" title=\"console.time进行时间计算\"></a>console.time进行时间计算</h2><p>计算程序的执行时间</p>\n<p>可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'计时器'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'计时器'</span>);</span><br></pre></td></tr></table></figure>\n\n<p>以上代码可以计算出<code>console.time(&#39;计时器&#39;)</code>和<code>console.timeEnd(&#39;计时器&#39;)</code>之间的代码块所需要的时间。</p>\n<h2 id=\"还可以console-log配合Date对象计算\"><a href=\"#还可以console-log配合Date对象计算\" class=\"headerlink\" title=\"还可以console.log配合Date对象计算\"></a>还可以console.log配合Date对象计算</h2><p>除了console.time()还可以用console.log配合Date对象计算</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> beginTime = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"用时共计\"</span>+(endTime-beginTime)+<span class=\"string\">\"ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> beginTime  = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime() </span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime  = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"用时共计\"</span>+(endTime-beginTime)+<span class=\"string\">\"ms\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//或者</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> beginTime  = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">1000</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">1000</span>; j++) &#123;&#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> endTime  = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">\"用时共计\"</span>+(endTime-beginTime)+<span class=\"string\">\"ms\"</span>);</span><br></pre></td></tr></table></figure>\n\n<p>那么聪明的你肯定会问这三者的的区别</p>\n<h3 id=\"Date-now-与-new-Date-getTime-的区别\"><a href=\"#Date-now-与-new-Date-getTime-的区别\" class=\"headerlink\" title=\"Date.now()与 new Date().getTime() 的区别\"></a>Date.now()与 new Date().getTime() 的区别</h3><p>它们都可以获取时间戳，但是实际上性能是不一样的（虽然差别不大，但是也算是一种性能的追求），可以做个测试</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'+new Date()'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">100000</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = + <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'+new Date()'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'new Date().getTime:'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> j = <span class=\"number\">0</span>; j &lt; <span class=\"number\">100000</span>; j++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> p = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'new Date().getTime:'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.time(<span class=\"string\">'Date.now()'</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k = <span class=\"number\">0</span>; k &lt; <span class=\"number\">100000</span>; k++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> q = <span class=\"built_in\">Date</span>.now()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.timeEnd(<span class=\"string\">'Date.now()'</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//输出</span></span><br><span class=\"line\">+<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(): <span class=\"number\">42.31396484375</span>ms</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getTime:: <span class=\"number\">33.93408203125</span>ms</span><br><span class=\"line\"><span class=\"built_in\">Date</span>.now(): <span class=\"number\">24.561767578125</span>ms</span><br></pre></td></tr></table></figure>\n\n<p>测试用例[<a href=\"https://jsperf.com/date-now-vs-new-date]\" target=\"_blank\" rel=\"noopener\">https://jsperf.com/date-now-vs-new-date]</a></p>\n<p><img src=\"https://tvax1.sinaimg.cn/large/b535b7d3ly1g7ua23h8toj20r20m6mxz.jpg\" alt=\"测试用例\"></p>\n<h2 id=\"profile\"><a href=\"#profile\" class=\"headerlink\" title=\"profile\"></a>profile</h2><p>使用<code>console.profile</code>测试程序性能</p>\n<p>开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">parent</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10000</span>; i++) &#123;</span><br><span class=\"line\">            childA()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">childA</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">2000</span>; i++) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.profile(<span class=\"string\">'性能分析'</span>);</span><br><span class=\"line\">parent();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.profileEnd(<span class=\"string\">'性能分析'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//执行后</span></span><br><span class=\"line\"><span class=\"comment\">//Profile '性能分析' started.</span></span><br><span class=\"line\"><span class=\"comment\">//Profile '性能分析' finished.</span></span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://tva3.sinaimg.cn/large/b535b7d3ly1g7ua23n1qvj210105uaad.jpg\" alt=\"console.profile\"></p>\n"},{"title":"如何在nuxt中使用Vuex做登陆管理","date":"2019-11-04T02:45:08.000Z","author":"胡豪","_content":"\n## 前言\n\n在vue中vuex可以拿来做状态管理，今天记录下在nuxt框架下如何使用vuex实现项目中的登陆状态的管理\n\n\n## Vuex\n用token进行验证登录,根据约定,把token放在header中  \n根目录下创建一个store文件夹，在store中创建一个index.js\n\n### 简述Vuex\nVuex是单项数据流，利用Vuex做状态管理，可以对数据更好地追踪与bug发现  \n- state 初始化状态  \n- gatter 对数据的过滤操作\n- mutations 进行业务逻辑操作，它是同步的\n- action 如果需要异步操作，可以写在action中\n\n\n### /store/index.js\n```js\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport axios from \"axios\";\n\nVue.use(Vuex);\n\nconst store = () =>\n  new Vuex.Store({\n    state: {\n      user: {\n        isLogin: false,\n        userInfo: \"\",\n        token: \"\",\n        ticket: \"\"\n      }\n    },\n    mutations: {\n      login(state, data) { \n        state.user.isLogin = true;\n        state.user.userInfo = data.userInfo;\n        state.user.userInfo.token = data.token;\n        axios.defaults.headers.common[\"Authorization\"] = data.token;      \n      },\n      loginout(state) {\n        state.user.isLogin = false;\n        state.user.userInfo = \"\";\n        axios.defaults.headers.common[\"Authorization\"] = \"undefined\";\n      },\n      // 设置用户 openId 对应的 key\n      setTicket(state, data) {\n        state.user.ticket = data;\n      }\n    },\n    actions: {\n      nuxtServerInit({ commit }, { req }) { \n        if (req.session) {\n          if (req.session.authUser) {\n            commit(\"login\", req.session.authUser);\n          } else if (req.session.ticket) {\n            commit(\"setTicket\", req.session.ticket);\n          }\n        }\n      }\n    }\n  });\nexport default store;\n```\n\n## middleware \n官方文档: [https://zh.nuxtjs.org/guide/routing#%E4%B8%AD%E9%97%B4%E4%BB%B6](https://zh.nuxtjs.org/guide/routing/#%E4%B8%AD%E9%97%B4%E4%BB%B6)  \n利用middleware实现不登录无法访问\n\n```js\nexport default async function ({ store,redirect }) {\n  //用户未登录就跳转登录页\n  if(!store.state.user.isLogin){\n    redirect('/login')\n  }\n}\n```\n在组件中使用`middleware: 'mustLogin', data() {return {}}`\n\n## 登陆组件login\n登陆页，接口验证成功后，更新store存储的状态 `this.$store.commit(\"login\", result.data);`\n\n完整代码如下：\n```js\nmethods: {\n  async submitForm(formName) {\n    const account = this.loginForm.account;\n    const password = this.loginForm.password;\n    this.$refs[formName].validate(async valid => {\n      if (valid) {\n        let result = await login(account, password);\n        if (result.success) {\n          // 登录成功\n          this.$store.commit(\"login\", result.data);\n          if (window.history.length > 1) {\n            this.$router.go(-1);\n          } else {\n            this.$router.push(\"/\");\n          }\n        } else {\n          MessageBox({\n            type: \"error\",\n            title: \"登录信息\",\n            message: result.message\n          });\n        }\n      } else {\n        return false;\n      }\n    });\n  }\n} \n```\n## 登出组件login\n点击退出按钮，接口发送退出请求，更新store存储的状态 `this.$store.commit(\"loginout\",null);`\n```html\n<span v-if=\"$store.state.user.isLogin\" @click=\"loginOut\">退出</span>\n```\n\n```js\nmethods: {\n  async loginOut() { \n    await loginOut();\n    this.$store.commit(\"loginout\",null);\n    this.$router.push(\"/\")\n  }\n}\n```\n\n## 总结\n至此,就是nuxt中使用Vuex的整个流程,具体不同的地方就需要在项目中针对性地去调整修改。","source":"_posts/如何在nuxt中使用Vuex做登陆管理.md","raw":"---\ntitle: 如何在nuxt中使用Vuex做登陆管理\ndate: 2019-11-4 10:45:08\nauthor: 胡豪\ncategories:\n  - JavaScript\n  - vue\ntags:\n  - SSR\n  - Nuxt\n---\n\n## 前言\n\n在vue中vuex可以拿来做状态管理，今天记录下在nuxt框架下如何使用vuex实现项目中的登陆状态的管理\n\n\n## Vuex\n用token进行验证登录,根据约定,把token放在header中  \n根目录下创建一个store文件夹，在store中创建一个index.js\n\n### 简述Vuex\nVuex是单项数据流，利用Vuex做状态管理，可以对数据更好地追踪与bug发现  \n- state 初始化状态  \n- gatter 对数据的过滤操作\n- mutations 进行业务逻辑操作，它是同步的\n- action 如果需要异步操作，可以写在action中\n\n\n### /store/index.js\n```js\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\nimport axios from \"axios\";\n\nVue.use(Vuex);\n\nconst store = () =>\n  new Vuex.Store({\n    state: {\n      user: {\n        isLogin: false,\n        userInfo: \"\",\n        token: \"\",\n        ticket: \"\"\n      }\n    },\n    mutations: {\n      login(state, data) { \n        state.user.isLogin = true;\n        state.user.userInfo = data.userInfo;\n        state.user.userInfo.token = data.token;\n        axios.defaults.headers.common[\"Authorization\"] = data.token;      \n      },\n      loginout(state) {\n        state.user.isLogin = false;\n        state.user.userInfo = \"\";\n        axios.defaults.headers.common[\"Authorization\"] = \"undefined\";\n      },\n      // 设置用户 openId 对应的 key\n      setTicket(state, data) {\n        state.user.ticket = data;\n      }\n    },\n    actions: {\n      nuxtServerInit({ commit }, { req }) { \n        if (req.session) {\n          if (req.session.authUser) {\n            commit(\"login\", req.session.authUser);\n          } else if (req.session.ticket) {\n            commit(\"setTicket\", req.session.ticket);\n          }\n        }\n      }\n    }\n  });\nexport default store;\n```\n\n## middleware \n官方文档: [https://zh.nuxtjs.org/guide/routing#%E4%B8%AD%E9%97%B4%E4%BB%B6](https://zh.nuxtjs.org/guide/routing/#%E4%B8%AD%E9%97%B4%E4%BB%B6)  \n利用middleware实现不登录无法访问\n\n```js\nexport default async function ({ store,redirect }) {\n  //用户未登录就跳转登录页\n  if(!store.state.user.isLogin){\n    redirect('/login')\n  }\n}\n```\n在组件中使用`middleware: 'mustLogin', data() {return {}}`\n\n## 登陆组件login\n登陆页，接口验证成功后，更新store存储的状态 `this.$store.commit(\"login\", result.data);`\n\n完整代码如下：\n```js\nmethods: {\n  async submitForm(formName) {\n    const account = this.loginForm.account;\n    const password = this.loginForm.password;\n    this.$refs[formName].validate(async valid => {\n      if (valid) {\n        let result = await login(account, password);\n        if (result.success) {\n          // 登录成功\n          this.$store.commit(\"login\", result.data);\n          if (window.history.length > 1) {\n            this.$router.go(-1);\n          } else {\n            this.$router.push(\"/\");\n          }\n        } else {\n          MessageBox({\n            type: \"error\",\n            title: \"登录信息\",\n            message: result.message\n          });\n        }\n      } else {\n        return false;\n      }\n    });\n  }\n} \n```\n## 登出组件login\n点击退出按钮，接口发送退出请求，更新store存储的状态 `this.$store.commit(\"loginout\",null);`\n```html\n<span v-if=\"$store.state.user.isLogin\" @click=\"loginOut\">退出</span>\n```\n\n```js\nmethods: {\n  async loginOut() { \n    await loginOut();\n    this.$store.commit(\"loginout\",null);\n    this.$router.push(\"/\")\n  }\n}\n```\n\n## 总结\n至此,就是nuxt中使用Vuex的整个流程,具体不同的地方就需要在项目中针对性地去调整修改。","slug":"如何在nuxt中使用Vuex做登陆管理","published":1,"updated":"2019-11-09T06:41:53.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufwf000q4sefn0mkl3ff","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在vue中vuex可以拿来做状态管理，今天记录下在nuxt框架下如何使用vuex实现项目中的登陆状态的管理</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>用token进行验证登录,根据约定,把token放在header中<br>根目录下创建一个store文件夹，在store中创建一个index.js</p>\n<h3 id=\"简述Vuex\"><a href=\"#简述Vuex\" class=\"headerlink\" title=\"简述Vuex\"></a>简述Vuex</h3><p>Vuex是单项数据流，利用Vuex做状态管理，可以对数据更好地追踪与bug发现  </p>\n<ul>\n<li>state 初始化状态  </li>\n<li>gatter 对数据的过滤操作</li>\n<li>mutations 进行业务逻辑操作，它是同步的</li>\n<li>action 如果需要异步操作，可以写在action中</li>\n</ul>\n<h3 id=\"store-index-js\"><a href=\"#store-index-js\" class=\"headerlink\" title=\"/store/index.js\"></a>/store/index.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">\"vue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">\"vuex\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">      user: &#123;</span><br><span class=\"line\">        isLogin: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        userInfo: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        token: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        ticket: <span class=\"string\">\"\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">      login(state, data) &#123; </span><br><span class=\"line\">        state.user.isLogin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        state.user.userInfo = data.userInfo;</span><br><span class=\"line\">        state.user.userInfo.token = data.token;</span><br><span class=\"line\">        axios.defaults.headers.common[<span class=\"string\">\"Authorization\"</span>] = data.token;      </span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      loginout(state) &#123;</span><br><span class=\"line\">        state.user.isLogin = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        state.user.userInfo = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        axios.defaults.headers.common[<span class=\"string\">\"Authorization\"</span>] = <span class=\"string\">\"undefined\"</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 设置用户 openId 对应的 key</span></span><br><span class=\"line\">      setTicket(state, data) &#123;</span><br><span class=\"line\">        state.user.ticket = data;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">      nuxtServerInit(&#123; commit &#125;, &#123; req &#125;) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.session) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (req.session.authUser) &#123;</span><br><span class=\"line\">            commit(<span class=\"string\">\"login\"</span>, req.session.authUser);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req.session.ticket) &#123;</span><br><span class=\"line\">            commit(<span class=\"string\">\"setTicket\"</span>, req.session.ticket);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"middleware\"><a href=\"#middleware\" class=\"headerlink\" title=\"middleware\"></a>middleware</h2><p>官方文档: <a href=\"https://zh.nuxtjs.org/guide/routing/#%E4%B8%AD%E9%97%B4%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/guide/routing#%E4%B8%AD%E9%97%B4%E4%BB%B6</a><br>利用middleware实现不登录无法访问</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">&#123; store,redirect &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//用户未登录就跳转登录页</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!store.state.user.isLogin)&#123;</span><br><span class=\"line\">    redirect(<span class=\"string\">'/login'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在组件中使用<code>middleware: &#39;mustLogin&#39;, data() {return {}}</code></p>\n<h2 id=\"登陆组件login\"><a href=\"#登陆组件login\" class=\"headerlink\" title=\"登陆组件login\"></a>登陆组件login</h2><p>登陆页，接口验证成功后，更新store存储的状态 <code>this.$store.commit(&quot;login&quot;, result.data);</code></p>\n<p>完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> submitForm(formName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> account = <span class=\"keyword\">this</span>.loginForm.account;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> password = <span class=\"keyword\">this</span>.loginForm.password;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$refs[formName].validate(<span class=\"keyword\">async</span> valid =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (valid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> login(account, password);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.success) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 登录成功</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.$store.commit(<span class=\"string\">\"login\"</span>, result.data);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.history.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.$router.go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.$router.push(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          MessageBox(&#123;</span><br><span class=\"line\">            type: <span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">            title: <span class=\"string\">\"登录信息\"</span>,</span><br><span class=\"line\">            message: result.message</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"登出组件login\"><a href=\"#登出组件login\" class=\"headerlink\" title=\"登出组件login\"></a>登出组件login</h2><p>点击退出按钮，接口发送退出请求，更新store存储的状态 <code>this.$store.commit(&quot;loginout&quot;,null);</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"$store.state.user.isLogin\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"loginOut\"</span>&gt;</span>退出<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> loginOut() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">await</span> loginOut();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store.commit(<span class=\"string\">\"loginout\"</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$router.push(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此,就是nuxt中使用Vuex的整个流程,具体不同的地方就需要在项目中针对性地去调整修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在vue中vuex可以拿来做状态管理，今天记录下在nuxt框架下如何使用vuex实现项目中的登陆状态的管理</p>\n<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><p>用token进行验证登录,根据约定,把token放在header中<br>根目录下创建一个store文件夹，在store中创建一个index.js</p>\n<h3 id=\"简述Vuex\"><a href=\"#简述Vuex\" class=\"headerlink\" title=\"简述Vuex\"></a>简述Vuex</h3><p>Vuex是单项数据流，利用Vuex做状态管理，可以对数据更好地追踪与bug发现  </p>\n<ul>\n<li>state 初始化状态  </li>\n<li>gatter 对数据的过滤操作</li>\n<li>mutations 进行业务逻辑操作，它是同步的</li>\n<li>action 如果需要异步操作，可以写在action中</li>\n</ul>\n<h3 id=\"store-index-js\"><a href=\"#store-index-js\" class=\"headerlink\" title=\"/store/index.js\"></a>/store/index.js</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">\"vue\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">\"vuex\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> axios <span class=\"keyword\">from</span> <span class=\"string\">\"axios\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span></span><br><span class=\"line\">  <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">    state: &#123;</span><br><span class=\"line\">      user: &#123;</span><br><span class=\"line\">        isLogin: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        userInfo: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        token: <span class=\"string\">\"\"</span>,</span><br><span class=\"line\">        ticket: <span class=\"string\">\"\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    mutations: &#123;</span><br><span class=\"line\">      login(state, data) &#123; </span><br><span class=\"line\">        state.user.isLogin = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        state.user.userInfo = data.userInfo;</span><br><span class=\"line\">        state.user.userInfo.token = data.token;</span><br><span class=\"line\">        axios.defaults.headers.common[<span class=\"string\">\"Authorization\"</span>] = data.token;      </span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      loginout(state) &#123;</span><br><span class=\"line\">        state.user.isLogin = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        state.user.userInfo = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">        axios.defaults.headers.common[<span class=\"string\">\"Authorization\"</span>] = <span class=\"string\">\"undefined\"</span>;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      <span class=\"comment\">// 设置用户 openId 对应的 key</span></span><br><span class=\"line\">      setTicket(state, data) &#123;</span><br><span class=\"line\">        state.user.ticket = data;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">      nuxtServerInit(&#123; commit &#125;, &#123; req &#125;) &#123; </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (req.session) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (req.session.authUser) &#123;</span><br><span class=\"line\">            commit(<span class=\"string\">\"login\"</span>, req.session.authUser);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (req.session.ticket) &#123;</span><br><span class=\"line\">            commit(<span class=\"string\">\"setTicket\"</span>, req.session.ticket);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> store;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"middleware\"><a href=\"#middleware\" class=\"headerlink\" title=\"middleware\"></a>middleware</h2><p>官方文档: <a href=\"https://zh.nuxtjs.org/guide/routing/#%E4%B8%AD%E9%97%B4%E4%BB%B6\" target=\"_blank\" rel=\"noopener\">https://zh.nuxtjs.org/guide/routing#%E4%B8%AD%E9%97%B4%E4%BB%B6</a><br>利用middleware实现不登录无法访问</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">&#123; store,redirect &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//用户未登录就跳转登录页</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!store.state.user.isLogin)&#123;</span><br><span class=\"line\">    redirect(<span class=\"string\">'/login'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在组件中使用<code>middleware: &#39;mustLogin&#39;, data() {return {}}</code></p>\n<h2 id=\"登陆组件login\"><a href=\"#登陆组件login\" class=\"headerlink\" title=\"登陆组件login\"></a>登陆组件login</h2><p>登陆页，接口验证成功后，更新store存储的状态 <code>this.$store.commit(&quot;login&quot;, result.data);</code></p>\n<p>完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> submitForm(formName) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> account = <span class=\"keyword\">this</span>.loginForm.account;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> password = <span class=\"keyword\">this</span>.loginForm.password;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$refs[formName].validate(<span class=\"keyword\">async</span> valid =&gt; &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (valid) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> result = <span class=\"keyword\">await</span> login(account, password);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.success) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 登录成功</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.$store.commit(<span class=\"string\">\"login\"</span>, result.data);</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.history.length &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.$router.go(<span class=\"number\">-1</span>);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.$router.push(<span class=\"string\">\"/\"</span>);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          MessageBox(&#123;</span><br><span class=\"line\">            type: <span class=\"string\">\"error\"</span>,</span><br><span class=\"line\">            title: <span class=\"string\">\"登录信息\"</span>,</span><br><span class=\"line\">            message: result.message</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"登出组件login\"><a href=\"#登出组件login\" class=\"headerlink\" title=\"登出组件login\"></a>登出组件login</h2><p>点击退出按钮，接口发送退出请求，更新store存储的状态 <code>this.$store.commit(&quot;loginout&quot;,null);</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">v-if</span>=<span class=\"string\">\"$store.state.user.isLogin\"</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"loginOut\"</span>&gt;</span>退出<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> loginOut() &#123; </span><br><span class=\"line\">    <span class=\"keyword\">await</span> loginOut();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$store.commit(<span class=\"string\">\"loginout\"</span>,<span class=\"literal\">null</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.$router.push(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>至此,就是nuxt中使用Vuex的整个流程,具体不同的地方就需要在项目中针对性地去调整修改。</p>\n"},{"title":"网页禁止审查及一些简单禁止用户对页面操作","date":"2019-11-05T03:02:26.000Z","author":"胡豪","_content":"\n## 前言\n\n对于一些网页，如原创文章，我们不希望用户对我们的网页文章内容拷贝粘贴，所以前端可以做一些操作去禁止，但这种操作也只是防君子不防小人，上有政策下有对策，还是有方法破解的。\n\n## 先说破解禁止 F12 方法\n\n遇到有些网页禁止 F12 审查，我们可以用空白网页先开调试模式，再在地址栏输入网址进入网页\n\n## 简单禁止 F12 审查\n\n此方法就是 js 监听 F12 键盘事件去做操作(不安全，存在绕过漏洞)\n\n```js\ndocument.onkeydown = function() {\n  if (window.event && window.event.keyCode == 123) {\n    alert(\"F12被禁用\");\n    event.keyCode = 0;\n    event.returnValue = false;\n  }\n  if (window.event && window.event.keyCode == 13) {\n    window.event.keyCode = 505;\n  }\n  if (window.event && window.event.keyCode == 8) {\n    alert(str + \"\\n请使用Del键进行字符的删除操作！\");\n    window.event.returnValue = false;\n  }\n};\n```\n\n## 屏蔽右键菜单\n\n```js\ndocument.oncontextmenu = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽粘贴\n\n```js\ndocument.onpaste = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽复制\n\n```js\ndocument.oncopy = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽剪切\n\n```js\ndocument.oncut = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽选中\n\n```js\ndocument.onselectstart = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 总结\n凡事无绝对，没法做到真正禁止。浏览器菜单里查看页面源代码，直接ctrl+s，爬虫  \n对于页面安全性研究不深，代码来源网上寻找，用时自取。","source":"_posts/网页禁止审查及一些简单禁止用户对页面操作.md","raw":"---\ntitle: 网页禁止审查及一些简单禁止用户对页面操作\ndate: 2019-11-05 11:02:26\nauthor: 胡豪\ncategories:\n  - JavaScript\ntags:\n  - js基础\n---\n\n## 前言\n\n对于一些网页，如原创文章，我们不希望用户对我们的网页文章内容拷贝粘贴，所以前端可以做一些操作去禁止，但这种操作也只是防君子不防小人，上有政策下有对策，还是有方法破解的。\n\n## 先说破解禁止 F12 方法\n\n遇到有些网页禁止 F12 审查，我们可以用空白网页先开调试模式，再在地址栏输入网址进入网页\n\n## 简单禁止 F12 审查\n\n此方法就是 js 监听 F12 键盘事件去做操作(不安全，存在绕过漏洞)\n\n```js\ndocument.onkeydown = function() {\n  if (window.event && window.event.keyCode == 123) {\n    alert(\"F12被禁用\");\n    event.keyCode = 0;\n    event.returnValue = false;\n  }\n  if (window.event && window.event.keyCode == 13) {\n    window.event.keyCode = 505;\n  }\n  if (window.event && window.event.keyCode == 8) {\n    alert(str + \"\\n请使用Del键进行字符的删除操作！\");\n    window.event.returnValue = false;\n  }\n};\n```\n\n## 屏蔽右键菜单\n\n```js\ndocument.oncontextmenu = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽粘贴\n\n```js\ndocument.onpaste = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽复制\n\n```js\ndocument.oncopy = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽剪切\n\n```js\ndocument.oncut = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 屏蔽选中\n\n```js\ndocument.onselectstart = function(event) {\n  if (window.event) {\n    event = window.event;\n  }\n  try {\n    var the = event.srcElement;\n    if (\n      !(\n        (the.tagName == \"INPUT\" && the.type.toLowerCase() == \"text\") ||\n        the.tagName == \"TEXTAREA\"\n      )\n    ) {\n      return false;\n    }\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n```\n\n## 总结\n凡事无绝对，没法做到真正禁止。浏览器菜单里查看页面源代码，直接ctrl+s，爬虫  \n对于页面安全性研究不深，代码来源网上寻找，用时自取。","slug":"网页禁止审查及一些简单禁止用户对页面操作","published":1,"updated":"2019-11-09T06:41:53.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufwi000u4sefwg7g7553","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于一些网页，如原创文章，我们不希望用户对我们的网页文章内容拷贝粘贴，所以前端可以做一些操作去禁止，但这种操作也只是防君子不防小人，上有政策下有对策，还是有方法破解的。</p>\n<h2 id=\"先说破解禁止-F12-方法\"><a href=\"#先说破解禁止-F12-方法\" class=\"headerlink\" title=\"先说破解禁止 F12 方法\"></a>先说破解禁止 F12 方法</h2><p>遇到有些网页禁止 F12 审查，我们可以用空白网页先开调试模式，再在地址栏输入网址进入网页</p>\n<h2 id=\"简单禁止-F12-审查\"><a href=\"#简单禁止-F12-审查\" class=\"headerlink\" title=\"简单禁止 F12 审查\"></a>简单禁止 F12 审查</h2><p>此方法就是 js 监听 F12 键盘事件去做操作(不安全，存在绕过漏洞)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.onkeydown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event &amp;&amp; <span class=\"built_in\">window</span>.event.keyCode == <span class=\"number\">123</span>) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"F12被禁用\"</span>);</span><br><span class=\"line\">    event.keyCode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    event.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event &amp;&amp; <span class=\"built_in\">window</span>.event.keyCode == <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.event.keyCode = <span class=\"number\">505</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event &amp;&amp; <span class=\"built_in\">window</span>.event.keyCode == <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">    alert(str + <span class=\"string\">\"\\n请使用Del键进行字符的删除操作！\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.event.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽右键菜单\"><a href=\"#屏蔽右键菜单\" class=\"headerlink\" title=\"屏蔽右键菜单\"></a>屏蔽右键菜单</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncontextmenu = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽粘贴\"><a href=\"#屏蔽粘贴\" class=\"headerlink\" title=\"屏蔽粘贴\"></a>屏蔽粘贴</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.onpaste = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽复制\"><a href=\"#屏蔽复制\" class=\"headerlink\" title=\"屏蔽复制\"></a>屏蔽复制</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncopy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽剪切\"><a href=\"#屏蔽剪切\" class=\"headerlink\" title=\"屏蔽剪切\"></a>屏蔽剪切</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncut = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽选中\"><a href=\"#屏蔽选中\" class=\"headerlink\" title=\"屏蔽选中\"></a>屏蔽选中</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.onselectstart = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>凡事无绝对，没法做到真正禁止。浏览器菜单里查看页面源代码，直接ctrl+s，爬虫<br>对于页面安全性研究不深，代码来源网上寻找，用时自取。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于一些网页，如原创文章，我们不希望用户对我们的网页文章内容拷贝粘贴，所以前端可以做一些操作去禁止，但这种操作也只是防君子不防小人，上有政策下有对策，还是有方法破解的。</p>\n<h2 id=\"先说破解禁止-F12-方法\"><a href=\"#先说破解禁止-F12-方法\" class=\"headerlink\" title=\"先说破解禁止 F12 方法\"></a>先说破解禁止 F12 方法</h2><p>遇到有些网页禁止 F12 审查，我们可以用空白网页先开调试模式，再在地址栏输入网址进入网页</p>\n<h2 id=\"简单禁止-F12-审查\"><a href=\"#简单禁止-F12-审查\" class=\"headerlink\" title=\"简单禁止 F12 审查\"></a>简单禁止 F12 审查</h2><p>此方法就是 js 监听 F12 键盘事件去做操作(不安全，存在绕过漏洞)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.onkeydown = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event &amp;&amp; <span class=\"built_in\">window</span>.event.keyCode == <span class=\"number\">123</span>) &#123;</span><br><span class=\"line\">    alert(<span class=\"string\">\"F12被禁用\"</span>);</span><br><span class=\"line\">    event.keyCode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    event.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event &amp;&amp; <span class=\"built_in\">window</span>.event.keyCode == <span class=\"number\">13</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.event.keyCode = <span class=\"number\">505</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event &amp;&amp; <span class=\"built_in\">window</span>.event.keyCode == <span class=\"number\">8</span>) &#123;</span><br><span class=\"line\">    alert(str + <span class=\"string\">\"\\n请使用Del键进行字符的删除操作！\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.event.returnValue = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽右键菜单\"><a href=\"#屏蔽右键菜单\" class=\"headerlink\" title=\"屏蔽右键菜单\"></a>屏蔽右键菜单</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncontextmenu = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽粘贴\"><a href=\"#屏蔽粘贴\" class=\"headerlink\" title=\"屏蔽粘贴\"></a>屏蔽粘贴</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.onpaste = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽复制\"><a href=\"#屏蔽复制\" class=\"headerlink\" title=\"屏蔽复制\"></a>屏蔽复制</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncopy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽剪切\"><a href=\"#屏蔽剪切\" class=\"headerlink\" title=\"屏蔽剪切\"></a>屏蔽剪切</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.oncut = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"屏蔽选中\"><a href=\"#屏蔽选中\" class=\"headerlink\" title=\"屏蔽选中\"></a>屏蔽选中</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">document</span>.onselectstart = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">window</span>.event) &#123;</span><br><span class=\"line\">    event = <span class=\"built_in\">window</span>.event;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> the = event.srcElement;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (</span><br><span class=\"line\">      !(</span><br><span class=\"line\">        (the.tagName == <span class=\"string\">\"INPUT\"</span> &amp;&amp; the.type.toLowerCase() == <span class=\"string\">\"text\"</span>) ||</span><br><span class=\"line\">        the.tagName == <span class=\"string\">\"TEXTAREA\"</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    ) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>凡事无绝对，没法做到真正禁止。浏览器菜单里查看页面源代码，直接ctrl+s，爬虫<br>对于页面安全性研究不深，代码来源网上寻找，用时自取。</p>\n"},{"title":"谈谈前端路由","date":"2019-09-19T08:57:02.000Z","author":"霜寒","_content":"\n\n## 单页面应用与前端路由\n\n在传统的 Web 开发中，浏览器根据地址栏的 URL 向服务器发送一个 HTTP 请求，服务器根据 URL 返回一个 HTML 页面。这种情况下，一个 URL 对应一个 HTML 页面，\n一个 Web 应用包含很多 HTML 页面，这样的应用就是多页面应用；在多页面应用中，**页面路由的控制由服务器负责**，这种路由方式称为后端路由。\n\n在多页面应用中，每次页面切换都需要向服务器发送一次请求，页面使用的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面\n间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致公共部分的刷新。\n\n有没有一种方式让 Web 应用只是看起来像多页面应用，也就是说 URL 的变化可以引起页面内容的变化，但不会向服务器发送新的请求哪？满足这种条件的 Web 应用就是单页面\n应用（Single Page Application，简称 SPA）。单页面应用虽然名为”单页“，但视觉上的感受仍然是多页面，因为 URL 发生变化，页面上的内容也会变化，但这只是逻辑上的多页面，实际上无论 URL 如何变化，对应的 HTML 文件都是同一个，这也是单页面应用名字的由来。在单页面应用中，**URL 发生变化并不会向服务器发送新的请求**，所以”逻辑页面“的变化只能由前端负责，这种方式称为前端路由。\n\n## 前端路由的实现\n\n**路由就是 URL 到函数的映射**，这个是前端路由的原理。如果做到在 URL 发生变化的时候不向服务器发送请求，而是去执行一个控制 UI 组件的函数哪？那就不得不说说 hash 和 history 这两种实现方案了。\n\n### 基于 hash\n\n在一个 URL 的组成中，`#`号包括`#`号后边的部分称为 hash。在浏览器中，可以通过`location.hash`获取到。`#`代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如：\n\n```\n// #title 是 hash\nhttp://www.example.com/index.html#title\n```\n\n`#`号是用来指导浏览器动作的，对服务器完全不起作用，HTTP 请求不会带上`#`号以及它后边的内容。单单改变`#`号后边的内容，浏览器只会滚动到指定的位置，不会重新加载网页。而且改变 hash 还会改变浏览器的历史记录。我们可以通过`onhashchange`监听到 hash 的改变来不刷新浏览器触发视图的更新。代码如下：\n\n```html\n<ul>\n  <li><a href=\"#\">white</a></li>\n  <li><a href=\"#yellow\">yellow</a></li>\n  <li><a href=\"#green\">green</a></li>\n</ul>\n这是页面的内容\n```\n\n```javascript\nfunction Router() {\n  this.routes = {};\n  this.currentUrl = \"\";\n}\n\nRouter.prototype.route = function(path, callback) {\n  this.routes[path] =\n    callback ||\n    function() {\n      console.log(\"请为路由绑定处理方法\");\n    };\n};\n\nRouter.prototype.refresh = function() {\n  console.log(\"触发一次 hashchange，hash值为\", location.hash);\n  this.currentUrl = \"/\" + location.hash.slice(1);\n  // 执行当前路由绑定的方法\n  this.routes[this.currentUrl]();\n};\n\nRouter.prototype.init = function() {\n  window.addEventListener(\"DOMContentLoaded\", this.refresh.bind(this), false);\n  window.addEventListener(\"hashchange\", this.refresh.bind(this), false);\n};\n\nwindow.Router = new Router();\nwindow.Router.init();\n\nvar content = document.querySelector(\"body\");\nfunction changeBgColor(color) {\n  content.style.backgroundColor = color;\n}\n\nRouter.route(\"/\", function() {\n  changeBgColor(\"white\");\n});\nRouter.route(\"/yellow\", function() {\n  changeBgColor(\"yellow\");\n});\nRouter.route(\"/green\", function() {\n  changeBgColor(\"green\");\n});\n```\n\n### 基于 history 模式\n\n在 HTML5 规范中，history新增了一下几个 API：\n```javascript\nhistory.pushState();    // 添加新的状态到历史状态栈\nhistory.replaceState(); // 用新的状态代替当前状态\nhistory.state           // 返回当前状态对象\n```\n通过上面两个操作状态的 API，也能够做到：**改变 url 的同时，不刷新页面**。所以 history 也具备实现路由控制的潜力。仅仅是改变 url 不刷新页面还不够，还要能够监听到 url 的变化。对于 hash 来说，hash 的改变可以出发 onhashchange 事件，history 并没有这样的事件可以监听。然而，对于一个应用来说，改变一个 url 只有下面三种途径：\n\n+ 点击浏览器的前进或者后退\n+ 点击 a 标签\n+ 在 JS 代码中直接修改路由\n\n第 2 种和第 3 种途径可以看成是一种，因为 a 标签的默认事件可以被禁止，进而调用 js 方法。关键是第 1 种，HTML5 规范种新增了一个 onpopstate 事件，通过它便可以监听到前进或者后退的按钮点击。要特别注意的是：**调用`history.pushState`和`history.replaceState`并不会触发 onpopstate 事件**。\n```javascript\n// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件\nwindow.addEventListener('DOMContentLoaded', onLoad)\n// 监听路由变化\nwindow.addEventListener('popstate', onPopState)\n\n// 路由视图\nvar routerView = null\n\nfunction onLoad () {\n  routerView = document.querySelector('#routeView')\n  onPopState()\n\n  // 拦截 <a> 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。\n  var linkList = document.querySelectorAll('a[href]')\n  linkList.forEach(el => el.addEventListener('click', function (e) {\n    e.preventDefault()\n    history.pushState(null, '', el.getAttribute('href'))\n    onPopState()\n  }))\n}\n\n// 路由变化时，根据路由渲染对应 UI\nfunction onPopState () {\n  switch (location.pathname) {\n    case '/home':\n      routerView.innerHTML = 'Home'\n      return\n    case '/about':\n      routerView.innerHTML = 'About'\n      return\n    default:\n      return\n  }\n}\n```\n\n### hash vs history\n\nhash 模式下，每个 url 都会带有`#`号，看起来可能不太友好。但是，hash 模式兼容 IE8 及其以上的浏览器。history 模式使用了 HTML5 里边新的 API，看起来会比较友好。但是，仅仅有前端的参与还是不够的，需要后端进行配置，前端的路由要和后端的路由要匹配起来，在刷新浏览器的时候会给后端发送请求，这个时候后台需要对请求的 url，做一个捕捉，将后端不存在的 url，重定向到指定路由。\n\n## 参考内容\n\n- [URL 中的 hash](https://www.cnblogs.com/m2maomao/p/10611983.html)\n- [React 进阶之路](https://book.douban.com/subject/30210697/)\n- [单页面应用路由实现原理](https://github.com/youngwind/blog/issues/109)\n- [hash 和 history 两种模式的区别](https://www.jianshu.com/p/3fcae6a4968f?open_source=weibo_search)\n- [前端路由原理解析和实现](https://github.com/whinc/blog/issues/13)\n","source":"_posts/谈谈前端路由.md","raw":"---\ntitle: 谈谈前端路由\ntags: 前端路由\ncategory: JavaScript\ndate: 2019-09-19 16:57:02\nauthor: 霜寒\n---\n\n\n## 单页面应用与前端路由\n\n在传统的 Web 开发中，浏览器根据地址栏的 URL 向服务器发送一个 HTTP 请求，服务器根据 URL 返回一个 HTML 页面。这种情况下，一个 URL 对应一个 HTML 页面，\n一个 Web 应用包含很多 HTML 页面，这样的应用就是多页面应用；在多页面应用中，**页面路由的控制由服务器负责**，这种路由方式称为后端路由。\n\n在多页面应用中，每次页面切换都需要向服务器发送一次请求，页面使用的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面\n间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致公共部分的刷新。\n\n有没有一种方式让 Web 应用只是看起来像多页面应用，也就是说 URL 的变化可以引起页面内容的变化，但不会向服务器发送新的请求哪？满足这种条件的 Web 应用就是单页面\n应用（Single Page Application，简称 SPA）。单页面应用虽然名为”单页“，但视觉上的感受仍然是多页面，因为 URL 发生变化，页面上的内容也会变化，但这只是逻辑上的多页面，实际上无论 URL 如何变化，对应的 HTML 文件都是同一个，这也是单页面应用名字的由来。在单页面应用中，**URL 发生变化并不会向服务器发送新的请求**，所以”逻辑页面“的变化只能由前端负责，这种方式称为前端路由。\n\n## 前端路由的实现\n\n**路由就是 URL 到函数的映射**，这个是前端路由的原理。如果做到在 URL 发生变化的时候不向服务器发送请求，而是去执行一个控制 UI 组件的函数哪？那就不得不说说 hash 和 history 这两种实现方案了。\n\n### 基于 hash\n\n在一个 URL 的组成中，`#`号包括`#`号后边的部分称为 hash。在浏览器中，可以通过`location.hash`获取到。`#`代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如：\n\n```\n// #title 是 hash\nhttp://www.example.com/index.html#title\n```\n\n`#`号是用来指导浏览器动作的，对服务器完全不起作用，HTTP 请求不会带上`#`号以及它后边的内容。单单改变`#`号后边的内容，浏览器只会滚动到指定的位置，不会重新加载网页。而且改变 hash 还会改变浏览器的历史记录。我们可以通过`onhashchange`监听到 hash 的改变来不刷新浏览器触发视图的更新。代码如下：\n\n```html\n<ul>\n  <li><a href=\"#\">white</a></li>\n  <li><a href=\"#yellow\">yellow</a></li>\n  <li><a href=\"#green\">green</a></li>\n</ul>\n这是页面的内容\n```\n\n```javascript\nfunction Router() {\n  this.routes = {};\n  this.currentUrl = \"\";\n}\n\nRouter.prototype.route = function(path, callback) {\n  this.routes[path] =\n    callback ||\n    function() {\n      console.log(\"请为路由绑定处理方法\");\n    };\n};\n\nRouter.prototype.refresh = function() {\n  console.log(\"触发一次 hashchange，hash值为\", location.hash);\n  this.currentUrl = \"/\" + location.hash.slice(1);\n  // 执行当前路由绑定的方法\n  this.routes[this.currentUrl]();\n};\n\nRouter.prototype.init = function() {\n  window.addEventListener(\"DOMContentLoaded\", this.refresh.bind(this), false);\n  window.addEventListener(\"hashchange\", this.refresh.bind(this), false);\n};\n\nwindow.Router = new Router();\nwindow.Router.init();\n\nvar content = document.querySelector(\"body\");\nfunction changeBgColor(color) {\n  content.style.backgroundColor = color;\n}\n\nRouter.route(\"/\", function() {\n  changeBgColor(\"white\");\n});\nRouter.route(\"/yellow\", function() {\n  changeBgColor(\"yellow\");\n});\nRouter.route(\"/green\", function() {\n  changeBgColor(\"green\");\n});\n```\n\n### 基于 history 模式\n\n在 HTML5 规范中，history新增了一下几个 API：\n```javascript\nhistory.pushState();    // 添加新的状态到历史状态栈\nhistory.replaceState(); // 用新的状态代替当前状态\nhistory.state           // 返回当前状态对象\n```\n通过上面两个操作状态的 API，也能够做到：**改变 url 的同时，不刷新页面**。所以 history 也具备实现路由控制的潜力。仅仅是改变 url 不刷新页面还不够，还要能够监听到 url 的变化。对于 hash 来说，hash 的改变可以出发 onhashchange 事件，history 并没有这样的事件可以监听。然而，对于一个应用来说，改变一个 url 只有下面三种途径：\n\n+ 点击浏览器的前进或者后退\n+ 点击 a 标签\n+ 在 JS 代码中直接修改路由\n\n第 2 种和第 3 种途径可以看成是一种，因为 a 标签的默认事件可以被禁止，进而调用 js 方法。关键是第 1 种，HTML5 规范种新增了一个 onpopstate 事件，通过它便可以监听到前进或者后退的按钮点击。要特别注意的是：**调用`history.pushState`和`history.replaceState`并不会触发 onpopstate 事件**。\n```javascript\n// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件\nwindow.addEventListener('DOMContentLoaded', onLoad)\n// 监听路由变化\nwindow.addEventListener('popstate', onPopState)\n\n// 路由视图\nvar routerView = null\n\nfunction onLoad () {\n  routerView = document.querySelector('#routeView')\n  onPopState()\n\n  // 拦截 <a> 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。\n  var linkList = document.querySelectorAll('a[href]')\n  linkList.forEach(el => el.addEventListener('click', function (e) {\n    e.preventDefault()\n    history.pushState(null, '', el.getAttribute('href'))\n    onPopState()\n  }))\n}\n\n// 路由变化时，根据路由渲染对应 UI\nfunction onPopState () {\n  switch (location.pathname) {\n    case '/home':\n      routerView.innerHTML = 'Home'\n      return\n    case '/about':\n      routerView.innerHTML = 'About'\n      return\n    default:\n      return\n  }\n}\n```\n\n### hash vs history\n\nhash 模式下，每个 url 都会带有`#`号，看起来可能不太友好。但是，hash 模式兼容 IE8 及其以上的浏览器。history 模式使用了 HTML5 里边新的 API，看起来会比较友好。但是，仅仅有前端的参与还是不够的，需要后端进行配置，前端的路由要和后端的路由要匹配起来，在刷新浏览器的时候会给后端发送请求，这个时候后台需要对请求的 url，做一个捕捉，将后端不存在的 url，重定向到指定路由。\n\n## 参考内容\n\n- [URL 中的 hash](https://www.cnblogs.com/m2maomao/p/10611983.html)\n- [React 进阶之路](https://book.douban.com/subject/30210697/)\n- [单页面应用路由实现原理](https://github.com/youngwind/blog/issues/109)\n- [hash 和 history 两种模式的区别](https://www.jianshu.com/p/3fcae6a4968f?open_source=weibo_search)\n- [前端路由原理解析和实现](https://github.com/whinc/blog/issues/13)\n","slug":"谈谈前端路由","published":1,"updated":"2019-09-24T06:10:49.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufwj000w4sefvfg0x01z","content":"<h2 id=\"单页面应用与前端路由\"><a href=\"#单页面应用与前端路由\" class=\"headerlink\" title=\"单页面应用与前端路由\"></a>单页面应用与前端路由</h2><p>在传统的 Web 开发中，浏览器根据地址栏的 URL 向服务器发送一个 HTTP 请求，服务器根据 URL 返回一个 HTML 页面。这种情况下，一个 URL 对应一个 HTML 页面，<br>一个 Web 应用包含很多 HTML 页面，这样的应用就是多页面应用；在多页面应用中，<strong>页面路由的控制由服务器负责</strong>，这种路由方式称为后端路由。</p>\n<p>在多页面应用中，每次页面切换都需要向服务器发送一次请求，页面使用的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面<br>间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致公共部分的刷新。</p>\n<p>有没有一种方式让 Web 应用只是看起来像多页面应用，也就是说 URL 的变化可以引起页面内容的变化，但不会向服务器发送新的请求哪？满足这种条件的 Web 应用就是单页面<br>应用（Single Page Application，简称 SPA）。单页面应用虽然名为”单页“，但视觉上的感受仍然是多页面，因为 URL 发生变化，页面上的内容也会变化，但这只是逻辑上的多页面，实际上无论 URL 如何变化，对应的 HTML 文件都是同一个，这也是单页面应用名字的由来。在单页面应用中，<strong>URL 发生变化并不会向服务器发送新的请求</strong>，所以”逻辑页面“的变化只能由前端负责，这种方式称为前端路由。</p>\n<h2 id=\"前端路由的实现\"><a href=\"#前端路由的实现\" class=\"headerlink\" title=\"前端路由的实现\"></a>前端路由的实现</h2><p><strong>路由就是 URL 到函数的映射</strong>，这个是前端路由的原理。如果做到在 URL 发生变化的时候不向服务器发送请求，而是去执行一个控制 UI 组件的函数哪？那就不得不说说 hash 和 history 这两种实现方案了。</p>\n<h3 id=\"基于-hash\"><a href=\"#基于-hash\" class=\"headerlink\" title=\"基于 hash\"></a>基于 hash</h3><p>在一个 URL 的组成中，<code>#</code>号包括<code>#</code>号后边的部分称为 hash。在浏览器中，可以通过<code>location.hash</code>获取到。<code>#</code>代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// #title 是 hash</span><br><span class=\"line\">http://www.example.com/index.html#title</span><br></pre></td></tr></table></figure>\n\n<p><code>#</code>号是用来指导浏览器动作的，对服务器完全不起作用，HTTP 请求不会带上<code>#</code>号以及它后边的内容。单单改变<code>#</code>号后边的内容，浏览器只会滚动到指定的位置，不会重新加载网页。而且改变 hash 还会改变浏览器的历史记录。我们可以通过<code>onhashchange</code>监听到 hash 的改变来不刷新浏览器触发视图的更新。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>white<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#yellow\"</span>&gt;</span>yellow<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#green\"</span>&gt;</span>green<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">这是页面的内容</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Router</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.prototype.route = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routes[path] =</span><br><span class=\"line\">    callback ||</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"请为路由绑定处理方法\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.prototype.refresh = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"触发一次 hashchange，hash值为\"</span>, location.hash);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">\"/\"</span> + location.hash.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 执行当前路由绑定的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"DOMContentLoaded\"</span>, <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"hashchange\"</span>, <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.Router = <span class=\"keyword\">new</span> Router();</span><br><span class=\"line\"><span class=\"built_in\">window</span>.Router.init();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"body\"</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeBgColor</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  content.style.backgroundColor = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.route(<span class=\"string\">\"/\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  changeBgColor(<span class=\"string\">\"white\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Router.route(<span class=\"string\">\"/yellow\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  changeBgColor(<span class=\"string\">\"yellow\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Router.route(<span class=\"string\">\"/green\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  changeBgColor(<span class=\"string\">\"green\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基于-history-模式\"><a href=\"#基于-history-模式\" class=\"headerlink\" title=\"基于 history 模式\"></a>基于 history 模式</h3><p>在 HTML5 规范中，history新增了一下几个 API：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.pushState();    <span class=\"comment\">// 添加新的状态到历史状态栈</span></span><br><span class=\"line\">history.replaceState(); <span class=\"comment\">// 用新的状态代替当前状态</span></span><br><span class=\"line\">history.state           <span class=\"comment\">// 返回当前状态对象</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面两个操作状态的 API，也能够做到：<strong>改变 url 的同时，不刷新页面</strong>。所以 history 也具备实现路由控制的潜力。仅仅是改变 url 不刷新页面还不够，还要能够监听到 url 的变化。对于 hash 来说，hash 的改变可以出发 onhashchange 事件，history 并没有这样的事件可以监听。然而，对于一个应用来说，改变一个 url 只有下面三种途径：</p>\n<ul>\n<li>点击浏览器的前进或者后退</li>\n<li>点击 a 标签</li>\n<li>在 JS 代码中直接修改路由</li>\n</ul>\n<p>第 2 种和第 3 种途径可以看成是一种，因为 a 标签的默认事件可以被禁止，进而调用 js 方法。关键是第 1 种，HTML5 规范种新增了一个 onpopstate 事件，通过它便可以监听到前进或者后退的按钮点击。要特别注意的是：<strong>调用<code>history.pushState</code>和<code>history.replaceState</code>并不会触发 onpopstate 事件</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, onLoad)</span><br><span class=\"line\"><span class=\"comment\">// 监听路由变化</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, onPopState)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路由视图</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> routerView = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  routerView = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#routeView'</span>)</span><br><span class=\"line\">  onPopState()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> linkList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'a[href]'</span>)</span><br><span class=\"line\">  linkList.forEach(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault()</span><br><span class=\"line\">    history.pushState(<span class=\"literal\">null</span>, <span class=\"string\">''</span>, el.getAttribute(<span class=\"string\">'href'</span>))</span><br><span class=\"line\">    onPopState()</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路由变化时，根据路由渲染对应 UI</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onPopState</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (location.pathname) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'/home'</span>:</span><br><span class=\"line\">      routerView.innerHTML = <span class=\"string\">'Home'</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'/about'</span>:</span><br><span class=\"line\">      routerView.innerHTML = <span class=\"string\">'About'</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hash-vs-history\"><a href=\"#hash-vs-history\" class=\"headerlink\" title=\"hash vs history\"></a>hash vs history</h3><p>hash 模式下，每个 url 都会带有<code>#</code>号，看起来可能不太友好。但是，hash 模式兼容 IE8 及其以上的浏览器。history 模式使用了 HTML5 里边新的 API，看起来会比较友好。但是，仅仅有前端的参与还是不够的，需要后端进行配置，前端的路由要和后端的路由要匹配起来，在刷新浏览器的时候会给后端发送请求，这个时候后台需要对请求的 url，做一个捕捉，将后端不存在的 url，重定向到指定路由。</p>\n<h2 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h2><ul>\n<li><a href=\"https://www.cnblogs.com/m2maomao/p/10611983.html\" target=\"_blank\" rel=\"noopener\">URL 中的 hash</a></li>\n<li><a href=\"https://book.douban.com/subject/30210697/\" target=\"_blank\" rel=\"noopener\">React 进阶之路</a></li>\n<li><a href=\"https://github.com/youngwind/blog/issues/109\" target=\"_blank\" rel=\"noopener\">单页面应用路由实现原理</a></li>\n<li><a href=\"https://www.jianshu.com/p/3fcae6a4968f?open_source=weibo_search\" target=\"_blank\" rel=\"noopener\">hash 和 history 两种模式的区别</a></li>\n<li><a href=\"https://github.com/whinc/blog/issues/13\" target=\"_blank\" rel=\"noopener\">前端路由原理解析和实现</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"单页面应用与前端路由\"><a href=\"#单页面应用与前端路由\" class=\"headerlink\" title=\"单页面应用与前端路由\"></a>单页面应用与前端路由</h2><p>在传统的 Web 开发中，浏览器根据地址栏的 URL 向服务器发送一个 HTTP 请求，服务器根据 URL 返回一个 HTML 页面。这种情况下，一个 URL 对应一个 HTML 页面，<br>一个 Web 应用包含很多 HTML 页面，这样的应用就是多页面应用；在多页面应用中，<strong>页面路由的控制由服务器负责</strong>，这种路由方式称为后端路由。</p>\n<p>在多页面应用中，每次页面切换都需要向服务器发送一次请求，页面使用的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面<br>间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致公共部分的刷新。</p>\n<p>有没有一种方式让 Web 应用只是看起来像多页面应用，也就是说 URL 的变化可以引起页面内容的变化，但不会向服务器发送新的请求哪？满足这种条件的 Web 应用就是单页面<br>应用（Single Page Application，简称 SPA）。单页面应用虽然名为”单页“，但视觉上的感受仍然是多页面，因为 URL 发生变化，页面上的内容也会变化，但这只是逻辑上的多页面，实际上无论 URL 如何变化，对应的 HTML 文件都是同一个，这也是单页面应用名字的由来。在单页面应用中，<strong>URL 发生变化并不会向服务器发送新的请求</strong>，所以”逻辑页面“的变化只能由前端负责，这种方式称为前端路由。</p>\n<h2 id=\"前端路由的实现\"><a href=\"#前端路由的实现\" class=\"headerlink\" title=\"前端路由的实现\"></a>前端路由的实现</h2><p><strong>路由就是 URL 到函数的映射</strong>，这个是前端路由的原理。如果做到在 URL 发生变化的时候不向服务器发送请求，而是去执行一个控制 UI 组件的函数哪？那就不得不说说 hash 和 history 这两种实现方案了。</p>\n<h3 id=\"基于-hash\"><a href=\"#基于-hash\" class=\"headerlink\" title=\"基于 hash\"></a>基于 hash</h3><p>在一个 URL 的组成中，<code>#</code>号包括<code>#</code>号后边的部分称为 hash。在浏览器中，可以通过<code>location.hash</code>获取到。<code>#</code>代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// #title 是 hash</span><br><span class=\"line\">http://www.example.com/index.html#title</span><br></pre></td></tr></table></figure>\n\n<p><code>#</code>号是用来指导浏览器动作的，对服务器完全不起作用，HTTP 请求不会带上<code>#</code>号以及它后边的内容。单单改变<code>#</code>号后边的内容，浏览器只会滚动到指定的位置，不会重新加载网页。而且改变 hash 还会改变浏览器的历史记录。我们可以通过<code>onhashchange</code>监听到 hash 的改变来不刷新浏览器触发视图的更新。代码如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#\"</span>&gt;</span>white<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#yellow\"</span>&gt;</span>yellow<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#green\"</span>&gt;</span>green<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">这是页面的内容</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Router</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.prototype.route = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routes[path] =</span><br><span class=\"line\">    callback ||</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"请为路由绑定处理方法\"</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.prototype.refresh = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"触发一次 hashchange，hash值为\"</span>, location.hash);</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">\"/\"</span> + location.hash.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"comment\">// 执行当前路由绑定的方法</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"DOMContentLoaded\"</span>, <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"hashchange\"</span>, <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">window</span>.Router = <span class=\"keyword\">new</span> Router();</span><br><span class=\"line\"><span class=\"built_in\">window</span>.Router.init();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> content = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">\"body\"</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">changeBgColor</span>(<span class=\"params\">color</span>) </span>&#123;</span><br><span class=\"line\">  content.style.backgroundColor = color;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Router.route(<span class=\"string\">\"/\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  changeBgColor(<span class=\"string\">\"white\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Router.route(<span class=\"string\">\"/yellow\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  changeBgColor(<span class=\"string\">\"yellow\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Router.route(<span class=\"string\">\"/green\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  changeBgColor(<span class=\"string\">\"green\"</span>);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基于-history-模式\"><a href=\"#基于-history-模式\" class=\"headerlink\" title=\"基于 history 模式\"></a>基于 history 模式</h3><p>在 HTML5 规范中，history新增了一下几个 API：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history.pushState();    <span class=\"comment\">// 添加新的状态到历史状态栈</span></span><br><span class=\"line\">history.replaceState(); <span class=\"comment\">// 用新的状态代替当前状态</span></span><br><span class=\"line\">history.state           <span class=\"comment\">// 返回当前状态对象</span></span><br></pre></td></tr></table></figure>\n\n<p>通过上面两个操作状态的 API，也能够做到：<strong>改变 url 的同时，不刷新页面</strong>。所以 history 也具备实现路由控制的潜力。仅仅是改变 url 不刷新页面还不够，还要能够监听到 url 的变化。对于 hash 来说，hash 的改变可以出发 onhashchange 事件，history 并没有这样的事件可以监听。然而，对于一个应用来说，改变一个 url 只有下面三种途径：</p>\n<ul>\n<li>点击浏览器的前进或者后退</li>\n<li>点击 a 标签</li>\n<li>在 JS 代码中直接修改路由</li>\n</ul>\n<p>第 2 种和第 3 种途径可以看成是一种，因为 a 标签的默认事件可以被禁止，进而调用 js 方法。关键是第 1 种，HTML5 规范种新增了一个 onpopstate 事件，通过它便可以监听到前进或者后退的按钮点击。要特别注意的是：<strong>调用<code>history.pushState</code>和<code>history.replaceState</code>并不会触发 onpopstate 事件</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, onLoad)</span><br><span class=\"line\"><span class=\"comment\">// 监听路由变化</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, onPopState)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路由视图</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> routerView = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onLoad</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  routerView = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#routeView'</span>)</span><br><span class=\"line\">  onPopState()</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> linkList = <span class=\"built_in\">document</span>.querySelectorAll(<span class=\"string\">'a[href]'</span>)</span><br><span class=\"line\">  linkList.forEach(<span class=\"function\"><span class=\"params\">el</span> =&gt;</span> el.addEventListener(<span class=\"string\">'click'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    e.preventDefault()</span><br><span class=\"line\">    history.pushState(<span class=\"literal\">null</span>, <span class=\"string\">''</span>, el.getAttribute(<span class=\"string\">'href'</span>))</span><br><span class=\"line\">    onPopState()</span><br><span class=\"line\">  &#125;))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 路由变化时，根据路由渲染对应 UI</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">onPopState</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (location.pathname) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'/home'</span>:</span><br><span class=\"line\">      routerView.innerHTML = <span class=\"string\">'Home'</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'/about'</span>:</span><br><span class=\"line\">      routerView.innerHTML = <span class=\"string\">'About'</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"hash-vs-history\"><a href=\"#hash-vs-history\" class=\"headerlink\" title=\"hash vs history\"></a>hash vs history</h3><p>hash 模式下，每个 url 都会带有<code>#</code>号，看起来可能不太友好。但是，hash 模式兼容 IE8 及其以上的浏览器。history 模式使用了 HTML5 里边新的 API，看起来会比较友好。但是，仅仅有前端的参与还是不够的，需要后端进行配置，前端的路由要和后端的路由要匹配起来，在刷新浏览器的时候会给后端发送请求，这个时候后台需要对请求的 url，做一个捕捉，将后端不存在的 url，重定向到指定路由。</p>\n<h2 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h2><ul>\n<li><a href=\"https://www.cnblogs.com/m2maomao/p/10611983.html\" target=\"_blank\" rel=\"noopener\">URL 中的 hash</a></li>\n<li><a href=\"https://book.douban.com/subject/30210697/\" target=\"_blank\" rel=\"noopener\">React 进阶之路</a></li>\n<li><a href=\"https://github.com/youngwind/blog/issues/109\" target=\"_blank\" rel=\"noopener\">单页面应用路由实现原理</a></li>\n<li><a href=\"https://www.jianshu.com/p/3fcae6a4968f?open_source=weibo_search\" target=\"_blank\" rel=\"noopener\">hash 和 history 两种模式的区别</a></li>\n<li><a href=\"https://github.com/whinc/blog/issues/13\" target=\"_blank\" rel=\"noopener\">前端路由原理解析和实现</a></li>\n</ul>\n"},{"title":"闭包的概念与应用","date":"2019-10-07T12:28:12.000Z","author":"霜寒","_content":"\n## 什么是闭包？\n\n作为一个 JavaScript 语言的开发者，提起闭包肯定不会感到陌生，那么到底什么才是闭包哪？\n\n闭包不是什么新奇的概念，它早在高级语言开始发展的年代就产生了。闭包（Closure）是词法闭包的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：\n+ 一种说法认为闭包是**符合一定条件的函数**。认为闭包是在其词法上下文中引用了自由变量（自由变量是指局部变量以外的变量）的函数。\n+ 另一种说法认为闭包是函数和与其相关的引用环境组合而成的实体。认为闭包是**在实现深约束时，需要创建一个能显示表示引用环境的东西**，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。\n\n这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。很明显第二种说法更确切一些，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。\n\n## JavaScript 闭包的本质\n\n在支持嵌套作用域的语言中，有时不能简单直接的确定函数的引用环境。这样的语言一般具有这样的特性：\n+ 函数是一等公民，即函数可以作为一个函数的返回值或参数，还可以作为一个变量的值\n+ 函数可以嵌套定义，即在一个函数内部可以定义另一个函数。\n\nJavaScript 闭包的源自两点，**词法作用域和函数当做值传递**。\n\n作用域是查找变量时的一些规则。词法作用域就是定义在词法阶段的作用域。或者换句话说，词法作用域是由你书写代码时将变量和块作用域写在哪里来决定的。按照代码书写时的样子，内部函数可以顺着作用域链一层一层地查找、访问函数外的变量，或者我们叫它自由变量。\n\n函数当做值传递，也就是上面所说的函数是一等公民。函数内部的自由变量是在外层函数执行时创建的，外层函数执行完以后，这些变量理应被销毁，但是如果将内层函数作为返回值返回，这些自由变量就被保存了下来。而且无法访问，必须通过内层函数来访问。本来执行过程和词法作用域是封闭的，将内层函数作为返回值返回就提供了一种访问自由变量的方式。\n\n一个函数如何能封闭外部状态哪？**当外部状态的scope失效的时候，还有一份留在内部状态里面**。在执行过程中，返回函数，或者将函数得以保留下来，并且函数中有自由变量就会形成闭包。**一个函数中没有自由变量时，引用环境不会发生变化**。\n\n## 闭包的应用\n\n知道了什么是闭包，也理解了闭包的本质，下面可以了解下闭包的几种应用，或许你在日常的开发中已经用到不少了。\n\n### 封装私有变量，存储计算的值\n\n```javascript\n// 将计算的结果保存在 sum 中\nfunction add(init) {\n  var sum = init;\n  return function getSum(number) {\n    sum += number;\n    return sum;\n  }\n}\n```\n### 延迟计算\n\n```javascript\n// 延迟计算\nfunction add(init) {\n  var sum = init;\n  var args = [];\n  return function getSum() {\n    // 当参数到达一定的数量时再进行运算\n    args = args.concat(Array.from(arguments));\n    if(args.length > 5) {\n      for(let i = 0; i < args.length; i++) {\n        sum += args[i];\n      }\n      return sum;\n    }\n  }\n}\n```\n\n### 延续局部变量的寿命\n\nimg 对象经常用于进行数据上报，但是通过查询后台的记录可以得知，因为一些低版本的浏览器的实现可能存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。\n\n```javascript\n// 这种方法会丢失 30% 左右的数据\nvar report = function (src) {\n  var img = new Image();\n  img.src = src;\n};\n\n// 把 img 变量封装起来，就可以解决请求丢失的问题\nvar report = (function(){\n  var imgs = [];\n  return function(src) {\n    var img = new Image();\n    imgs.push(img);\n    img.src = src;\n  }\n})();\n```\n\n### 私有数据和应用程序接口\n\n有时，你想强制程序与数据的交互方式，以便保护其完整性。通过是使用闭包，完全可以做到这一点。创建此类接口的一种常见方法就是从函数返回对象。这时，定义在原函数中的数据只能由返回对象上定义的方法访问，下面是一个例子：\n```javascript\nfunction makeCalendar(name) {\n  var calendar = {\n    owner: name,\n    events: [],\n  };\n  \n  return {\n    addEvent: function(event, dateString) {\n      var eventInfo = {\n        event: event,\n        date: new Date(dateString),\n      };\n      calendar.events.push(eventInfo);\n      calendar.events.sort(function(a, b) {\n        return a.date - b.date;\n      });\n    },\n    \n    listEvents: function() {\n      if (calendar.events.length > 0) {\n        console.log(calendar.owner + \"'s events are: \");\n        \n        calendar.events.forEach(function(eventInfo) {\n          var dateStr = eventInfo.date.toLocaleDateString();\n          var description = dateStr + \": \" + eventInfo.event;\n          \n          console.log(description);\n        });\n      } else {\n        console.log(calendar.owner + \" has no events.\");\n      }\n    },\n  };\n}\n```\n\n## 闭包与内存管理\n\n局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就会一直存在。在这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量的时候，可以手动把这些变量设置为 null。\n\n## 参考内容\n\n- [闭包的概念、形式与应用](https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#artrelatedtopics)\n- [什么是闭包？](https://www.zhihu.com/question/34210214)\n- [JavaScript Weekly: Making Sense of Closures](https://medium.com/launch-school/javascript-weekly-making-sense-of-closures-daa2e0b56f88)\n- [JavaScript 设计模式与开发实践](https://book.douban.com/subject/26382780/)","source":"_posts/闭包的概念与应用.md","raw":"---\ntitle: 闭包的概念与应用\ndate: 2019-10-07 20:28:12\ntags: 闭包\ncategory: JavaScript\nauthor: 霜寒\n---\n\n## 什么是闭包？\n\n作为一个 JavaScript 语言的开发者，提起闭包肯定不会感到陌生，那么到底什么才是闭包哪？\n\n闭包不是什么新奇的概念，它早在高级语言开始发展的年代就产生了。闭包（Closure）是词法闭包的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：\n+ 一种说法认为闭包是**符合一定条件的函数**。认为闭包是在其词法上下文中引用了自由变量（自由变量是指局部变量以外的变量）的函数。\n+ 另一种说法认为闭包是函数和与其相关的引用环境组合而成的实体。认为闭包是**在实现深约束时，需要创建一个能显示表示引用环境的东西**，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。\n\n这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。很明显第二种说法更确切一些，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。\n\n## JavaScript 闭包的本质\n\n在支持嵌套作用域的语言中，有时不能简单直接的确定函数的引用环境。这样的语言一般具有这样的特性：\n+ 函数是一等公民，即函数可以作为一个函数的返回值或参数，还可以作为一个变量的值\n+ 函数可以嵌套定义，即在一个函数内部可以定义另一个函数。\n\nJavaScript 闭包的源自两点，**词法作用域和函数当做值传递**。\n\n作用域是查找变量时的一些规则。词法作用域就是定义在词法阶段的作用域。或者换句话说，词法作用域是由你书写代码时将变量和块作用域写在哪里来决定的。按照代码书写时的样子，内部函数可以顺着作用域链一层一层地查找、访问函数外的变量，或者我们叫它自由变量。\n\n函数当做值传递，也就是上面所说的函数是一等公民。函数内部的自由变量是在外层函数执行时创建的，外层函数执行完以后，这些变量理应被销毁，但是如果将内层函数作为返回值返回，这些自由变量就被保存了下来。而且无法访问，必须通过内层函数来访问。本来执行过程和词法作用域是封闭的，将内层函数作为返回值返回就提供了一种访问自由变量的方式。\n\n一个函数如何能封闭外部状态哪？**当外部状态的scope失效的时候，还有一份留在内部状态里面**。在执行过程中，返回函数，或者将函数得以保留下来，并且函数中有自由变量就会形成闭包。**一个函数中没有自由变量时，引用环境不会发生变化**。\n\n## 闭包的应用\n\n知道了什么是闭包，也理解了闭包的本质，下面可以了解下闭包的几种应用，或许你在日常的开发中已经用到不少了。\n\n### 封装私有变量，存储计算的值\n\n```javascript\n// 将计算的结果保存在 sum 中\nfunction add(init) {\n  var sum = init;\n  return function getSum(number) {\n    sum += number;\n    return sum;\n  }\n}\n```\n### 延迟计算\n\n```javascript\n// 延迟计算\nfunction add(init) {\n  var sum = init;\n  var args = [];\n  return function getSum() {\n    // 当参数到达一定的数量时再进行运算\n    args = args.concat(Array.from(arguments));\n    if(args.length > 5) {\n      for(let i = 0; i < args.length; i++) {\n        sum += args[i];\n      }\n      return sum;\n    }\n  }\n}\n```\n\n### 延续局部变量的寿命\n\nimg 对象经常用于进行数据上报，但是通过查询后台的记录可以得知，因为一些低版本的浏览器的实现可能存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。\n\n```javascript\n// 这种方法会丢失 30% 左右的数据\nvar report = function (src) {\n  var img = new Image();\n  img.src = src;\n};\n\n// 把 img 变量封装起来，就可以解决请求丢失的问题\nvar report = (function(){\n  var imgs = [];\n  return function(src) {\n    var img = new Image();\n    imgs.push(img);\n    img.src = src;\n  }\n})();\n```\n\n### 私有数据和应用程序接口\n\n有时，你想强制程序与数据的交互方式，以便保护其完整性。通过是使用闭包，完全可以做到这一点。创建此类接口的一种常见方法就是从函数返回对象。这时，定义在原函数中的数据只能由返回对象上定义的方法访问，下面是一个例子：\n```javascript\nfunction makeCalendar(name) {\n  var calendar = {\n    owner: name,\n    events: [],\n  };\n  \n  return {\n    addEvent: function(event, dateString) {\n      var eventInfo = {\n        event: event,\n        date: new Date(dateString),\n      };\n      calendar.events.push(eventInfo);\n      calendar.events.sort(function(a, b) {\n        return a.date - b.date;\n      });\n    },\n    \n    listEvents: function() {\n      if (calendar.events.length > 0) {\n        console.log(calendar.owner + \"'s events are: \");\n        \n        calendar.events.forEach(function(eventInfo) {\n          var dateStr = eventInfo.date.toLocaleDateString();\n          var description = dateStr + \": \" + eventInfo.event;\n          \n          console.log(description);\n        });\n      } else {\n        console.log(calendar.owner + \" has no events.\");\n      }\n    },\n  };\n}\n```\n\n## 闭包与内存管理\n\n局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就会一直存在。在这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量的时候，可以手动把这些变量设置为 null。\n\n## 参考内容\n\n- [闭包的概念、形式与应用](https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#artrelatedtopics)\n- [什么是闭包？](https://www.zhihu.com/question/34210214)\n- [JavaScript Weekly: Making Sense of Closures](https://medium.com/launch-school/javascript-weekly-making-sense-of-closures-daa2e0b56f88)\n- [JavaScript 设计模式与开发实践](https://book.douban.com/subject/26382780/)","slug":"闭包的概念与应用","published":1,"updated":"2019-10-08T02:00:04.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufwl00104sefrru33tr5","content":"<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>作为一个 JavaScript 语言的开发者，提起闭包肯定不会感到陌生，那么到底什么才是闭包哪？</p>\n<p>闭包不是什么新奇的概念，它早在高级语言开始发展的年代就产生了。闭包（Closure）是词法闭包的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：</p>\n<ul>\n<li>一种说法认为闭包是<strong>符合一定条件的函数</strong>。认为闭包是在其词法上下文中引用了自由变量（自由变量是指局部变量以外的变量）的函数。</li>\n<li>另一种说法认为闭包是函数和与其相关的引用环境组合而成的实体。认为闭包是<strong>在实现深约束时，需要创建一个能显示表示引用环境的东西</strong>，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。</li>\n</ul>\n<p>这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。很明显第二种说法更确切一些，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。</p>\n<h2 id=\"JavaScript-闭包的本质\"><a href=\"#JavaScript-闭包的本质\" class=\"headerlink\" title=\"JavaScript 闭包的本质\"></a>JavaScript 闭包的本质</h2><p>在支持嵌套作用域的语言中，有时不能简单直接的确定函数的引用环境。这样的语言一般具有这样的特性：</p>\n<ul>\n<li>函数是一等公民，即函数可以作为一个函数的返回值或参数，还可以作为一个变量的值</li>\n<li>函数可以嵌套定义，即在一个函数内部可以定义另一个函数。</li>\n</ul>\n<p>JavaScript 闭包的源自两点，<strong>词法作用域和函数当做值传递</strong>。</p>\n<p>作用域是查找变量时的一些规则。词法作用域就是定义在词法阶段的作用域。或者换句话说，词法作用域是由你书写代码时将变量和块作用域写在哪里来决定的。按照代码书写时的样子，内部函数可以顺着作用域链一层一层地查找、访问函数外的变量，或者我们叫它自由变量。</p>\n<p>函数当做值传递，也就是上面所说的函数是一等公民。函数内部的自由变量是在外层函数执行时创建的，外层函数执行完以后，这些变量理应被销毁，但是如果将内层函数作为返回值返回，这些自由变量就被保存了下来。而且无法访问，必须通过内层函数来访问。本来执行过程和词法作用域是封闭的，将内层函数作为返回值返回就提供了一种访问自由变量的方式。</p>\n<p>一个函数如何能封闭外部状态哪？<strong>当外部状态的scope失效的时候，还有一份留在内部状态里面</strong>。在执行过程中，返回函数，或者将函数得以保留下来，并且函数中有自由变量就会形成闭包。<strong>一个函数中没有自由变量时，引用环境不会发生变化</strong>。</p>\n<h2 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h2><p>知道了什么是闭包，也理解了闭包的本质，下面可以了解下闭包的几种应用，或许你在日常的开发中已经用到不少了。</p>\n<h3 id=\"封装私有变量，存储计算的值\"><a href=\"#封装私有变量，存储计算的值\" class=\"headerlink\" title=\"封装私有变量，存储计算的值\"></a>封装私有变量，存储计算的值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将计算的结果保存在 sum 中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">init</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = init;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">    sum += number;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延迟计算\"><a href=\"#延迟计算\" class=\"headerlink\" title=\"延迟计算\"></a>延迟计算</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 延迟计算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">init</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = init;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当参数到达一定的数量时再进行运算</span></span><br><span class=\"line\">    args = args.concat(<span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(args.length &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; args.length; i++) &#123;</span><br><span class=\"line\">        sum += args[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延续局部变量的寿命\"><a href=\"#延续局部变量的寿命\" class=\"headerlink\" title=\"延续局部变量的寿命\"></a>延续局部变量的寿命</h3><p>img 对象经常用于进行数据上报，但是通过查询后台的记录可以得知，因为一些低版本的浏览器的实现可能存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这种方法会丢失 30% 左右的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> report = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">  img.src = src;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 img 变量封装起来，就可以解决请求丢失的问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> report = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imgs = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    imgs.push(img);</span><br><span class=\"line\">    img.src = src;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"私有数据和应用程序接口\"><a href=\"#私有数据和应用程序接口\" class=\"headerlink\" title=\"私有数据和应用程序接口\"></a>私有数据和应用程序接口</h3><p>有时，你想强制程序与数据的交互方式，以便保护其完整性。通过是使用闭包，完全可以做到这一点。创建此类接口的一种常见方法就是从函数返回对象。这时，定义在原函数中的数据只能由返回对象上定义的方法访问，下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeCalendar</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> calendar = &#123;</span><br><span class=\"line\">    owner: name,</span><br><span class=\"line\">    events: [],</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    addEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event, dateString</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> eventInfo = &#123;</span><br><span class=\"line\">        event: event,</span><br><span class=\"line\">        date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(dateString),</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      calendar.events.push(eventInfo);</span><br><span class=\"line\">      calendar.events.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.date - b.date;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    listEvents: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (calendar.events.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(calendar.owner + <span class=\"string\">\"'s events are: \"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        calendar.events.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventInfo</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> dateStr = eventInfo.date.toLocaleDateString();</span><br><span class=\"line\">          <span class=\"keyword\">var</span> description = dateStr + <span class=\"string\">\": \"</span> + eventInfo.event;</span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(description);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(calendar.owner + <span class=\"string\">\" has no events.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包与内存管理\"><a href=\"#闭包与内存管理\" class=\"headerlink\" title=\"闭包与内存管理\"></a>闭包与内存管理</h2><p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就会一直存在。在这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量的时候，可以手动把这些变量设置为 null。</p>\n<h2 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h2><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#artrelatedtopics\" target=\"_blank\" rel=\"noopener\">闭包的概念、形式与应用</a></li>\n<li><a href=\"https://www.zhihu.com/question/34210214\" target=\"_blank\" rel=\"noopener\">什么是闭包？</a></li>\n<li><a href=\"https://medium.com/launch-school/javascript-weekly-making-sense-of-closures-daa2e0b56f88\" target=\"_blank\" rel=\"noopener\">JavaScript Weekly: Making Sense of Closures</a></li>\n<li><a href=\"https://book.douban.com/subject/26382780/\" target=\"_blank\" rel=\"noopener\">JavaScript 设计模式与开发实践</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>作为一个 JavaScript 语言的开发者，提起闭包肯定不会感到陌生，那么到底什么才是闭包哪？</p>\n<p>闭包不是什么新奇的概念，它早在高级语言开始发展的年代就产生了。闭包（Closure）是词法闭包的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类：</p>\n<ul>\n<li>一种说法认为闭包是<strong>符合一定条件的函数</strong>。认为闭包是在其词法上下文中引用了自由变量（自由变量是指局部变量以外的变量）的函数。</li>\n<li>另一种说法认为闭包是函数和与其相关的引用环境组合而成的实体。认为闭包是<strong>在实现深约束时，需要创建一个能显示表示引用环境的东西</strong>，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。</li>\n</ul>\n<p>这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。很明显第二种说法更确切一些，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。</p>\n<h2 id=\"JavaScript-闭包的本质\"><a href=\"#JavaScript-闭包的本质\" class=\"headerlink\" title=\"JavaScript 闭包的本质\"></a>JavaScript 闭包的本质</h2><p>在支持嵌套作用域的语言中，有时不能简单直接的确定函数的引用环境。这样的语言一般具有这样的特性：</p>\n<ul>\n<li>函数是一等公民，即函数可以作为一个函数的返回值或参数，还可以作为一个变量的值</li>\n<li>函数可以嵌套定义，即在一个函数内部可以定义另一个函数。</li>\n</ul>\n<p>JavaScript 闭包的源自两点，<strong>词法作用域和函数当做值传递</strong>。</p>\n<p>作用域是查找变量时的一些规则。词法作用域就是定义在词法阶段的作用域。或者换句话说，词法作用域是由你书写代码时将变量和块作用域写在哪里来决定的。按照代码书写时的样子，内部函数可以顺着作用域链一层一层地查找、访问函数外的变量，或者我们叫它自由变量。</p>\n<p>函数当做值传递，也就是上面所说的函数是一等公民。函数内部的自由变量是在外层函数执行时创建的，外层函数执行完以后，这些变量理应被销毁，但是如果将内层函数作为返回值返回，这些自由变量就被保存了下来。而且无法访问，必须通过内层函数来访问。本来执行过程和词法作用域是封闭的，将内层函数作为返回值返回就提供了一种访问自由变量的方式。</p>\n<p>一个函数如何能封闭外部状态哪？<strong>当外部状态的scope失效的时候，还有一份留在内部状态里面</strong>。在执行过程中，返回函数，或者将函数得以保留下来，并且函数中有自由变量就会形成闭包。<strong>一个函数中没有自由变量时，引用环境不会发生变化</strong>。</p>\n<h2 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h2><p>知道了什么是闭包，也理解了闭包的本质，下面可以了解下闭包的几种应用，或许你在日常的开发中已经用到不少了。</p>\n<h3 id=\"封装私有变量，存储计算的值\"><a href=\"#封装私有变量，存储计算的值\" class=\"headerlink\" title=\"封装私有变量，存储计算的值\"></a>封装私有变量，存储计算的值</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将计算的结果保存在 sum 中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">init</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = init;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\">number</span>) </span>&#123;</span><br><span class=\"line\">    sum += number;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延迟计算\"><a href=\"#延迟计算\" class=\"headerlink\" title=\"延迟计算\"></a>延迟计算</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 延迟计算</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">init</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> sum = init;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 当参数到达一定的数量时再进行运算</span></span><br><span class=\"line\">    args = args.concat(<span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(args.length &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span>(<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; args.length; i++) &#123;</span><br><span class=\"line\">        sum += args[i];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"延续局部变量的寿命\"><a href=\"#延续局部变量的寿命\" class=\"headerlink\" title=\"延续局部变量的寿命\"></a>延续局部变量的寿命</h3><p>img 对象经常用于进行数据上报，但是通过查询后台的记录可以得知，因为一些低版本的浏览器的实现可能存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这种方法会丢失 30% 左右的数据</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> report = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">  img.src = src;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 把 img 变量封装起来，就可以解决请求丢失的问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> report = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> imgs = [];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">src</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> img = <span class=\"keyword\">new</span> Image();</span><br><span class=\"line\">    imgs.push(img);</span><br><span class=\"line\">    img.src = src;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"私有数据和应用程序接口\"><a href=\"#私有数据和应用程序接口\" class=\"headerlink\" title=\"私有数据和应用程序接口\"></a>私有数据和应用程序接口</h3><p>有时，你想强制程序与数据的交互方式，以便保护其完整性。通过是使用闭包，完全可以做到这一点。创建此类接口的一种常见方法就是从函数返回对象。这时，定义在原函数中的数据只能由返回对象上定义的方法访问，下面是一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeCalendar</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> calendar = &#123;</span><br><span class=\"line\">    owner: name,</span><br><span class=\"line\">    events: [],</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    addEvent: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event, dateString</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> eventInfo = &#123;</span><br><span class=\"line\">        event: event,</span><br><span class=\"line\">        date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(dateString),</span><br><span class=\"line\">      &#125;;</span><br><span class=\"line\">      calendar.events.push(eventInfo);</span><br><span class=\"line\">      calendar.events.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a.date - b.date;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    </span><br><span class=\"line\">    listEvents: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (calendar.events.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(calendar.owner + <span class=\"string\">\"'s events are: \"</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">        calendar.events.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">eventInfo</span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> dateStr = eventInfo.date.toLocaleDateString();</span><br><span class=\"line\">          <span class=\"keyword\">var</span> description = dateStr + <span class=\"string\">\": \"</span> + eventInfo.event;</span><br><span class=\"line\">          </span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(description);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(calendar.owner + <span class=\"string\">\" has no events.\"</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"闭包与内存管理\"><a href=\"#闭包与内存管理\" class=\"headerlink\" title=\"闭包与内存管理\"></a>闭包与内存管理</h2><p>局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就会一直存在。在这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量的时候，可以手动把这些变量设置为 null。</p>\n<h2 id=\"参考内容\"><a href=\"#参考内容\" class=\"headerlink\" title=\"参考内容\"></a>参考内容</h2><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/linux/l-cn-closure/#artrelatedtopics\" target=\"_blank\" rel=\"noopener\">闭包的概念、形式与应用</a></li>\n<li><a href=\"https://www.zhihu.com/question/34210214\" target=\"_blank\" rel=\"noopener\">什么是闭包？</a></li>\n<li><a href=\"https://medium.com/launch-school/javascript-weekly-making-sense-of-closures-daa2e0b56f88\" target=\"_blank\" rel=\"noopener\">JavaScript Weekly: Making Sense of Closures</a></li>\n<li><a href=\"https://book.douban.com/subject/26382780/\" target=\"_blank\" rel=\"noopener\">JavaScript 设计模式与开发实践</a></li>\n</ul>\n"},{"layout":"post","title":"javascript中的Map","date":"2019-08-26T02:53:41.000Z","author":"胡豪","_content":"\n\n# 探究javascript Map\n什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。  \nMap 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。  \nECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。\n## 语法\n\n```js\nnew Map([iterable])\n```\niterable (可迭代传参)\nIterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n\n## 描述\n\n一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for...of 循环在每次迭代后会返回一个形式为[key，value]的数组。\n\n键的比较是基于 \"SameValueZero\" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 \n\nObjects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：\n\n* 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。\n* Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。\n* 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。\n* Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。\n* Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。\n* Map 在涉及频繁增删键值对的场景下会有些性能优势。\n\n最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;  \nobject获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。\n\n\n## 属性\n\n* Map.length \n\n* get Map[@@species]\n\n* Map.prototype\n\n## Map 实例\n\n### *属性\nMap.prototype.constructor  \n返回一个函数，它创建了实例的原型。默认是Map函数。\n\nMap.prototype.size  \n返回Map对象的键/值对的数量。\n\n### *方法\n\nMap.prototype.clear()\n移除Map对象的所有键/值对 。\n\nMap.prototype.delete(key)\n如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false\n\nMap.prototype.entries()\n返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\nMap.prototype.forEach(callbackFn[, thisArg])\n按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。\n\nMap.prototype.get(key)\n返回键对应的值，如果不存在，则返回undefined。\n\nMap.prototype.has(key)\n返回一个布尔值，表示Map实例是否包含键对应的值。\n\nMap.prototype.keys()\n返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。\n\nMap.prototype.set(key, value)\n设置Map对象中键的值。返回该Map对象。\n\nMap.prototype.values()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。\n\nMap.prototype[@@iterator]()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\n## 实例\n\n### 使用 Map 对象\n```js\nvar myMap = new Map();\n \nvar keyObj = {},\n    keyFunc = function () {},\n    keyString = \"a string\";\n \n// 添加键\nmyMap.set(keyString, \"和键'a string'关联的值\");\nmyMap.set(keyObj, \"和键keyObj关联的值\");\nmyMap.set(keyFunc, \"和键keyFunc关联的值\");\n \nmyMap.size; // 3\n \n// 读取值\nmyMap.get(keyString);    // \"和键'a string'关联的值\"\nmyMap.get(keyObj);       // \"和键keyObj关联的值\"\nmyMap.get(keyFunc);      // \"和键keyFunc关联的值\"\n \nmyMap.get(\"a string\");   // \"和键'a string'关联的值\"\n                         // 因为keyString === 'a string'\nmyMap.get({});           // undefined, 因为keyObj !== {}\nmyMap.get(function() {}) // undefined, 因为keyFunc !== function () {}\n```\n### 使用 for..of 方法迭代 Map\n```js\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\nfor (var [key, value] of myMap) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"\n\nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"\n\nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"\n\nfor (var [key, value] of myMap.entries()) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### 使用 forEach() 方法迭代 Map\n```js\nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n})\n// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### Map 与数组的关系\n```js\nvar kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];\n\n// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象\nvar myMap = new Map(kvArray);\n\nmyMap.get(\"key1\"); // 返回值为 \"value1\"\n\n// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组\nconsole.log(Array.from(myMap)); // 输出和kvArray相同的数组\n\n// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组\nconsole.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"]\n```\n### 复制或合并 Maps\n```js\nvar original = new Map([\n  [1, 'one']\n]);\n\nvar clone = new Map(original);\n\nconsole.log(clone.get(1)); // one\nconsole.log(original === clone); // false. Useful for shallow comparison\n```\n请记住，数据本身未被克隆。\n\nMap对象间可以进行合并，但是会保持键的唯一性。\n```js\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。\n// 展开运算符本质上是将Map对象转换成数组。\nvar merged = new Map([...first, ...second]);\n\nconsole.log(merged.get(1)); // uno\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\nMap对象也能与数组合并：\n```js\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。\nvar merged = new Map([...first, ...second, [1, 'eins']]);\n\nconsole.log(merged.get(1)); // eins\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\n\n\n# 以上讲的是Map，那不得不说map( )是什么\n\nECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类  \nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n\n## 语法\n``` js\nvar new_array = array.map(function callback(currentValue,index,arr), thisValue)\n```\n## 参数\ncallback 生成新数组元素的函数，使用三个参数：  \n* currentValue callback 数组中正在处理的当前元素。  \n* index可选 callback 数组中正在处理的当前元素的索引。  \n* array可选 callback  map 方法被调用的数组。\n\nthisArg可选 执行 callback 函数时使用的this 值。\n\n## 示例\n```js\nvar array1 = [1,3,6];\nconst map1 = array1.map(x => x *2);\nconsole.log(map1);   \n// > Array [2, 6, 12]\n```\n\n```js\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n});\n \nconsole.log(map1);\n\n// > Array [undefined, 6, undefined]\n```\n出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了\n```js\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n    return x\n});\n \nconsole.log(map1);\n\n// > Array [2, 6, 12]\n```\n可以使用 map 重新格式化数组中的对象\n```js\nvar oldArray = [{key: 1, value: 10}, \n                {key: 2, value: 20}, \n                {key: 3, value: 30}];\n\nvar nowArr = oldArray.map(function(obj) { \n   var rObj = {};\n   rObj[obj.key] = obj.value;\n   return rObj;\n});\n\n// nowArr 数组为： [{1: 10}, {2: 20}, {3: 30}], \n\n// oldArray 数组未被修改: \n// [{key: 1, value: 10}, \n//  {key: 2, value: 20}, \n//  {key: 3, value: 30}]\n```\n\n# 用ES5模拟实现ES6中的Map类\n\n与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：\n1.set(key,value):向字典中添加新元素。\n\n2.remove(key):使用键名从字典中移除相应的元素。\n\n3.has(key):如果某个键值存在于字典中，返回true，否则返回false。\n\n4.get(key):通过键名找到指定的值并返回。\n\n5.clear():清空字典。\n\n6.size():返回字典中元素个数。\n\n7.values():将字典所有值以数组形式返回。\n\n8.getItems():返回items变量，代表字典本身。\n\n\n```js\nfunction Map() {\n    var items = {};\n    this.has = function(key){    //has方法判断某个键值是否在字典中\n        return key in items;\n    },\n    this.set = function(key,value){    //set方法为字典添加新元素或更新已有元素\n        items[key] = value;\n    },\n    this.remove = function(key){\n        if (this.has(key)) {\n            delete items[key];\n            return true;\n        }\n        return false;\n    },\n    this.get = function(key){\n        return this.has(key)?items[key]:undefined;\n    },\n    this.values = function(){\n        var values = [];\n         //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。\n        for(var k in items){   \n            if (this.hasOwnProperty(k)) {\n                values.push(items[k]);\n            }\n        }\n        return values;\n    },\n    this.clear = function(){\n        items = {};\n    },\n    this.size = function(){\n        return Object.Keys(items).length;\n    },\n    this.getItems = function(){\n        return items;\n    }\n}\n```","source":"_posts/javascript中的Map.md","raw":"---\nlayout: post\ntitle: javascript中的Map\ndate: 2019-08-26 10:53:41\nauthor: 胡豪\ncategories: \n- JavaScript \ntags:\n- js \n---\n\n\n# 探究javascript Map\n什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。  \nMap 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。  \nECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。\n## 语法\n\n```js\nnew Map([iterable])\n```\niterable (可迭代传参)\nIterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n\n## 描述\n\n一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for...of 循环在每次迭代后会返回一个形式为[key，value]的数组。\n\n键的比较是基于 \"SameValueZero\" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 \n\nObjects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：\n\n* 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。\n* Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。\n* 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。\n* Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。\n* Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。\n* Map 在涉及频繁增删键值对的场景下会有些性能优势。\n\n最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;  \nobject获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。\n\n\n## 属性\n\n* Map.length \n\n* get Map[@@species]\n\n* Map.prototype\n\n## Map 实例\n\n### *属性\nMap.prototype.constructor  \n返回一个函数，它创建了实例的原型。默认是Map函数。\n\nMap.prototype.size  \n返回Map对象的键/值对的数量。\n\n### *方法\n\nMap.prototype.clear()\n移除Map对象的所有键/值对 。\n\nMap.prototype.delete(key)\n如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false\n\nMap.prototype.entries()\n返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\nMap.prototype.forEach(callbackFn[, thisArg])\n按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。\n\nMap.prototype.get(key)\n返回键对应的值，如果不存在，则返回undefined。\n\nMap.prototype.has(key)\n返回一个布尔值，表示Map实例是否包含键对应的值。\n\nMap.prototype.keys()\n返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。\n\nMap.prototype.set(key, value)\n设置Map对象中键的值。返回该Map对象。\n\nMap.prototype.values()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。\n\nMap.prototype[@@iterator]()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\n## 实例\n\n### 使用 Map 对象\n```js\nvar myMap = new Map();\n \nvar keyObj = {},\n    keyFunc = function () {},\n    keyString = \"a string\";\n \n// 添加键\nmyMap.set(keyString, \"和键'a string'关联的值\");\nmyMap.set(keyObj, \"和键keyObj关联的值\");\nmyMap.set(keyFunc, \"和键keyFunc关联的值\");\n \nmyMap.size; // 3\n \n// 读取值\nmyMap.get(keyString);    // \"和键'a string'关联的值\"\nmyMap.get(keyObj);       // \"和键keyObj关联的值\"\nmyMap.get(keyFunc);      // \"和键keyFunc关联的值\"\n \nmyMap.get(\"a string\");   // \"和键'a string'关联的值\"\n                         // 因为keyString === 'a string'\nmyMap.get({});           // undefined, 因为keyObj !== {}\nmyMap.get(function() {}) // undefined, 因为keyFunc !== function () {}\n```\n### 使用 for..of 方法迭代 Map\n```js\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\nfor (var [key, value] of myMap) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"\n\nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"\n\nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"\n\nfor (var [key, value] of myMap.entries()) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### 使用 forEach() 方法迭代 Map\n```js\nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n})\n// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### Map 与数组的关系\n```js\nvar kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];\n\n// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象\nvar myMap = new Map(kvArray);\n\nmyMap.get(\"key1\"); // 返回值为 \"value1\"\n\n// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组\nconsole.log(Array.from(myMap)); // 输出和kvArray相同的数组\n\n// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组\nconsole.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"]\n```\n### 复制或合并 Maps\n```js\nvar original = new Map([\n  [1, 'one']\n]);\n\nvar clone = new Map(original);\n\nconsole.log(clone.get(1)); // one\nconsole.log(original === clone); // false. Useful for shallow comparison\n```\n请记住，数据本身未被克隆。\n\nMap对象间可以进行合并，但是会保持键的唯一性。\n```js\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。\n// 展开运算符本质上是将Map对象转换成数组。\nvar merged = new Map([...first, ...second]);\n\nconsole.log(merged.get(1)); // uno\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\nMap对象也能与数组合并：\n```js\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。\nvar merged = new Map([...first, ...second, [1, 'eins']]);\n\nconsole.log(merged.get(1)); // eins\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\n\n\n# 以上讲的是Map，那不得不说map( )是什么\n\nECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类  \nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n\n## 语法\n``` js\nvar new_array = array.map(function callback(currentValue,index,arr), thisValue)\n```\n## 参数\ncallback 生成新数组元素的函数，使用三个参数：  \n* currentValue callback 数组中正在处理的当前元素。  \n* index可选 callback 数组中正在处理的当前元素的索引。  \n* array可选 callback  map 方法被调用的数组。\n\nthisArg可选 执行 callback 函数时使用的this 值。\n\n## 示例\n```js\nvar array1 = [1,3,6];\nconst map1 = array1.map(x => x *2);\nconsole.log(map1);   \n// > Array [2, 6, 12]\n```\n\n```js\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n});\n \nconsole.log(map1);\n\n// > Array [undefined, 6, undefined]\n```\n出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了\n```js\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n    return x\n});\n \nconsole.log(map1);\n\n// > Array [2, 6, 12]\n```\n可以使用 map 重新格式化数组中的对象\n```js\nvar oldArray = [{key: 1, value: 10}, \n                {key: 2, value: 20}, \n                {key: 3, value: 30}];\n\nvar nowArr = oldArray.map(function(obj) { \n   var rObj = {};\n   rObj[obj.key] = obj.value;\n   return rObj;\n});\n\n// nowArr 数组为： [{1: 10}, {2: 20}, {3: 30}], \n\n// oldArray 数组未被修改: \n// [{key: 1, value: 10}, \n//  {key: 2, value: 20}, \n//  {key: 3, value: 30}]\n```\n\n# 用ES5模拟实现ES6中的Map类\n\n与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：\n1.set(key,value):向字典中添加新元素。\n\n2.remove(key):使用键名从字典中移除相应的元素。\n\n3.has(key):如果某个键值存在于字典中，返回true，否则返回false。\n\n4.get(key):通过键名找到指定的值并返回。\n\n5.clear():清空字典。\n\n6.size():返回字典中元素个数。\n\n7.values():将字典所有值以数组形式返回。\n\n8.getItems():返回items变量，代表字典本身。\n\n\n```js\nfunction Map() {\n    var items = {};\n    this.has = function(key){    //has方法判断某个键值是否在字典中\n        return key in items;\n    },\n    this.set = function(key,value){    //set方法为字典添加新元素或更新已有元素\n        items[key] = value;\n    },\n    this.remove = function(key){\n        if (this.has(key)) {\n            delete items[key];\n            return true;\n        }\n        return false;\n    },\n    this.get = function(key){\n        return this.has(key)?items[key]:undefined;\n    },\n    this.values = function(){\n        var values = [];\n         //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。\n        for(var k in items){   \n            if (this.hasOwnProperty(k)) {\n                values.push(items[k]);\n            }\n        }\n        return values;\n    },\n    this.clear = function(){\n        items = {};\n    },\n    this.size = function(){\n        return Object.Keys(items).length;\n    },\n    this.getItems = function(){\n        return items;\n    }\n}\n```","slug":"javascript中的Map","published":1,"updated":"2019-09-24T06:10:49.296Z","comments":1,"photos":[],"link":"","_id":"ck2ydufxo001r4sef44072hc4","content":"<h1 id=\"探究javascript-Map\"><a href=\"#探究javascript-Map\" class=\"headerlink\" title=\"探究javascript Map\"></a>探究javascript Map</h1><p>什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。<br>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。<br>ECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([iterable])</span><br></pre></td></tr></table></figure>\n\n<p>iterable (可迭代传参)<br>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>\n<p>键的比较是基于 “SameValueZero” 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 </p>\n<p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>\n<ul>\n<li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li>\n<li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li>\n<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>\n<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li>\n<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>\n<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>\n</ul>\n<p>最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;<br>object获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li><p>Map.length </p>\n</li>\n<li><p>get Map[@@species]</p>\n</li>\n<li><p>Map.prototype</p>\n</li>\n</ul>\n<h2 id=\"Map-实例\"><a href=\"#Map-实例\" class=\"headerlink\" title=\"Map 实例\"></a>Map 实例</h2><h3 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"*属性\"></a>*属性</h3><p>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</p>\n<p>Map.prototype.size<br>返回Map对象的键/值对的数量。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"*方法\"></a>*方法</h3><p>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</p>\n<p>Map.prototype.delete(key)<br>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false</p>\n<p>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<p>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</p>\n<p>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</p>\n<p>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</p>\n<p>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</p>\n<p>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</p>\n<p>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</p>\n<p>Map.prototype<a href>@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"使用-Map-对象\"><a href=\"#使用-Map-对象\" class=\"headerlink\" title=\"使用 Map 对象\"></a>使用 Map 对象</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> keyObj = &#123;&#125;,</span><br><span class=\"line\">    keyFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    keyString = <span class=\"string\">\"a string\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 添加键</span></span><br><span class=\"line\">myMap.set(keyString, <span class=\"string\">\"和键'a string'关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyObj, <span class=\"string\">\"和键keyObj关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyFunc, <span class=\"string\">\"和键keyFunc关联的值\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.size; <span class=\"comment\">// 3</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 读取值</span></span><br><span class=\"line\">myMap.get(keyString);    <span class=\"comment\">// \"和键'a string'关联的值\"</span></span><br><span class=\"line\">myMap.get(keyObj);       <span class=\"comment\">// \"和键keyObj关联的值\"</span></span><br><span class=\"line\">myMap.get(keyFunc);      <span class=\"comment\">// \"和键keyFunc关联的值\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.get(<span class=\"string\">\"a string\"</span>);   <span class=\"comment\">// \"和键'a string'关联的值\"</span></span><br><span class=\"line\">                         <span class=\"comment\">// 因为keyString === 'a string'</span></span><br><span class=\"line\">myMap.get(&#123;&#125;);           <span class=\"comment\">// undefined, 因为keyObj !== &#123;&#125;</span></span><br><span class=\"line\">myMap.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;) <span class=\"comment\">// undefined, 因为keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-for-of-方法迭代-Map\"><a href=\"#使用-for-of-方法迭代-Map\" class=\"headerlink\" title=\"使用 for..of 方法迭代 Map\"></a>使用 for..of 方法迭代 Map</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">myMap.set(<span class=\"number\">0</span>, <span class=\"string\">\"zero\"</span>);</span><br><span class=\"line\">myMap.set(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> myMap) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" = \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">of</span> myMap.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> myMap.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> myMap.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" = \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-forEach-方法迭代-Map\"><a href=\"#使用-forEach-方法迭代-Map\" class=\"headerlink\" title=\"使用 forEach() 方法迭代 Map\"></a>使用 forEach() 方法迭代 Map</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myMap.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" = \"</span> + value);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-与数组的关系\"><a href=\"#Map-与数组的关系\" class=\"headerlink\" title=\"Map 与数组的关系\"></a>Map 与数组的关系</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> kvArray = [[<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>], [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(kvArray);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"string\">\"key1\"</span>); <span class=\"comment\">// 返回值为 \"value1\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(myMap)); <span class=\"comment\">// 输出和kvArray相同的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(myMap.keys())); <span class=\"comment\">// 输出 [\"key1\", \"key2\"]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复制或合并-Maps\"><a href=\"#复制或合并-Maps\" class=\"headerlink\" title=\"复制或合并 Maps\"></a>复制或合并 Maps</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> original = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> clone = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(original);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clone.get(<span class=\"number\">1</span>)); <span class=\"comment\">// one</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(original === clone); <span class=\"comment\">// false. Useful for shallow comparison</span></span><br></pre></td></tr></table></figure>\n\n<p>请记住，数据本身未被克隆。</p>\n<p>Map对象间可以进行合并，但是会保持键的唯一性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> second = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'uno'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'dos'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span></span><br><span class=\"line\"><span class=\"comment\">// 展开运算符本质上是将Map对象转换成数组。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...first, ...second]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">1</span>)); <span class=\"comment\">// uno</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">2</span>)); <span class=\"comment\">// dos</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">3</span>)); <span class=\"comment\">// three</span></span><br></pre></td></tr></table></figure>\n\n<p>Map对象也能与数组合并：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> second = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'uno'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'dos'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...first, ...second, [<span class=\"number\">1</span>, <span class=\"string\">'eins'</span>]]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">1</span>)); <span class=\"comment\">// eins</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">2</span>)); <span class=\"comment\">// dos</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">3</span>)); <span class=\"comment\">// three</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"以上讲的是Map，那不得不说map-是什么\"><a href=\"#以上讲的是Map，那不得不说map-是什么\" class=\"headerlink\" title=\"以上讲的是Map，那不得不说map( )是什么\"></a>以上讲的是Map，那不得不说map( )是什么</h1><p>ECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类<br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> new_array = array.map(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callback</span>(<span class=\"params\">currentValue,index,arr</span>), <span class=\"title\">thisValue</span>)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>callback 生成新数组元素的函数，使用三个参数：  </p>\n<ul>\n<li>currentValue callback 数组中正在处理的当前元素。  </li>\n<li>index可选 callback 数组中正在处理的当前元素的索引。  </li>\n<li>array可选 callback  map 方法被调用的数组。</li>\n</ul>\n<p>thisArg可选 执行 callback 函数时使用的this 值。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = array1.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x *<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1);   </span><br><span class=\"line\"><span class=\"comment\">// &gt; Array [2, 6, 12]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = array1.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; Array [undefined, 6, undefined]</span></span><br></pre></td></tr></table></figure>\n\n<p>出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = array1.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; Array [2, 6, 12]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用 map 重新格式化数组中的对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> oldArray = [&#123;<span class=\"attr\">key</span>: <span class=\"number\">1</span>, <span class=\"attr\">value</span>: <span class=\"number\">10</span>&#125;, </span><br><span class=\"line\">                &#123;<span class=\"attr\">key</span>: <span class=\"number\">2</span>, <span class=\"attr\">value</span>: <span class=\"number\">20</span>&#125;, </span><br><span class=\"line\">                &#123;<span class=\"attr\">key</span>: <span class=\"number\">3</span>, <span class=\"attr\">value</span>: <span class=\"number\">30</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowArr = oldArray.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123; </span><br><span class=\"line\">   <span class=\"keyword\">var</span> rObj = &#123;&#125;;</span><br><span class=\"line\">   rObj[obj.key] = obj.value;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> rObj;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nowArr 数组为： [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;], </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// oldArray 数组未被修改: </span></span><br><span class=\"line\"><span class=\"comment\">// [&#123;key: 1, value: 10&#125;, </span></span><br><span class=\"line\"><span class=\"comment\">//  &#123;key: 2, value: 20&#125;, </span></span><br><span class=\"line\"><span class=\"comment\">//  &#123;key: 3, value: 30&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用ES5模拟实现ES6中的Map类\"><a href=\"#用ES5模拟实现ES6中的Map类\" class=\"headerlink\" title=\"用ES5模拟实现ES6中的Map类\"></a>用ES5模拟实现ES6中的Map类</h1><p>与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：<br>1.set(key,value):向字典中添加新元素。</p>\n<p>2.remove(key):使用键名从字典中移除相应的元素。</p>\n<p>3.has(key):如果某个键值存在于字典中，返回true，否则返回false。</p>\n<p>4.get(key):通过键名找到指定的值并返回。</p>\n<p>5.clear():清空字典。</p>\n<p>6.size():返回字典中元素个数。</p>\n<p>7.values():将字典所有值以数组形式返回。</p>\n<p>8.getItems():返回items变量，代表字典本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Map</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.has = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;    <span class=\"comment\">//has方法判断某个键值是否在字典中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.set = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,value</span>)</span>&#123;    <span class=\"comment\">//set方法为字典添加新元素或更新已有元素</span></span><br><span class=\"line\">        items[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> items[key];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key)?items[key]:<span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">         <span class=\"comment\">//for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> items)&#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">                values.push(items[k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        items = &#123;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.Keys(items).length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getItems = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> items;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"探究javascript-Map\"><a href=\"#探究javascript-Map\" class=\"headerlink\" title=\"探究javascript Map\"></a>探究javascript Map</h1><p>什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。<br>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。<br>ECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([iterable])</span><br></pre></td></tr></table></figure>\n\n<p>iterable (可迭代传参)<br>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>\n<p>键的比较是基于 “SameValueZero” 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 </p>\n<p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>\n<ul>\n<li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li>\n<li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li>\n<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>\n<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li>\n<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>\n<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>\n</ul>\n<p>最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;<br>object获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li><p>Map.length </p>\n</li>\n<li><p>get Map[@@species]</p>\n</li>\n<li><p>Map.prototype</p>\n</li>\n</ul>\n<h2 id=\"Map-实例\"><a href=\"#Map-实例\" class=\"headerlink\" title=\"Map 实例\"></a>Map 实例</h2><h3 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"*属性\"></a>*属性</h3><p>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</p>\n<p>Map.prototype.size<br>返回Map对象的键/值对的数量。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"*方法\"></a>*方法</h3><p>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</p>\n<p>Map.prototype.delete(key)<br>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false</p>\n<p>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<p>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</p>\n<p>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</p>\n<p>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</p>\n<p>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</p>\n<p>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</p>\n<p>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</p>\n<p>Map.prototype<a href>@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"使用-Map-对象\"><a href=\"#使用-Map-对象\" class=\"headerlink\" title=\"使用 Map 对象\"></a>使用 Map 对象</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">var</span> keyObj = &#123;&#125;,</span><br><span class=\"line\">    keyFunc = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">    keyString = <span class=\"string\">\"a string\"</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 添加键</span></span><br><span class=\"line\">myMap.set(keyString, <span class=\"string\">\"和键'a string'关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyObj, <span class=\"string\">\"和键keyObj关联的值\"</span>);</span><br><span class=\"line\">myMap.set(keyFunc, <span class=\"string\">\"和键keyFunc关联的值\"</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.size; <span class=\"comment\">// 3</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// 读取值</span></span><br><span class=\"line\">myMap.get(keyString);    <span class=\"comment\">// \"和键'a string'关联的值\"</span></span><br><span class=\"line\">myMap.get(keyObj);       <span class=\"comment\">// \"和键keyObj关联的值\"</span></span><br><span class=\"line\">myMap.get(keyFunc);      <span class=\"comment\">// \"和键keyFunc关联的值\"</span></span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.get(<span class=\"string\">\"a string\"</span>);   <span class=\"comment\">// \"和键'a string'关联的值\"</span></span><br><span class=\"line\">                         <span class=\"comment\">// 因为keyString === 'a string'</span></span><br><span class=\"line\">myMap.get(&#123;&#125;);           <span class=\"comment\">// undefined, 因为keyObj !== &#123;&#125;</span></span><br><span class=\"line\">myMap.get(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;) <span class=\"comment\">// undefined, 因为keyFunc !== function () &#123;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-for-of-方法迭代-Map\"><a href=\"#使用-for-of-方法迭代-Map\" class=\"headerlink\" title=\"使用 for..of 方法迭代 Map\"></a>使用 for..of 方法迭代 Map</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>();</span><br><span class=\"line\">myMap.set(<span class=\"number\">0</span>, <span class=\"string\">\"zero\"</span>);</span><br><span class=\"line\">myMap.set(<span class=\"number\">1</span>, <span class=\"string\">\"one\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> myMap) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" = \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">of</span> myMap.keys()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> value <span class=\"keyword\">of</span> myMap.values()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> [key, value] <span class=\"keyword\">of</span> myMap.entries()) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" = \"</span> + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-forEach-方法迭代-Map\"><a href=\"#使用-forEach-方法迭代-Map\" class=\"headerlink\" title=\"使用 forEach() 方法迭代 Map\"></a>使用 forEach() 方法迭代 Map</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myMap.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, key</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(key + <span class=\"string\">\" = \"</span> + value);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-与数组的关系\"><a href=\"#Map-与数组的关系\" class=\"headerlink\" title=\"Map 与数组的关系\"></a>Map 与数组的关系</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> kvArray = [[<span class=\"string\">\"key1\"</span>, <span class=\"string\">\"value1\"</span>], [<span class=\"string\">\"key2\"</span>, <span class=\"string\">\"value2\"</span>]];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> myMap = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(kvArray);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(<span class=\"string\">\"key1\"</span>); <span class=\"comment\">// 返回值为 \"value1\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(myMap)); <span class=\"comment\">// 输出和kvArray相同的数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(myMap.keys())); <span class=\"comment\">// 输出 [\"key1\", \"key2\"]</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复制或合并-Maps\"><a href=\"#复制或合并-Maps\" class=\"headerlink\" title=\"复制或合并 Maps\"></a>复制或合并 Maps</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> original = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> clone = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>(original);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(clone.get(<span class=\"number\">1</span>)); <span class=\"comment\">// one</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(original === clone); <span class=\"comment\">// false. Useful for shallow comparison</span></span><br></pre></td></tr></table></figure>\n\n<p>请记住，数据本身未被克隆。</p>\n<p>Map对象间可以进行合并，但是会保持键的唯一性。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> second = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'uno'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'dos'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span></span><br><span class=\"line\"><span class=\"comment\">// 展开运算符本质上是将Map对象转换成数组。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...first, ...second]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">1</span>)); <span class=\"comment\">// uno</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">2</span>)); <span class=\"comment\">// dos</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">3</span>)); <span class=\"comment\">// three</span></span><br></pre></td></tr></table></figure>\n\n<p>Map对象也能与数组合并：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> first = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'one'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'two'</span>],</span><br><span class=\"line\">  [<span class=\"number\">3</span>, <span class=\"string\">'three'</span>],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> second = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([</span><br><span class=\"line\">  [<span class=\"number\">1</span>, <span class=\"string\">'uno'</span>],</span><br><span class=\"line\">  [<span class=\"number\">2</span>, <span class=\"string\">'dos'</span>]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> merged = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>([...first, ...second, [<span class=\"number\">1</span>, <span class=\"string\">'eins'</span>]]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">1</span>)); <span class=\"comment\">// eins</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">2</span>)); <span class=\"comment\">// dos</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(merged.get(<span class=\"number\">3</span>)); <span class=\"comment\">// three</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"以上讲的是Map，那不得不说map-是什么\"><a href=\"#以上讲的是Map，那不得不说map-是什么\" class=\"headerlink\" title=\"以上讲的是Map，那不得不说map( )是什么\"></a>以上讲的是Map，那不得不说map( )是什么</h1><p>ECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类<br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> new_array = array.map(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callback</span>(<span class=\"params\">currentValue,index,arr</span>), <span class=\"title\">thisValue</span>)</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>callback 生成新数组元素的函数，使用三个参数：  </p>\n<ul>\n<li>currentValue callback 数组中正在处理的当前元素。  </li>\n<li>index可选 callback 数组中正在处理的当前元素的索引。  </li>\n<li>array可选 callback  map 方法被调用的数组。</li>\n</ul>\n<p>thisArg可选 执行 callback 函数时使用的this 值。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = array1.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x *<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1);   </span><br><span class=\"line\"><span class=\"comment\">// &gt; Array [2, 6, 12]</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = array1.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; Array [undefined, 6, undefined]</span></span><br></pre></td></tr></table></figure>\n\n<p>出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> array1 = [<span class=\"number\">1</span>, <span class=\"number\">3</span>,<span class=\"number\">6</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = array1.map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> x * <span class=\"number\">2</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// &gt; Array [2, 6, 12]</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用 map 重新格式化数组中的对象</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> oldArray = [&#123;<span class=\"attr\">key</span>: <span class=\"number\">1</span>, <span class=\"attr\">value</span>: <span class=\"number\">10</span>&#125;, </span><br><span class=\"line\">                &#123;<span class=\"attr\">key</span>: <span class=\"number\">2</span>, <span class=\"attr\">value</span>: <span class=\"number\">20</span>&#125;, </span><br><span class=\"line\">                &#123;<span class=\"attr\">key</span>: <span class=\"number\">3</span>, <span class=\"attr\">value</span>: <span class=\"number\">30</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> nowArr = oldArray.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123; </span><br><span class=\"line\">   <span class=\"keyword\">var</span> rObj = &#123;&#125;;</span><br><span class=\"line\">   rObj[obj.key] = obj.value;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> rObj;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// nowArr 数组为： [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;], </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// oldArray 数组未被修改: </span></span><br><span class=\"line\"><span class=\"comment\">// [&#123;key: 1, value: 10&#125;, </span></span><br><span class=\"line\"><span class=\"comment\">//  &#123;key: 2, value: 20&#125;, </span></span><br><span class=\"line\"><span class=\"comment\">//  &#123;key: 3, value: 30&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用ES5模拟实现ES6中的Map类\"><a href=\"#用ES5模拟实现ES6中的Map类\" class=\"headerlink\" title=\"用ES5模拟实现ES6中的Map类\"></a>用ES5模拟实现ES6中的Map类</h1><p>与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：<br>1.set(key,value):向字典中添加新元素。</p>\n<p>2.remove(key):使用键名从字典中移除相应的元素。</p>\n<p>3.has(key):如果某个键值存在于字典中，返回true，否则返回false。</p>\n<p>4.get(key):通过键名找到指定的值并返回。</p>\n<p>5.clear():清空字典。</p>\n<p>6.size():返回字典中元素个数。</p>\n<p>7.values():将字典所有值以数组形式返回。</p>\n<p>8.getItems():返回items变量，代表字典本身。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Map</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> items = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.has = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;    <span class=\"comment\">//has方法判断某个键值是否在字典中</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> key <span class=\"keyword\">in</span> items;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.set = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key,value</span>)</span>&#123;    <span class=\"comment\">//set方法为字典添加新元素或更新已有元素</span></span><br><span class=\"line\">        items[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.remove = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.has(key)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">delete</span> items[key];</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.get = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.has(key)?items[key]:<span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.values = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> values = [];</span><br><span class=\"line\">         <span class=\"comment\">//for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> k <span class=\"keyword\">in</span> items)&#123;   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">                values.push(items[k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> values;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.clear = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        items = &#123;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.size = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.Keys(items).length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.getItems = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> items;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"javascript垃圾回收机制","date":"2019-07-01T02:53:41.000Z","_content":"\n## 前言\n\n其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n};\n\nsetInterval(replaceThing,1000)\n\n```\n最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:\n1. 识别哪些对象需要被回收。\n2. 回收/重复使用需要被回收对象的内存。\n3. 压缩/整理内存(有些可能没有)\n\n而常见的识别对象是否需要回收的机制有下面几种:\n* 引用计数 (Python)\n* 逃逸分析 (Java)\n* Tracing/Reachable 追踪分析 (javascript)\n\n今天就主要看一下V8中GC的具体实现方式\n\n## Tracing/Reachable 追踪分析\nGC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。\n在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。\n\n\n## The Generational Hypothesis\nGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。\n这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。\n\n### Scavenger\nV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。\n\n![第一次GC](http://img.pandihai.com/03.svg)\n\n\n第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。\n\n![第二次GC](http://img.pandihai.com/04.svg)<center><font color=gray size=2>第二次GC</font></center>\n\n\n在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。\n\n#### Parallel\nParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。\n\n![Scavenger平行调度](http://img.pandihai.com/05.svg)<center><font color=gray size=2>Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center>\n\n### Major GC\nMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。\n\n#### Concurrent\nConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。\n\n![Major GC同步调度](http://img.pandihai.com/09.svg)<center><font color=gray size=2>Major GC同步调度</font></center>\n\n\n### 什么时候会执行GC\n在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。\n\n我们可以通过手动设置来设置新生代和老代的space大小:\n```js\n    node --max-old-space-size=1700 index.js\n    node --max-new-space-size=1024 index.js\n```\n\n\n#### 空闲时GC\n虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过[requestIdleCallback](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解[React 16 fiber的实现](https://www.youtube.com/watch?v=ZCuYPiUIONs))。\n\n![空闲时GC](http://img.pandihai.com/10.svg)<center><font color=gray size=2>利用主线程空闲时间进行GC</font></center>\n\n#### Incremental\n那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。\n\n![Incremental](http://img.pandihai.com/06.svg)<center><font color=gray size=2>将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center>\n\n### 总结\n不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。\n\n最后的最后将之前的内存泄漏代码一步步的推演:\n\n1. 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。\n2. 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,**闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的**,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。**另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量**,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。\n3. 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing->longStr(reachable),theThing->someMethod(reachable),execution stack -> setInterval -> closure -> originThing(reachable)。   \n所有标记完成。此时:\n```js\n          from-space                                to-space\n\n    theThing         (reachable)                theThing\n    replaceThing     (reachable)                replaceThing\n    unused                                      originThing\n    originThing      (reachable)       =>       longStr  \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n4. 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2\n5. 第二次GC开始\n\n```js\n          from-space                                to-space                           old-space\n\n    theThing         (reachable)                theThing                             originThing -> theThing\n    replaceThing     (reachable)                replaceThing                         theThing -> longStr\n    unused                                      originThing                          theThing -> someMethod\n    originThing      (reachable)       =>       longStr                    =>        someMethod -> originThing(closure)        \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n6. 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法\n\n```js\n         old-space\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n```\n\n#### 结论 \n主要导致内存泄漏的原因是\n\n![闭包是在声明的时候被创建的](http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png)<center><font color=gray size=2>闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center>\n\n然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。\n\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n\n  originalThing = null;    //手动释放局部作用域中的变量\n};\n\nsetInterval(replaceThing,1000)\n\n```\n","source":"_posts/javascript垃圾回收机制.md","raw":"---\nlayout: post\ntitle: javascript垃圾回收机制\ndate: 2019-07-01 10:53:41\ntags:\n---\n\n## 前言\n\n其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n};\n\nsetInterval(replaceThing,1000)\n\n```\n最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:\n1. 识别哪些对象需要被回收。\n2. 回收/重复使用需要被回收对象的内存。\n3. 压缩/整理内存(有些可能没有)\n\n而常见的识别对象是否需要回收的机制有下面几种:\n* 引用计数 (Python)\n* 逃逸分析 (Java)\n* Tracing/Reachable 追踪分析 (javascript)\n\n今天就主要看一下V8中GC的具体实现方式\n\n## Tracing/Reachable 追踪分析\nGC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。\n在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。\n\n\n## The Generational Hypothesis\nGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。\n这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。\n\n### Scavenger\nV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。\n\n![第一次GC](http://img.pandihai.com/03.svg)\n\n\n第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。\n\n![第二次GC](http://img.pandihai.com/04.svg)<center><font color=gray size=2>第二次GC</font></center>\n\n\n在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。\n\n#### Parallel\nParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。\n\n![Scavenger平行调度](http://img.pandihai.com/05.svg)<center><font color=gray size=2>Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center>\n\n### Major GC\nMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。\n\n#### Concurrent\nConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。\n\n![Major GC同步调度](http://img.pandihai.com/09.svg)<center><font color=gray size=2>Major GC同步调度</font></center>\n\n\n### 什么时候会执行GC\n在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。\n\n我们可以通过手动设置来设置新生代和老代的space大小:\n```js\n    node --max-old-space-size=1700 index.js\n    node --max-new-space-size=1024 index.js\n```\n\n\n#### 空闲时GC\n虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过[requestIdleCallback](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解[React 16 fiber的实现](https://www.youtube.com/watch?v=ZCuYPiUIONs))。\n\n![空闲时GC](http://img.pandihai.com/10.svg)<center><font color=gray size=2>利用主线程空闲时间进行GC</font></center>\n\n#### Incremental\n那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。\n\n![Incremental](http://img.pandihai.com/06.svg)<center><font color=gray size=2>将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center>\n\n### 总结\n不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。\n\n最后的最后将之前的内存泄漏代码一步步的推演:\n\n1. 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。\n2. 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,**闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的**,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。**另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量**,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。\n3. 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing->longStr(reachable),theThing->someMethod(reachable),execution stack -> setInterval -> closure -> originThing(reachable)。   \n所有标记完成。此时:\n```js\n          from-space                                to-space\n\n    theThing         (reachable)                theThing\n    replaceThing     (reachable)                replaceThing\n    unused                                      originThing\n    originThing      (reachable)       =>       longStr  \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n4. 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2\n5. 第二次GC开始\n\n```js\n          from-space                                to-space                           old-space\n\n    theThing         (reachable)                theThing                             originThing -> theThing\n    replaceThing     (reachable)                replaceThing                         theThing -> longStr\n    unused                                      originThing                          theThing -> someMethod\n    originThing      (reachable)       =>       longStr                    =>        someMethod -> originThing(closure)        \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n6. 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法\n\n```js\n         old-space\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n```\n\n#### 结论 \n主要导致内存泄漏的原因是\n\n![闭包是在声明的时候被创建的](http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png)<center><font color=gray size=2>闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center>\n\n然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。\n\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n\n  originalThing = null;    //手动释放局部作用域中的变量\n};\n\nsetInterval(replaceThing,1000)\n\n```\n","slug":"javascript垃圾回收机制","published":1,"updated":"2019-09-18T01:43:40.011Z","comments":1,"photos":[],"link":"","_id":"ck2ydufxq001t4sefe7medn0v","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>\n<ol>\n<li>识别哪些对象需要被回收。</li>\n<li>回收/重复使用需要被回收对象的内存。</li>\n<li>压缩/整理内存(有些可能没有)</li>\n</ol>\n<p>而常见的识别对象是否需要回收的机制有下面几种:</p>\n<ul>\n<li>引用计数 (Python)</li>\n<li>逃逸分析 (Java)</li>\n<li>Tracing/Reachable 追踪分析 (javascript)</li>\n</ul>\n<p>今天就主要看一下V8中GC的具体实现方式</p>\n<h2 id=\"Tracing-Reachable-追踪分析\"><a href=\"#Tracing-Reachable-追踪分析\" class=\"headerlink\" title=\"Tracing/Reachable 追踪分析\"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>\n<h2 id=\"The-Generational-Hypothesis\"><a href=\"#The-Generational-Hypothesis\" class=\"headerlink\" title=\"The Generational Hypothesis\"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>\n<h3 id=\"Scavenger\"><a href=\"#Scavenger\" class=\"headerlink\" title=\"Scavenger\"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>\n<p><img src=\"http://img.pandihai.com/03.svg\" alt=\"第一次GC\"></p>\n<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>\n<p><img src=\"http://img.pandihai.com/04.svg\" alt=\"第二次GC\"><center><font color=\"gray\" size=\"2\">第二次GC</font></center></p>\n<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>\n<h4 id=\"Parallel\"><a href=\"#Parallel\" class=\"headerlink\" title=\"Parallel\"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>\n<p><img src=\"http://img.pandihai.com/05.svg\" alt=\"Scavenger平行调度\"><center><font color=\"gray\" size=\"2\">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>\n<h4 id=\"Concurrent\"><a href=\"#Concurrent\" class=\"headerlink\" title=\"Concurrent\"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>\n<p><img src=\"http://img.pandihai.com/09.svg\" alt=\"Major GC同步调度\"><center><font color=\"gray\" size=\"2\">Major GC同步调度</font></center></p>\n<h3 id=\"什么时候会执行GC\"><a href=\"#什么时候会执行GC\" class=\"headerlink\" title=\"什么时候会执行GC\"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>\n<p>我们可以通过手动设置来设置新生代和老代的space大小:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-old-space-size=<span class=\"number\">1700</span> index.js</span><br><span class=\"line\">node --max-<span class=\"keyword\">new</span>-space-size=<span class=\"number\">1024</span> index.js</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"空闲时GC\"><a href=\"#空闲时GC\" class=\"headerlink\" title=\"空闲时GC\"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"noopener\">React 16 fiber的实现</a>)。</p>\n<p><img src=\"http://img.pandihai.com/10.svg\" alt=\"空闲时GC\"><center><font color=\"gray\" size=\"2\">利用主线程空闲时间进行GC</font></center></p>\n<h4 id=\"Incremental\"><a href=\"#Incremental\" class=\"headerlink\" title=\"Incremental\"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>\n<p><img src=\"http://img.pandihai.com/06.svg\" alt=\"Incremental\"><center><font color=\"gray\" size=\"2\">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>\n<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>\n<ol>\n<li><p>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</p>\n</li>\n<li><p>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</p>\n</li>\n<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing</span><br><span class=\"line\">unused                                      originThing</span><br><span class=\"line\">originThing      (reachable)       =&gt;       longStr  </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>\n</li>\n<li><p>第二次GC开始</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space                           old-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class=\"line\">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class=\"line\">originThing      (reachable)       =&gt;       <span class=\"function\"><span class=\"params\">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     old-space</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>主要导致内存泄漏的原因是</p>\n<p><img src=\"http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png\" alt=\"闭包是在声明的时候被创建的\"><center><font color=\"gray\" size=\"2\">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>\n<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>\n<ol>\n<li>识别哪些对象需要被回收。</li>\n<li>回收/重复使用需要被回收对象的内存。</li>\n<li>压缩/整理内存(有些可能没有)</li>\n</ol>\n<p>而常见的识别对象是否需要回收的机制有下面几种:</p>\n<ul>\n<li>引用计数 (Python)</li>\n<li>逃逸分析 (Java)</li>\n<li>Tracing/Reachable 追踪分析 (javascript)</li>\n</ul>\n<p>今天就主要看一下V8中GC的具体实现方式</p>\n<h2 id=\"Tracing-Reachable-追踪分析\"><a href=\"#Tracing-Reachable-追踪分析\" class=\"headerlink\" title=\"Tracing/Reachable 追踪分析\"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>\n<h2 id=\"The-Generational-Hypothesis\"><a href=\"#The-Generational-Hypothesis\" class=\"headerlink\" title=\"The Generational Hypothesis\"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>\n<h3 id=\"Scavenger\"><a href=\"#Scavenger\" class=\"headerlink\" title=\"Scavenger\"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>\n<p><img src=\"http://img.pandihai.com/03.svg\" alt=\"第一次GC\"></p>\n<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>\n<p><img src=\"http://img.pandihai.com/04.svg\" alt=\"第二次GC\"><center><font color=\"gray\" size=\"2\">第二次GC</font></center></p>\n<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>\n<h4 id=\"Parallel\"><a href=\"#Parallel\" class=\"headerlink\" title=\"Parallel\"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>\n<p><img src=\"http://img.pandihai.com/05.svg\" alt=\"Scavenger平行调度\"><center><font color=\"gray\" size=\"2\">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>\n<h4 id=\"Concurrent\"><a href=\"#Concurrent\" class=\"headerlink\" title=\"Concurrent\"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>\n<p><img src=\"http://img.pandihai.com/09.svg\" alt=\"Major GC同步调度\"><center><font color=\"gray\" size=\"2\">Major GC同步调度</font></center></p>\n<h3 id=\"什么时候会执行GC\"><a href=\"#什么时候会执行GC\" class=\"headerlink\" title=\"什么时候会执行GC\"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>\n<p>我们可以通过手动设置来设置新生代和老代的space大小:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-old-space-size=<span class=\"number\">1700</span> index.js</span><br><span class=\"line\">node --max-<span class=\"keyword\">new</span>-space-size=<span class=\"number\">1024</span> index.js</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"空闲时GC\"><a href=\"#空闲时GC\" class=\"headerlink\" title=\"空闲时GC\"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"noopener\">React 16 fiber的实现</a>)。</p>\n<p><img src=\"http://img.pandihai.com/10.svg\" alt=\"空闲时GC\"><center><font color=\"gray\" size=\"2\">利用主线程空闲时间进行GC</font></center></p>\n<h4 id=\"Incremental\"><a href=\"#Incremental\" class=\"headerlink\" title=\"Incremental\"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>\n<p><img src=\"http://img.pandihai.com/06.svg\" alt=\"Incremental\"><center><font color=\"gray\" size=\"2\">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>\n<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>\n<ol>\n<li><p>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</p>\n</li>\n<li><p>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</p>\n</li>\n<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing</span><br><span class=\"line\">unused                                      originThing</span><br><span class=\"line\">originThing      (reachable)       =&gt;       longStr  </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>\n</li>\n<li><p>第二次GC开始</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space                           old-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class=\"line\">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class=\"line\">originThing      (reachable)       =&gt;       <span class=\"function\"><span class=\"params\">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     old-space</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>主要导致内存泄漏的原因是</p>\n<p><img src=\"http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png\" alt=\"闭包是在声明的时候被创建的\"><center><font color=\"gray\" size=\"2\">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>\n<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"web前端常见的安全问题","date":"2019-11-12T05:59:13.000Z","author":"刘涛","_content":"\n## 前言\n在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？本文主要侧重于分析几种常见的攻击的类型以及防御的方法。\n\n## SQL注入\nSQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。\n\n### 1.SQL注入的原理\n我们先看看下面这个例子来说明其原理：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql1.png)\n\n\n```JavaScript\n<form action=\"/login\" method=\"POST\">\n    <p>Username: <input type=\"text\" name=\"username\" /></p>\n    <p>Password: <input type=\"password\" name=\"password\" /></p>\n    <p><input type=\"submit\" value=\"登陆\" /></p>\n</form>\n  ```\n后端的 SQL 语句可能是如下这样的：\n```JavaScript\nlet querySQL = `\n    SELECT *\n    FROM user\n    WHERE username='${username}'\n    AND psw='${password}'\n`;\n// 接下来就是执行 sql 语句...\n  ```\n这是我们经常见到的登录页面，但是如果有一个恶意的攻击者输入的用户名是admin' --，密码随意输入，就可以直接登入系统了。why! ----这就是SQL注入<br>\n我们之前预想的SQL 语句是:\n  SELECT * FROM user WHERE username='admin' AND psw='password' \n但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：\n  SELECT * FROM user WHERE username='admin' --' AND psw='xxxx'\n在 SQL 中,' --是闭合和注释的意思，-- 是注释后面的内容的意思，所以查询语句就变成了：\n  SELECT * FROM user WHERE username='admin'\n\n所谓的万能密码，本质上就是SQL注入的一种利用方式。\n一次SQL注入的过程包括以下几个过程：\n* 获取用户请求参数\n* 拼接到代码中\n* SQL语句按照我们构造参数的语义执行成功\n\n**SQL注入的必备条件**\n**1.可以控制输入的数据**\n**2.服务器要执行的代码拼接了控制的数据**\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql2.png)\n\n\n我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，**SQL注入的本质:数据和代码未分离，即数据当做了代码来执**行。\n\n### 2.危害\n1. 获取数据库信息\n  * 管理员后台用户名和密码\n  * 获取其它数据库敏感信息：用户名、密码、手机号、身份证、银行卡信息......\n  * 整个数据库：脱裤\n2. 获取服务器权限\n3. 植入Webshell，获取服务器后门\n4. 读取服务器敏感文件\n\n### 3.如何防御\n* **严格限制Web应用的数据库的操作权限，**给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害\n\n* **后端代码检查输入的数据是否符合预期，**严格限制变量的类型，例如使用正则表达式进行一些匹配处理。\n\n* **对进入数据库的特殊字符（'，\"，，<，>，&，*，; 等）进行转义处理，或编码转换。**基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。\n\n* **所有的查询语句建议使用数据库提供的参数化查询接口，**参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。\n\n\n\n## XSS\nXSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。\n\n跨站脚本攻击有可能造成以下影响:\n* 利用虚假输入表单骗取用户个人信息\n* 利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。\n* 显示伪造的文章或图片\n  **XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。**\n\n  XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。\n ### 1.非持久型 XSS（反射型 XSS ）###\n  非持久型 XSS 漏洞，一般是通过给别人发送**带有恶意脚本代码参数的 URL**，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。\n  ![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss1.png)\n\n\n  举一个例子，比如页面中包含有以下代码：\n``` html\n<select>\n    <script>\n        document.write(''\n            + '<option value=1>'\n            +     location.href.substring(location.href.indexOf('default=') + 8)\n            + '</option>'\n        );\n        document.write('<option value=2>English</option>');\n    </script>\n</select>\n  ```\n攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=<script>console.log(document.cookie)</script>) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。<br>\n非持久型 XSS 漏洞攻击有以下几点特征：\n* 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。\n* 攻击者需要诱骗点击,必须要通过用户点击链接才能发起。\n* 反馈率低，所以较难发现和响应修复。\n* 盗取用户敏感保密信息。\n\n为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：\n* Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。\n* 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。\n* 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。\n* 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。\n* 前端渲染的时候对任何的字段都需要做 escape 转义编码。\n\n\n### 2.持久型XSS(存储型XSS)###\n持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss2.png) \n\n举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss3.png) \n\n主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于**后端从数据库中读出来的数据** 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。\n攻击成功需要同时满足以下几个条件：\n  * POST请求提交表单后端没做转义直接入库。\n  * 后端从数据库中取出数据没做转义直接输出给前端。\n  * 前端拿到后端数据没做转义直接渲染成 DOM。\n\n持久型 XSS 有以下几个特点：\n\n  * 持久性，植入在数据库中\n  * 盗取用户敏感私密信息\n  * 危害面积广\n\n### 3.如何防御###\n对于 XSS 攻击来说，通常有两种方式可以用来防御。\n\n**1)CSP**\nCSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。\n通常可以通过两种方式来开启 CSP：\n* 设置 HTTP Header 中的 Content-Security-Policy\n* 设置 meta 标签的方式\n\n这里以设置 HTTP Header 来举例：\n* 只允许加载本站资源\nContent-Security-Policy: default-src 'self'\n\n* 只允许加载 HTTPS 协议图片\nContent-Security-Policy: img-src https://*\n\n* 允许加载任何来源框架\nContent-Security-Policy: child-src 'none'\n\n如需了解更多属性，请查看[Content-Security-Policy文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)\n对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。\n\n**2)转义字符**\n用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。\n``` javascript\nfunction escape(str) {\n  str = str.replace(/&/g, '&amp;')\n  str = str.replace(/</g, '&lt;')\n  str = str.replace(/>/g, '&gt;')\n  str = str.replace(/\"/g, '&quto;')\n  str = str.replace(/'/g, '&#39;')\n  str = str.replace(/`/g, '&#96;')\n  str = str.replace(/\\//g, '&#x2F;')\n  return str\n}\n```\n但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。\n``` javascript\nconst xss = require('xss')\nlet html = xss('<h1 id=\"title\">XSS Demo</h1><script>alert(\"xss\");</script>')\n// -> <h1>XSS Demo</h1>&lt;script&gt;alert(\"xss\");&lt;/script&gt;\nconsole.log(html)\n ```\n 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。\n\n **3) HttpOnly Cookie。**\n 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。\n\n\n ## CSRF ##\n CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。\n\n ### 1. CSRF攻击的原理 ###\n ![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf1.png) \n\n 完成 CSRF 攻击必须要有三个条件：\n * 用户已经登录了站点 A，并在本地记录了 cookie\n * 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。\n * 站点 A 没有做任何 CSRF 防御\n  \n  我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现\"XXX隐私照片，不看后悔一辈子\"的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。\n\n   ![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf2.png)\n\n### 2.如何防御 ### \n防范 CSRF 攻击可以遵循以下几种规则：\n* Get 请求不对数据进行修改\n* 不让第三方网站访问到用户 Cookie\n* 阻止第三方网站请求接口\n* 请求时附带验证信息，比如验证码或者 Token\n\n**1)SameSite**\n可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。\n\n**2)Referer Check**\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以**通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击**。\n\n但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。\n\n\n**3)Anti CSRF Token**\n目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。\n\n**这种方法相比Referer检查要安全很多**，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。\n\n\n**4)验证码**\n应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。**但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码**。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。\n","source":"_posts/web前端常见的安全问题.md","raw":"---\ntitle: web前端常见的安全问题\ndate: 2019-11-12 13:59:13\nauthor: 刘涛\ncategories: JavaScript\ntags:  \n---\n\n## 前言\n在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？本文主要侧重于分析几种常见的攻击的类型以及防御的方法。\n\n## SQL注入\nSQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。\n\n### 1.SQL注入的原理\n我们先看看下面这个例子来说明其原理：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql1.png)\n\n\n```JavaScript\n<form action=\"/login\" method=\"POST\">\n    <p>Username: <input type=\"text\" name=\"username\" /></p>\n    <p>Password: <input type=\"password\" name=\"password\" /></p>\n    <p><input type=\"submit\" value=\"登陆\" /></p>\n</form>\n  ```\n后端的 SQL 语句可能是如下这样的：\n```JavaScript\nlet querySQL = `\n    SELECT *\n    FROM user\n    WHERE username='${username}'\n    AND psw='${password}'\n`;\n// 接下来就是执行 sql 语句...\n  ```\n这是我们经常见到的登录页面，但是如果有一个恶意的攻击者输入的用户名是admin' --，密码随意输入，就可以直接登入系统了。why! ----这就是SQL注入<br>\n我们之前预想的SQL 语句是:\n  SELECT * FROM user WHERE username='admin' AND psw='password' \n但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：\n  SELECT * FROM user WHERE username='admin' --' AND psw='xxxx'\n在 SQL 中,' --是闭合和注释的意思，-- 是注释后面的内容的意思，所以查询语句就变成了：\n  SELECT * FROM user WHERE username='admin'\n\n所谓的万能密码，本质上就是SQL注入的一种利用方式。\n一次SQL注入的过程包括以下几个过程：\n* 获取用户请求参数\n* 拼接到代码中\n* SQL语句按照我们构造参数的语义执行成功\n\n**SQL注入的必备条件**\n**1.可以控制输入的数据**\n**2.服务器要执行的代码拼接了控制的数据**\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql2.png)\n\n\n我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，**SQL注入的本质:数据和代码未分离，即数据当做了代码来执**行。\n\n### 2.危害\n1. 获取数据库信息\n  * 管理员后台用户名和密码\n  * 获取其它数据库敏感信息：用户名、密码、手机号、身份证、银行卡信息......\n  * 整个数据库：脱裤\n2. 获取服务器权限\n3. 植入Webshell，获取服务器后门\n4. 读取服务器敏感文件\n\n### 3.如何防御\n* **严格限制Web应用的数据库的操作权限，**给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害\n\n* **后端代码检查输入的数据是否符合预期，**严格限制变量的类型，例如使用正则表达式进行一些匹配处理。\n\n* **对进入数据库的特殊字符（'，\"，，<，>，&，*，; 等）进行转义处理，或编码转换。**基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。\n\n* **所有的查询语句建议使用数据库提供的参数化查询接口，**参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。\n\n\n\n## XSS\nXSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。\n\n跨站脚本攻击有可能造成以下影响:\n* 利用虚假输入表单骗取用户个人信息\n* 利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。\n* 显示伪造的文章或图片\n  **XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。**\n\n  XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。\n ### 1.非持久型 XSS（反射型 XSS ）###\n  非持久型 XSS 漏洞，一般是通过给别人发送**带有恶意脚本代码参数的 URL**，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。\n  ![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss1.png)\n\n\n  举一个例子，比如页面中包含有以下代码：\n``` html\n<select>\n    <script>\n        document.write(''\n            + '<option value=1>'\n            +     location.href.substring(location.href.indexOf('default=') + 8)\n            + '</option>'\n        );\n        document.write('<option value=2>English</option>');\n    </script>\n</select>\n  ```\n攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=<script>console.log(document.cookie)</script>) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。<br>\n非持久型 XSS 漏洞攻击有以下几点特征：\n* 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。\n* 攻击者需要诱骗点击,必须要通过用户点击链接才能发起。\n* 反馈率低，所以较难发现和响应修复。\n* 盗取用户敏感保密信息。\n\n为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：\n* Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。\n* 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。\n* 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。\n* 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。\n* 前端渲染的时候对任何的字段都需要做 escape 转义编码。\n\n\n### 2.持久型XSS(存储型XSS)###\n持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss2.png) \n\n举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss3.png) \n\n主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于**后端从数据库中读出来的数据** 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。\n攻击成功需要同时满足以下几个条件：\n  * POST请求提交表单后端没做转义直接入库。\n  * 后端从数据库中取出数据没做转义直接输出给前端。\n  * 前端拿到后端数据没做转义直接渲染成 DOM。\n\n持久型 XSS 有以下几个特点：\n\n  * 持久性，植入在数据库中\n  * 盗取用户敏感私密信息\n  * 危害面积广\n\n### 3.如何防御###\n对于 XSS 攻击来说，通常有两种方式可以用来防御。\n\n**1)CSP**\nCSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。\n通常可以通过两种方式来开启 CSP：\n* 设置 HTTP Header 中的 Content-Security-Policy\n* 设置 meta 标签的方式\n\n这里以设置 HTTP Header 来举例：\n* 只允许加载本站资源\nContent-Security-Policy: default-src 'self'\n\n* 只允许加载 HTTPS 协议图片\nContent-Security-Policy: img-src https://*\n\n* 允许加载任何来源框架\nContent-Security-Policy: child-src 'none'\n\n如需了解更多属性，请查看[Content-Security-Policy文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)\n对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。\n\n**2)转义字符**\n用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。\n``` javascript\nfunction escape(str) {\n  str = str.replace(/&/g, '&amp;')\n  str = str.replace(/</g, '&lt;')\n  str = str.replace(/>/g, '&gt;')\n  str = str.replace(/\"/g, '&quto;')\n  str = str.replace(/'/g, '&#39;')\n  str = str.replace(/`/g, '&#96;')\n  str = str.replace(/\\//g, '&#x2F;')\n  return str\n}\n```\n但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。\n``` javascript\nconst xss = require('xss')\nlet html = xss('<h1 id=\"title\">XSS Demo</h1><script>alert(\"xss\");</script>')\n// -> <h1>XSS Demo</h1>&lt;script&gt;alert(\"xss\");&lt;/script&gt;\nconsole.log(html)\n ```\n 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。\n\n **3) HttpOnly Cookie。**\n 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。\n\n\n ## CSRF ##\n CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。\n\n ### 1. CSRF攻击的原理 ###\n ![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf1.png) \n\n 完成 CSRF 攻击必须要有三个条件：\n * 用户已经登录了站点 A，并在本地记录了 cookie\n * 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。\n * 站点 A 没有做任何 CSRF 防御\n  \n  我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现\"XXX隐私照片，不看后悔一辈子\"的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。\n\n   ![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf2.png)\n\n### 2.如何防御 ### \n防范 CSRF 攻击可以遵循以下几种规则：\n* Get 请求不对数据进行修改\n* 不让第三方网站访问到用户 Cookie\n* 阻止第三方网站请求接口\n* 请求时附带验证信息，比如验证码或者 Token\n\n**1)SameSite**\n可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。\n\n**2)Referer Check**\nHTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以**通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击**。\n\n但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。\n\n\n**3)Anti CSRF Token**\n目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。\n\n**这种方法相比Referer检查要安全很多**，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。\n\n\n**4)验证码**\n应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。**但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码**。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。\n","slug":"web前端常见的安全问题","published":1,"updated":"2019-11-13T05:36:52.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufxt001v4sefq94i7bcj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？本文主要侧重于分析几种常见的攻击的类型以及防御的方法。</p>\n<h2 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h2><p>SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。</p>\n<h3 id=\"1-SQL注入的原理\"><a href=\"#1-SQL注入的原理\" class=\"headerlink\" title=\"1.SQL注入的原理\"></a>1.SQL注入的原理</h3><p>我们先看看下面这个例子来说明其原理：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql1.png\" alt></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">\"/login\"</span> method=<span class=\"string\">\"POST\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;Username: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    &lt;p&gt;Password: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    &lt;p&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"登陆\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/form&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>后端的 SQL 语句可能是如下这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> querySQL = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    SELECT *</span></span><br><span class=\"line\"><span class=\"string\">    FROM user</span></span><br><span class=\"line\"><span class=\"string\">    WHERE username='<span class=\"subst\">$&#123;username&#125;</span>'</span></span><br><span class=\"line\"><span class=\"string\">    AND psw='<span class=\"subst\">$&#123;password&#125;</span>'</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"><span class=\"comment\">// 接下来就是执行 sql 语句...</span></span><br></pre></td></tr></table></figure>\n\n<p>这是我们经常见到的登录页面，但是如果有一个恶意的攻击者输入的用户名是admin’ –，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入<br><br>我们之前预想的SQL 语句是:<br>  SELECT * FROM user WHERE username=’admin’ AND psw=’password’<br>但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：<br>  SELECT * FROM user WHERE username=’admin’ –’ AND psw=’xxxx’<br>在 SQL 中,’ –是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了：<br>  SELECT * FROM user WHERE username=’admin’</p>\n<p>所谓的万能密码，本质上就是SQL注入的一种利用方式。<br>一次SQL注入的过程包括以下几个过程：</p>\n<ul>\n<li>获取用户请求参数</li>\n<li>拼接到代码中</li>\n<li>SQL语句按照我们构造参数的语义执行成功</li>\n</ul>\n<p><strong>SQL注入的必备条件</strong><br><strong>1.可以控制输入的数据</strong><br><strong>2.服务器要执行的代码拼接了控制的数据</strong><br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql2.png\" alt></p>\n<p>我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，<strong>SQL注入的本质:数据和代码未分离，即数据当做了代码来执</strong>行。</p>\n<h3 id=\"2-危害\"><a href=\"#2-危害\" class=\"headerlink\" title=\"2.危害\"></a>2.危害</h3><ol>\n<li>获取数据库信息<ul>\n<li>管理员后台用户名和密码</li>\n<li>获取其它数据库敏感信息：用户名、密码、手机号、身份证、银行卡信息……</li>\n<li>整个数据库：脱裤</li>\n</ul>\n</li>\n<li>获取服务器权限</li>\n<li>植入Webshell，获取服务器后门</li>\n<li>读取服务器敏感文件</li>\n</ol>\n<h3 id=\"3-如何防御\"><a href=\"#3-如何防御\" class=\"headerlink\" title=\"3.如何防御\"></a>3.如何防御</h3><ul>\n<li><p><strong>严格限制Web应用的数据库的操作权限，</strong>给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>\n</li>\n<li><p><strong>后端代码检查输入的数据是否符合预期，</strong>严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>\n</li>\n<li><p><strong>对进入数据库的特殊字符（’，”，，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。</strong>基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。</p>\n</li>\n<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口，</strong>参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。</p>\n</li>\n</ul>\n<h2 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h2><p>XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。</p>\n<p>跨站脚本攻击有可能造成以下影响:</p>\n<ul>\n<li><p>利用虚假输入表单骗取用户个人信息</p>\n</li>\n<li><p>利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</p>\n</li>\n<li><p>显示伪造的文章或图片<br><strong>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</strong></p>\n<p>XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>\n<h3 id=\"1-非持久型-XSS（反射型-XSS-）\"><a href=\"#1-非持久型-XSS（反射型-XSS-）\" class=\"headerlink\" title=\"1.非持久型 XSS（反射型 XSS ）\"></a>1.非持久型 XSS（反射型 XSS ）</h3><p>非持久型 XSS 漏洞，一般是通过给别人发送<strong>带有恶意脚本代码参数的 URL</strong>，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss1.png\" alt></p>\n</li>\n</ul>\n<p>  举一个例子，比如页面中包含有以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.write(<span class=\"string\">''</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">            + '<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">1</span>&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">            +     location.href.substring(location.href.indexOf(<span class=\"string\">'default='</span>) + <span class=\"number\">8</span>)</span></span><br><span class=\"line\"><span class=\"actionscript\">            + <span class=\"string\">'&lt;/option&gt;'</span></span></span><br><span class=\"line\">        );</span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">        document.write('<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">2</span>&gt;</span>English<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>');</span></span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>攻击者可以直接通过 URL (类似：<a href=\"https://xxx.com/xxx?default=\" target=\"_blank\" rel=\"noopener\">https://xxx.com/xxx?default=</a><script>console.log(document.cookie)</script>) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。<br><br>非持久型 XSS 漏洞攻击有以下几点特征：</p>\n<ul>\n<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>\n<li>攻击者需要诱骗点击,必须要通过用户点击链接才能发起。</li>\n<li>反馈率低，所以较难发现和响应修复。</li>\n<li>盗取用户敏感保密信息。</li>\n</ul>\n<p>为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：</p>\n<ul>\n<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>\n<li>尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。</li>\n<li>尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。</li>\n<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>\n<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>\n</ul>\n<h3 id=\"2-持久型XSS-存储型XSS\"><a href=\"#2-持久型XSS-存储型XSS\" class=\"headerlink\" title=\"2.持久型XSS(存储型XSS)\"></a>2.持久型XSS(存储型XSS)</h3><p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss2.png\" alt> </p>\n<p>举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss3.png\" alt> </p>\n<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于<strong>后端从数据库中读出来的数据</strong> 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。<br>攻击成功需要同时满足以下几个条件：</p>\n<ul>\n<li>POST请求提交表单后端没做转义直接入库。</li>\n<li>后端从数据库中取出数据没做转义直接输出给前端。</li>\n<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>\n</ul>\n<p>持久型 XSS 有以下几个特点：</p>\n<ul>\n<li>持久性，植入在数据库中</li>\n<li>盗取用户敏感私密信息</li>\n<li>危害面积广</li>\n</ul>\n<h3 id=\"3-如何防御-1\"><a href=\"#3-如何防御-1\" class=\"headerlink\" title=\"3.如何防御\"></a>3.如何防御</h3><p>对于 XSS 攻击来说，通常有两种方式可以用来防御。</p>\n<p><strong>1)CSP</strong><br>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。<br>通常可以通过两种方式来开启 CSP：</p>\n<ul>\n<li>设置 HTTP Header 中的 Content-Security-Policy</li>\n<li>设置 meta 标签的方式</li>\n</ul>\n<p>这里以设置 HTTP Header 来举例：</p>\n<ul>\n<li><p>只允许加载本站资源<br>Content-Security-Policy: default-src ‘self’</p>\n</li>\n<li><p>只允许加载 HTTPS 协议图片<br>Content-Security-Policy: img-src https://*</p>\n</li>\n<li><p>允许加载任何来源框架<br>Content-Security-Policy: child-src ‘none’</p>\n</li>\n</ul>\n<p>如需了解更多属性，请查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\" target=\"_blank\" rel=\"noopener\">Content-Security-Policy文档</a><br>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。</p>\n<p><strong>2)转义字符</strong><br>用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/&amp;/g</span>, <span class=\"string\">'&amp;amp;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/&lt;/g</span>, <span class=\"string\">'&amp;lt;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/&gt;/g</span>, <span class=\"string\">'&amp;gt;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/\"/g</span>, <span class=\"string\">'&amp;quto;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/'/g</span>, <span class=\"string\">'&amp;#39;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/`/g</span>, <span class=\"string\">'&amp;#96;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/\\//g</span>, <span class=\"string\">'&amp;#x2F;'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xss = <span class=\"built_in\">require</span>(<span class=\"string\">'xss'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> html = xss(<span class=\"string\">'&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;'</span>)</span><br><span class=\"line\"><span class=\"comment\">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(html)</span><br></pre></td></tr></table></figure>\n\n<p> 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。</p>\n<p> <strong>3) HttpOnly Cookie。</strong><br> 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。</p>\n<h2 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h2><p> CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p>\n<h3 id=\"1-CSRF攻击的原理\"><a href=\"#1-CSRF攻击的原理\" class=\"headerlink\" title=\"1. CSRF攻击的原理\"></a>1. CSRF攻击的原理</h3><p> <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf1.png\" alt> </p>\n<p> 完成 CSRF 攻击必须要有三个条件：</p>\n<ul>\n<li><p>用户已经登录了站点 A，并在本地记录了 cookie</p>\n</li>\n<li><p>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</p>\n</li>\n<li><p>站点 A 没有做任何 CSRF 防御</p>\n<p>我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf2.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"2-如何防御\"><a href=\"#2-如何防御\" class=\"headerlink\" title=\"2.如何防御\"></a>2.如何防御</h3><p>防范 CSRF 攻击可以遵循以下几种规则：</p>\n<ul>\n<li>Get 请求不对数据进行修改</li>\n<li>不让第三方网站访问到用户 Cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>请求时附带验证信息，比如验证码或者 Token</li>\n</ul>\n<p><strong>1)SameSite</strong><br>可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>\n<p><strong>2)Referer Check</strong><br>HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以<strong>通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击</strong>。</p>\n<p>但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。</p>\n<p><strong>3)Anti CSRF Token</strong><br>目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>\n<p><strong>这种方法相比Referer检查要安全很多</strong>，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。</p>\n<p><strong>4)验证码</strong><br>应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。<strong>但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码</strong>。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？本文主要侧重于分析几种常见的攻击的类型以及防御的方法。</p>\n<h2 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h2><p>SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。</p>\n<h3 id=\"1-SQL注入的原理\"><a href=\"#1-SQL注入的原理\" class=\"headerlink\" title=\"1.SQL注入的原理\"></a>1.SQL注入的原理</h3><p>我们先看看下面这个例子来说明其原理：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql1.png\" alt></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;form action=<span class=\"string\">\"/login\"</span> method=<span class=\"string\">\"POST\"</span>&gt;</span><br><span class=\"line\">    &lt;p&gt;Username: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    &lt;p&gt;Password: <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">    &lt;p&gt;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"登陆\"</span> /&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/form&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>后端的 SQL 语句可能是如下这样的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> querySQL = <span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">    SELECT *</span></span><br><span class=\"line\"><span class=\"string\">    FROM user</span></span><br><span class=\"line\"><span class=\"string\">    WHERE username='<span class=\"subst\">$&#123;username&#125;</span>'</span></span><br><span class=\"line\"><span class=\"string\">    AND psw='<span class=\"subst\">$&#123;password&#125;</span>'</span></span><br><span class=\"line\"><span class=\"string\">`</span>;</span><br><span class=\"line\"><span class=\"comment\">// 接下来就是执行 sql 语句...</span></span><br></pre></td></tr></table></figure>\n\n<p>这是我们经常见到的登录页面，但是如果有一个恶意的攻击者输入的用户名是admin’ –，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入<br><br>我们之前预想的SQL 语句是:<br>  SELECT * FROM user WHERE username=’admin’ AND psw=’password’<br>但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式：<br>  SELECT * FROM user WHERE username=’admin’ –’ AND psw=’xxxx’<br>在 SQL 中,’ –是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了：<br>  SELECT * FROM user WHERE username=’admin’</p>\n<p>所谓的万能密码，本质上就是SQL注入的一种利用方式。<br>一次SQL注入的过程包括以下几个过程：</p>\n<ul>\n<li>获取用户请求参数</li>\n<li>拼接到代码中</li>\n<li>SQL语句按照我们构造参数的语义执行成功</li>\n</ul>\n<p><strong>SQL注入的必备条件</strong><br><strong>1.可以控制输入的数据</strong><br><strong>2.服务器要执行的代码拼接了控制的数据</strong><br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/sql2.png\" alt></p>\n<p>我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，<strong>SQL注入的本质:数据和代码未分离，即数据当做了代码来执</strong>行。</p>\n<h3 id=\"2-危害\"><a href=\"#2-危害\" class=\"headerlink\" title=\"2.危害\"></a>2.危害</h3><ol>\n<li>获取数据库信息<ul>\n<li>管理员后台用户名和密码</li>\n<li>获取其它数据库敏感信息：用户名、密码、手机号、身份证、银行卡信息……</li>\n<li>整个数据库：脱裤</li>\n</ul>\n</li>\n<li>获取服务器权限</li>\n<li>植入Webshell，获取服务器后门</li>\n<li>读取服务器敏感文件</li>\n</ol>\n<h3 id=\"3-如何防御\"><a href=\"#3-如何防御\" class=\"headerlink\" title=\"3.如何防御\"></a>3.如何防御</h3><ul>\n<li><p><strong>严格限制Web应用的数据库的操作权限，</strong>给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害</p>\n</li>\n<li><p><strong>后端代码检查输入的数据是否符合预期，</strong>严格限制变量的类型，例如使用正则表达式进行一些匹配处理。</p>\n</li>\n<li><p><strong>对进入数据库的特殊字符（’，”，，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。</strong>基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。</p>\n</li>\n<li><p><strong>所有的查询语句建议使用数据库提供的参数化查询接口，</strong>参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。</p>\n</li>\n</ul>\n<h2 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h2><p>XSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。</p>\n<p>跨站脚本攻击有可能造成以下影响:</p>\n<ul>\n<li><p>利用虚假输入表单骗取用户个人信息</p>\n</li>\n<li><p>利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。</p>\n</li>\n<li><p>显示伪造的文章或图片<br><strong>XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。</strong></p>\n<p>XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。</p>\n<h3 id=\"1-非持久型-XSS（反射型-XSS-）\"><a href=\"#1-非持久型-XSS（反射型-XSS-）\" class=\"headerlink\" title=\"1.非持久型 XSS（反射型 XSS ）\"></a>1.非持久型 XSS（反射型 XSS ）</h3><p>非持久型 XSS 漏洞，一般是通过给别人发送<strong>带有恶意脚本代码参数的 URL</strong>，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss1.png\" alt></p>\n</li>\n</ul>\n<p>  举一个例子，比如页面中包含有以下代码：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\">        <span class=\"built_in\">document</span>.write(<span class=\"string\">''</span></span></span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">            + '<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">1</span>&gt;</span>'</span></span></span><br><span class=\"line\"><span class=\"actionscript\">            +     location.href.substring(location.href.indexOf(<span class=\"string\">'default='</span>) + <span class=\"number\">8</span>)</span></span><br><span class=\"line\"><span class=\"actionscript\">            + <span class=\"string\">'&lt;/option&gt;'</span></span></span><br><span class=\"line\">        );</span><br><span class=\"line\"><span class=\"handlebars\"><span class=\"xml\">        document.write('<span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">2</span>&gt;</span>English<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span>');</span></span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>攻击者可以直接通过 URL (类似：<a href=\"https://xxx.com/xxx?default=\" target=\"_blank\" rel=\"noopener\">https://xxx.com/xxx?default=</a><script>console.log(document.cookie)</script>) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。<br><br>非持久型 XSS 漏洞攻击有以下几点特征：</p>\n<ul>\n<li>即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。</li>\n<li>攻击者需要诱骗点击,必须要通过用户点击链接才能发起。</li>\n<li>反馈率低，所以较难发现和响应修复。</li>\n<li>盗取用户敏感保密信息。</li>\n</ul>\n<p>为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情：</p>\n<ul>\n<li>Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。</li>\n<li>尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。</li>\n<li>尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。</li>\n<li>如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。</li>\n<li>前端渲染的时候对任何的字段都需要做 escape 转义编码。</li>\n</ul>\n<h3 id=\"2-持久型XSS-存储型XSS\"><a href=\"#2-持久型XSS-存储型XSS\" class=\"headerlink\" title=\"2.持久型XSS(存储型XSS)\"></a>2.持久型XSS(存储型XSS)</h3><p>持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss2.png\" alt> </p>\n<p>举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/xss3.png\" alt> </p>\n<p>主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于<strong>后端从数据库中读出来的数据</strong> 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。<br>攻击成功需要同时满足以下几个条件：</p>\n<ul>\n<li>POST请求提交表单后端没做转义直接入库。</li>\n<li>后端从数据库中取出数据没做转义直接输出给前端。</li>\n<li>前端拿到后端数据没做转义直接渲染成 DOM。</li>\n</ul>\n<p>持久型 XSS 有以下几个特点：</p>\n<ul>\n<li>持久性，植入在数据库中</li>\n<li>盗取用户敏感私密信息</li>\n<li>危害面积广</li>\n</ul>\n<h3 id=\"3-如何防御-1\"><a href=\"#3-如何防御-1\" class=\"headerlink\" title=\"3.如何防御\"></a>3.如何防御</h3><p>对于 XSS 攻击来说，通常有两种方式可以用来防御。</p>\n<p><strong>1)CSP</strong><br>CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。<br>通常可以通过两种方式来开启 CSP：</p>\n<ul>\n<li>设置 HTTP Header 中的 Content-Security-Policy</li>\n<li>设置 meta 标签的方式</li>\n</ul>\n<p>这里以设置 HTTP Header 来举例：</p>\n<ul>\n<li><p>只允许加载本站资源<br>Content-Security-Policy: default-src ‘self’</p>\n</li>\n<li><p>只允许加载 HTTPS 协议图片<br>Content-Security-Policy: img-src https://*</p>\n</li>\n<li><p>允许加载任何来源框架<br>Content-Security-Policy: child-src ‘none’</p>\n</li>\n</ul>\n<p>如需了解更多属性，请查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\" target=\"_blank\" rel=\"noopener\">Content-Security-Policy文档</a><br>对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。</p>\n<p><strong>2)转义字符</strong><br>用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">escape</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/&amp;/g</span>, <span class=\"string\">'&amp;amp;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/&lt;/g</span>, <span class=\"string\">'&amp;lt;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/&gt;/g</span>, <span class=\"string\">'&amp;gt;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/\"/g</span>, <span class=\"string\">'&amp;quto;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/'/g</span>, <span class=\"string\">'&amp;#39;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/`/g</span>, <span class=\"string\">'&amp;#96;'</span>)</span><br><span class=\"line\">  str = str.replace(<span class=\"regexp\">/\\//g</span>, <span class=\"string\">'&amp;#x2F;'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> str</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xss = <span class=\"built_in\">require</span>(<span class=\"string\">'xss'</span>)</span><br><span class=\"line\"><span class=\"keyword\">let</span> html = xss(<span class=\"string\">'&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;'</span>)</span><br><span class=\"line\"><span class=\"comment\">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(html)</span><br></pre></td></tr></table></figure>\n\n<p> 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。</p>\n<p> <strong>3) HttpOnly Cookie。</strong><br> 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。</p>\n<h2 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h2><p> CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。</p>\n<h3 id=\"1-CSRF攻击的原理\"><a href=\"#1-CSRF攻击的原理\" class=\"headerlink\" title=\"1. CSRF攻击的原理\"></a>1. CSRF攻击的原理</h3><p> <img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf1.png\" alt> </p>\n<p> 完成 CSRF 攻击必须要有三个条件：</p>\n<ul>\n<li><p>用户已经登录了站点 A，并在本地记录了 cookie</p>\n</li>\n<li><p>在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。</p>\n</li>\n<li><p>站点 A 没有做任何 CSRF 防御</p>\n<p>我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/web%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/csrf2.png\" alt></p>\n</li>\n</ul>\n<h3 id=\"2-如何防御\"><a href=\"#2-如何防御\" class=\"headerlink\" title=\"2.如何防御\"></a>2.如何防御</h3><p>防范 CSRF 攻击可以遵循以下几种规则：</p>\n<ul>\n<li>Get 请求不对数据进行修改</li>\n<li>不让第三方网站访问到用户 Cookie</li>\n<li>阻止第三方网站请求接口</li>\n<li>请求时附带验证信息，比如验证码或者 Token</li>\n</ul>\n<p><strong>1)SameSite</strong><br>可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。</p>\n<p><strong>2)Referer Check</strong><br>HTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以<strong>通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击</strong>。</p>\n<p>但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。</p>\n<p><strong>3)Anti CSRF Token</strong><br>目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。</p>\n<p><strong>这种方法相比Referer检查要安全很多</strong>，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。</p>\n<p><strong>4)验证码</strong><br>应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。<strong>但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码</strong>。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。</p>\n"},{"title":"前端性能优化一:性能指标","date":"2019-09-16T02:27:35.000Z","_content":"\n\n\n如果我们想要提高我们的前端性能,那么首先你得先只知道怎么测量你的前端性能。但是哪些前端的性能指标我们应该关注呢?\n在Web1.0时代当我们讨论到前端性能指标用的最多的就是`page load time`。到了单页应用程序越来越多的时代,单一的`page load time`指标已经无法完全衡量前端性能了,因为一个单页应用程序`page load time`可能只触发了一次,但是用户会跟程序有很多的交互,每一个交互或者动作都需要有指标来衡量他的性能。\n\n接下来就介绍几个比较重要的前端性能指标:\n*  first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间\n*  first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas.\n\n这两个指标对用户来说都是很重要的,这两个指标可以认为我们程序正在告诉我们的用户:我们正在正确工作。\n* First meaningful paint (FMP):这个指标标志着首屏最重要的一块区域的渲染,通常是用户最关注的区域。比如视频网站的视频播放区域,搜索网站的第一个搜索结果区域,又或者是购物网站的照片首图。通常来说浏览器很难清楚的了解哪一块是对于网站首屏来说是最关键的,所以开发者自己来告诉浏览器是哪一块是关键区域是很有必要的。\n\n这也是非常关键的一个指标,通常如果用户能够快速的看到最重要的一块区域被渲染完成,即使其他的区域都还没有被渲染用户可能也不会注意到。\n\n* long task:我们都知道浏览器是单线程的在响应用户的操作时通过在任务队列里面增加任务,然后一个个的执行的.这意味着如果我们有一个长任务需要使用较长的时间,那么队列中的其他任务就只能等待,响应用户的操作就会变慢,或者动画就会变卡顿。\n* Time to interactive (TTI):这个指标表示浏览器已经渲染完了我们首屏需要显示的内容并且已经准备好接受用户的交互信息了,也标志着程序是否可用。程序暂时无法响应用户的交互有下面几个原因:\n  * 需要执行的javascript还没有执行完成。\n  * 有长任务阻绝着主线程.无法给用户响应。\n\n\n|指标|介绍|  \n|------|---|\nfirst paint (FP)/first contentful paint (FCP) | 程序是否正确的开始渲染\nFirst meaningful paint (FMP) | 用户最关注的的首屏内容显示\nTime to interactive (TTI) | 程序是否可用\nlong task|程序使用的体验(是否响应延迟,动画卡顿)\n\n还有一些其他的指标比如 First Input Delay(首次接受用户响应的延迟时间) First CPU Idle(第一次CPU闲置的时间):这些指标都和上面的指标有着直接的关系。\n\n### 用户体验\n知道了这些指标,我们要把这些指标控制在什么样的时间才能给用户带来比较好的用户的体验呢,下面有这样一张表\n\n|时间|介绍|  \n|--------|---|\n|0到16ms|用户希望看的动画能够流畅,动画卡顿会带来非常差的用户体验,在浏览器上每秒钟渲染60帧动画就能够保持流畅,这大约就是16ms渲染一帧，这16ms包括了浏览器要渲染新的元素到页面上需要的时间，也就是说程序有大约10ms的时间可以进行操作。|\n|0到100ms|在这个时间内响应用户的交互,用户会觉得响应是非常及时的|\n|100到300ms|用户会感觉到有一些延迟|\n|300到1000ms|当执行一些页面加载或者页面跳转的时候,在这个时间内是一个正常的加载跳转时间|\n|1000ms或以上|超过1000ms(1秒),用户会对之前的操作渐渐失去耐心和注意力|\n|10000ms或以上|当你的响应超过10秒,用户会感到烦躁,然后终止之前操作|\n\n上面的延迟时间取决于你使用什么样的网络和设备,比如你使用的电脑和wifi网络,用户在1000ms是一个比较现实的目标。但是当你设备是手机网络只有3G的时候在5000ms内加载才是更现实的目标。\n\n#### 响应时间:处理响应用户的操作在50ms以内\n在大多数的时间里，用户在使用程序时大多数的时间都在等待网站响应他们的操作比如点击一个按钮,在文本框中输入内容,而不是等待网站加载。那么网站比较理想的响应用户时间是在100ms以内。\n\n##### 100ms?不是50ms吗?\n我们的目标是在100ms以内响应用户的操作,那为什么处理用户的响应时间只有50ms?因为在我们接受到用户的输入时,可能会有别的任务正在执行.比如我们接受到用户在文本框中输入了一个A,这个时候浏览器正在执行别的任务,浏览器会把这个操作先加入到任务队列里,等浏览器执行完之前的任务才会去处理用户的响应。那么保守的估计为了让用户在100ms以内获得响应,我们的处理用户响应的执行时间就是50ms。\n![响应时间](http://img.pandihai.com/rail-response-details.png)\n\n#### 动画:生产每一帧动画的时间在10ms左右\n理论上来说只要没16ms渲染一帧,动画就会看起来是流畅的,但是浏览器大约需要6ms的时间来将每一帧渲染到画面上.因此产生每一帧动画的时间留给程序的大约就10ms左右。\n\n#### 主线程闲置时间越多越好\n主线程能够有尽可能多的闲置时间,那么当产生用户交互时就可以立马给用户响应。当主线程闲置时,浏览器会有很多的内部程序需要执行,比如闲置GC等。\n\n#### 主要内容渲染完成且程序可交互时间在5秒之内\n当页面加载缓慢,用户会失去耐心。网站的加载和响应速度直接影响用户的体验。\n\n### 如何测试这些指标\n#### 使用测试工具或者网站\n* Chrome DevTools-Audits\n* [WebPageTest](https://webpagetest.org/easy)\n\n#### 在真实的用户环境获得这些指标\n在介绍如何在用户真实环境中或者这些指标之前先介绍一些API\n* [performance.mark](https://www.w3.org/TR/user-timing/#dom-performance-mark):创建给定标记的一个timestamp。\n* [performance.measure](https://www.w3.org/TR/user-timing/#dom-performance-measure):两个mark之间所经历的时间\n* [PerformanceObserver](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver):PerformanceObserver接口用于监控性能,可以根据传入的[监控事件](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType)返回对应的[PerformanceEntry](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry)对象。\n\n##### 获得FP/FCP\n```js\nconst observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      //这里的name是为了区分'first-paint','first-contentful-paint'\n      const metricName = entry.name;\n      const time = Math.round(entry.startTime + entry.duration);\n      reportToServer({\n        eventCategory: 'Performance Metrics',\n        eventAction: metricName,\n        eventValue: time,\n        nonInteraction: true,\n      });\n    }\n  });\n  observer.observe({entryTypes: ['paint']});\n```\n##### 根据你首屏最重要的元素获得FMP\n之前已经介绍过对于浏览器来说很那准确的知道每个网站对重要的一块区域显示的时间,那么只有开发者自己能够准确的找到最重要的一块区域获得FMP,假设我们网站首屏最重要的元素是一个图片就可以这么写.\n```js\n<img src=\"important.jpg\" onload=\"performance.clearMarks('img displayed'); performance.mark('img displayed');\">\n<script>\nperformance.clearMarks(\"img displayed\");\nperformance.mark(\"img displayed\");\n</script>\n```\n##### 获得TTI\n目前在PerformanceObserver中还没有办法获得TTI的接口,通过这个[tti-polyfill](https://github.com/GoogleChromeLabs/tti-polyfill)可以知道这个tti\n```js\nimport ttiPolyfill from 'tti-polyfill.js';\n\nttiPolyfill.getFirstConsistentlyInteractive().then((tti) => {\n  reportToServer({\n    eventCategory: 'Performance Metrics',\n    eventAction: 'TTI',\n    eventValue: tti,\n    nonInteraction: true,\n  });\n});\n```\n\n##### 监视长任务\n之前提到过,长任务可能会影响浏览器对用户响应速度或者造成动画的卡顿.那么能意识到长任务的存在并且把他缩短是很有必要的。(长任务API认为50ms以上任务的为长任务)\n```js\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    reportToServer({\n      eventCategory: 'Performance Metrics',\n      eventAction: 'longtask',\n      eventValue: Math.round(entry.startTime + entry.duration),\n      //这里的长任务会包含一个attribute\n      //https://w3c.github.io/longtasks/#sec-TaskAttributionTiming\n      eventLabel: JSON.stringify(entry.attribution),\n    });\n  }\n});\n\nobserver.observe({entryTypes: ['longtask']});\n```\n\n##### 监视响应延迟\n长任务会阻塞线程导致浏览器无法响应用户操作,之前也提到过如果能在100ms以内响应用户的操作就不会让用户觉得卡顿,那么如果能够监控到你关键交互的响应时间也是很有必要的\n```js\nconst submitBtn = document.querySelector('#submit');\n\nsubmitBtn.addEventListener('click', (event) => {\n  const lag = performance.now() - event.timeStamp;\n  if (lag > 100) {\n    reportToServer({\n      eventCategory: 'Performance Metric'\n      eventAction: 'input-latency',\n      eventLabel: '#subscribe:click',\n      eventValue: Math.round(lag),\n      nonInteraction: true,\n    });\n  }\n});\n```\n\n##### 幸存者偏差\n当我们的程序如果加载速度很慢(比如加载了过多的js),那么真实用户在网络环境不一致的情况下,有些响应过慢的用户可能早早的在加载完成前就已经退出网站,那么这里就会有一个幸存者偏差的问题.你监控的用户都是已经加载完成的用户。为了能够同时检测到退出的用户.\n```js\n///写在最头部\nwindow.__trackAbandons = () => {\n  // 去掉事件监听那么这个方法只执行一次\n  document.removeEventListener('visibilitychange', window.__trackAbandons);\n  //因为我们还没有加载report js API 所以我们要让服务器提供一个post接口在接收这次请求\n  const ANALYTICS_URL = 'https://ANALYTICS_URL';\n  const TRACKING_ID = 'TRACKING_ID';\n  const CLIENT_ID = (Math.random() * Math.pow(2, 52));\n\n  // Send the data to Google Analytics via the Measurement Protocol.\n  navigator.sendBeacon && navigator.sendBeacon(ANALYTICS_URL, [\n    'v=1', 't=event', 'ec=Load', 'ea=abandon', 'ni=1',\n    'dl=' + encodeURIComponent(location.href),\n    'dt=' + encodeURIComponent(document.title),\n    'tid=' + TRACKING_ID,\n    'cid=' + CLIENT_ID,\n    'ev=' + Math.round(performance.now()),\n  ].join('&'));\n};\n//visibilitychange可以监听页面unload事件\n//https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event\ndocument.addEventListener('visibilitychange', window.__trackAbandons);\n```\n\n### 结论\n性能对现在的程序越来越重要,那么在一个程序需要进行性能优化的时候.个人认为可以按照这样的一个顺序进行:\n\n数据收集->讨论性能指标阀值->针对性能优化->数据重新验证优化结果\n\n这里主要讨论了我们一些性能指标和收集性能指标的方法,后面会讨论如何针对每一块进行优化。","source":"_posts/前端性能优化一-性能指标.md","raw":"---\ntitle: '前端性能优化一:性能指标'\ndate: 2019-09-16 10:27:35\ntags:\n---\n\n\n\n如果我们想要提高我们的前端性能,那么首先你得先只知道怎么测量你的前端性能。但是哪些前端的性能指标我们应该关注呢?\n在Web1.0时代当我们讨论到前端性能指标用的最多的就是`page load time`。到了单页应用程序越来越多的时代,单一的`page load time`指标已经无法完全衡量前端性能了,因为一个单页应用程序`page load time`可能只触发了一次,但是用户会跟程序有很多的交互,每一个交互或者动作都需要有指标来衡量他的性能。\n\n接下来就介绍几个比较重要的前端性能指标:\n*  first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间\n*  first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas.\n\n这两个指标对用户来说都是很重要的,这两个指标可以认为我们程序正在告诉我们的用户:我们正在正确工作。\n* First meaningful paint (FMP):这个指标标志着首屏最重要的一块区域的渲染,通常是用户最关注的区域。比如视频网站的视频播放区域,搜索网站的第一个搜索结果区域,又或者是购物网站的照片首图。通常来说浏览器很难清楚的了解哪一块是对于网站首屏来说是最关键的,所以开发者自己来告诉浏览器是哪一块是关键区域是很有必要的。\n\n这也是非常关键的一个指标,通常如果用户能够快速的看到最重要的一块区域被渲染完成,即使其他的区域都还没有被渲染用户可能也不会注意到。\n\n* long task:我们都知道浏览器是单线程的在响应用户的操作时通过在任务队列里面增加任务,然后一个个的执行的.这意味着如果我们有一个长任务需要使用较长的时间,那么队列中的其他任务就只能等待,响应用户的操作就会变慢,或者动画就会变卡顿。\n* Time to interactive (TTI):这个指标表示浏览器已经渲染完了我们首屏需要显示的内容并且已经准备好接受用户的交互信息了,也标志着程序是否可用。程序暂时无法响应用户的交互有下面几个原因:\n  * 需要执行的javascript还没有执行完成。\n  * 有长任务阻绝着主线程.无法给用户响应。\n\n\n|指标|介绍|  \n|------|---|\nfirst paint (FP)/first contentful paint (FCP) | 程序是否正确的开始渲染\nFirst meaningful paint (FMP) | 用户最关注的的首屏内容显示\nTime to interactive (TTI) | 程序是否可用\nlong task|程序使用的体验(是否响应延迟,动画卡顿)\n\n还有一些其他的指标比如 First Input Delay(首次接受用户响应的延迟时间) First CPU Idle(第一次CPU闲置的时间):这些指标都和上面的指标有着直接的关系。\n\n### 用户体验\n知道了这些指标,我们要把这些指标控制在什么样的时间才能给用户带来比较好的用户的体验呢,下面有这样一张表\n\n|时间|介绍|  \n|--------|---|\n|0到16ms|用户希望看的动画能够流畅,动画卡顿会带来非常差的用户体验,在浏览器上每秒钟渲染60帧动画就能够保持流畅,这大约就是16ms渲染一帧，这16ms包括了浏览器要渲染新的元素到页面上需要的时间，也就是说程序有大约10ms的时间可以进行操作。|\n|0到100ms|在这个时间内响应用户的交互,用户会觉得响应是非常及时的|\n|100到300ms|用户会感觉到有一些延迟|\n|300到1000ms|当执行一些页面加载或者页面跳转的时候,在这个时间内是一个正常的加载跳转时间|\n|1000ms或以上|超过1000ms(1秒),用户会对之前的操作渐渐失去耐心和注意力|\n|10000ms或以上|当你的响应超过10秒,用户会感到烦躁,然后终止之前操作|\n\n上面的延迟时间取决于你使用什么样的网络和设备,比如你使用的电脑和wifi网络,用户在1000ms是一个比较现实的目标。但是当你设备是手机网络只有3G的时候在5000ms内加载才是更现实的目标。\n\n#### 响应时间:处理响应用户的操作在50ms以内\n在大多数的时间里，用户在使用程序时大多数的时间都在等待网站响应他们的操作比如点击一个按钮,在文本框中输入内容,而不是等待网站加载。那么网站比较理想的响应用户时间是在100ms以内。\n\n##### 100ms?不是50ms吗?\n我们的目标是在100ms以内响应用户的操作,那为什么处理用户的响应时间只有50ms?因为在我们接受到用户的输入时,可能会有别的任务正在执行.比如我们接受到用户在文本框中输入了一个A,这个时候浏览器正在执行别的任务,浏览器会把这个操作先加入到任务队列里,等浏览器执行完之前的任务才会去处理用户的响应。那么保守的估计为了让用户在100ms以内获得响应,我们的处理用户响应的执行时间就是50ms。\n![响应时间](http://img.pandihai.com/rail-response-details.png)\n\n#### 动画:生产每一帧动画的时间在10ms左右\n理论上来说只要没16ms渲染一帧,动画就会看起来是流畅的,但是浏览器大约需要6ms的时间来将每一帧渲染到画面上.因此产生每一帧动画的时间留给程序的大约就10ms左右。\n\n#### 主线程闲置时间越多越好\n主线程能够有尽可能多的闲置时间,那么当产生用户交互时就可以立马给用户响应。当主线程闲置时,浏览器会有很多的内部程序需要执行,比如闲置GC等。\n\n#### 主要内容渲染完成且程序可交互时间在5秒之内\n当页面加载缓慢,用户会失去耐心。网站的加载和响应速度直接影响用户的体验。\n\n### 如何测试这些指标\n#### 使用测试工具或者网站\n* Chrome DevTools-Audits\n* [WebPageTest](https://webpagetest.org/easy)\n\n#### 在真实的用户环境获得这些指标\n在介绍如何在用户真实环境中或者这些指标之前先介绍一些API\n* [performance.mark](https://www.w3.org/TR/user-timing/#dom-performance-mark):创建给定标记的一个timestamp。\n* [performance.measure](https://www.w3.org/TR/user-timing/#dom-performance-measure):两个mark之间所经历的时间\n* [PerformanceObserver](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver):PerformanceObserver接口用于监控性能,可以根据传入的[监控事件](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType)返回对应的[PerformanceEntry](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry)对象。\n\n##### 获得FP/FCP\n```js\nconst observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      //这里的name是为了区分'first-paint','first-contentful-paint'\n      const metricName = entry.name;\n      const time = Math.round(entry.startTime + entry.duration);\n      reportToServer({\n        eventCategory: 'Performance Metrics',\n        eventAction: metricName,\n        eventValue: time,\n        nonInteraction: true,\n      });\n    }\n  });\n  observer.observe({entryTypes: ['paint']});\n```\n##### 根据你首屏最重要的元素获得FMP\n之前已经介绍过对于浏览器来说很那准确的知道每个网站对重要的一块区域显示的时间,那么只有开发者自己能够准确的找到最重要的一块区域获得FMP,假设我们网站首屏最重要的元素是一个图片就可以这么写.\n```js\n<img src=\"important.jpg\" onload=\"performance.clearMarks('img displayed'); performance.mark('img displayed');\">\n<script>\nperformance.clearMarks(\"img displayed\");\nperformance.mark(\"img displayed\");\n</script>\n```\n##### 获得TTI\n目前在PerformanceObserver中还没有办法获得TTI的接口,通过这个[tti-polyfill](https://github.com/GoogleChromeLabs/tti-polyfill)可以知道这个tti\n```js\nimport ttiPolyfill from 'tti-polyfill.js';\n\nttiPolyfill.getFirstConsistentlyInteractive().then((tti) => {\n  reportToServer({\n    eventCategory: 'Performance Metrics',\n    eventAction: 'TTI',\n    eventValue: tti,\n    nonInteraction: true,\n  });\n});\n```\n\n##### 监视长任务\n之前提到过,长任务可能会影响浏览器对用户响应速度或者造成动画的卡顿.那么能意识到长任务的存在并且把他缩短是很有必要的。(长任务API认为50ms以上任务的为长任务)\n```js\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    reportToServer({\n      eventCategory: 'Performance Metrics',\n      eventAction: 'longtask',\n      eventValue: Math.round(entry.startTime + entry.duration),\n      //这里的长任务会包含一个attribute\n      //https://w3c.github.io/longtasks/#sec-TaskAttributionTiming\n      eventLabel: JSON.stringify(entry.attribution),\n    });\n  }\n});\n\nobserver.observe({entryTypes: ['longtask']});\n```\n\n##### 监视响应延迟\n长任务会阻塞线程导致浏览器无法响应用户操作,之前也提到过如果能在100ms以内响应用户的操作就不会让用户觉得卡顿,那么如果能够监控到你关键交互的响应时间也是很有必要的\n```js\nconst submitBtn = document.querySelector('#submit');\n\nsubmitBtn.addEventListener('click', (event) => {\n  const lag = performance.now() - event.timeStamp;\n  if (lag > 100) {\n    reportToServer({\n      eventCategory: 'Performance Metric'\n      eventAction: 'input-latency',\n      eventLabel: '#subscribe:click',\n      eventValue: Math.round(lag),\n      nonInteraction: true,\n    });\n  }\n});\n```\n\n##### 幸存者偏差\n当我们的程序如果加载速度很慢(比如加载了过多的js),那么真实用户在网络环境不一致的情况下,有些响应过慢的用户可能早早的在加载完成前就已经退出网站,那么这里就会有一个幸存者偏差的问题.你监控的用户都是已经加载完成的用户。为了能够同时检测到退出的用户.\n```js\n///写在最头部\nwindow.__trackAbandons = () => {\n  // 去掉事件监听那么这个方法只执行一次\n  document.removeEventListener('visibilitychange', window.__trackAbandons);\n  //因为我们还没有加载report js API 所以我们要让服务器提供一个post接口在接收这次请求\n  const ANALYTICS_URL = 'https://ANALYTICS_URL';\n  const TRACKING_ID = 'TRACKING_ID';\n  const CLIENT_ID = (Math.random() * Math.pow(2, 52));\n\n  // Send the data to Google Analytics via the Measurement Protocol.\n  navigator.sendBeacon && navigator.sendBeacon(ANALYTICS_URL, [\n    'v=1', 't=event', 'ec=Load', 'ea=abandon', 'ni=1',\n    'dl=' + encodeURIComponent(location.href),\n    'dt=' + encodeURIComponent(document.title),\n    'tid=' + TRACKING_ID,\n    'cid=' + CLIENT_ID,\n    'ev=' + Math.round(performance.now()),\n  ].join('&'));\n};\n//visibilitychange可以监听页面unload事件\n//https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event\ndocument.addEventListener('visibilitychange', window.__trackAbandons);\n```\n\n### 结论\n性能对现在的程序越来越重要,那么在一个程序需要进行性能优化的时候.个人认为可以按照这样的一个顺序进行:\n\n数据收集->讨论性能指标阀值->针对性能优化->数据重新验证优化结果\n\n这里主要讨论了我们一些性能指标和收集性能指标的方法,后面会讨论如何针对每一块进行优化。","slug":"前端性能优化一-性能指标","published":1,"updated":"2019-09-18T01:43:40.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufxu001w4seflx8f6k1b","content":"<p>如果我们想要提高我们的前端性能,那么首先你得先只知道怎么测量你的前端性能。但是哪些前端的性能指标我们应该关注呢?<br>在Web1.0时代当我们讨论到前端性能指标用的最多的就是<code>page load time</code>。到了单页应用程序越来越多的时代,单一的<code>page load time</code>指标已经无法完全衡量前端性能了,因为一个单页应用程序<code>page load time</code>可能只触发了一次,但是用户会跟程序有很多的交互,每一个交互或者动作都需要有指标来衡量他的性能。</p>\n<p>接下来就介绍几个比较重要的前端性能指标:</p>\n<ul>\n<li>first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间</li>\n<li>first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas.</li>\n</ul>\n<p>这两个指标对用户来说都是很重要的,这两个指标可以认为我们程序正在告诉我们的用户:我们正在正确工作。</p>\n<ul>\n<li>First meaningful paint (FMP):这个指标标志着首屏最重要的一块区域的渲染,通常是用户最关注的区域。比如视频网站的视频播放区域,搜索网站的第一个搜索结果区域,又或者是购物网站的照片首图。通常来说浏览器很难清楚的了解哪一块是对于网站首屏来说是最关键的,所以开发者自己来告诉浏览器是哪一块是关键区域是很有必要的。</li>\n</ul>\n<p>这也是非常关键的一个指标,通常如果用户能够快速的看到最重要的一块区域被渲染完成,即使其他的区域都还没有被渲染用户可能也不会注意到。</p>\n<ul>\n<li>long task:我们都知道浏览器是单线程的在响应用户的操作时通过在任务队列里面增加任务,然后一个个的执行的.这意味着如果我们有一个长任务需要使用较长的时间,那么队列中的其他任务就只能等待,响应用户的操作就会变慢,或者动画就会变卡顿。</li>\n<li>Time to interactive (TTI):这个指标表示浏览器已经渲染完了我们首屏需要显示的内容并且已经准备好接受用户的交互信息了,也标志着程序是否可用。程序暂时无法响应用户的交互有下面几个原因:<ul>\n<li>需要执行的javascript还没有执行完成。</li>\n<li>有长任务阻绝着主线程.无法给用户响应。</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>first paint (FP)/first contentful paint (FCP)</td>\n<td>程序是否正确的开始渲染</td>\n</tr>\n<tr>\n<td>First meaningful paint (FMP)</td>\n<td>用户最关注的的首屏内容显示</td>\n</tr>\n<tr>\n<td>Time to interactive (TTI)</td>\n<td>程序是否可用</td>\n</tr>\n<tr>\n<td>long task</td>\n<td>程序使用的体验(是否响应延迟,动画卡顿)</td>\n</tr>\n</tbody></table>\n<p>还有一些其他的指标比如 First Input Delay(首次接受用户响应的延迟时间) First CPU Idle(第一次CPU闲置的时间):这些指标都和上面的指标有着直接的关系。</p>\n<h3 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h3><p>知道了这些指标,我们要把这些指标控制在什么样的时间才能给用户带来比较好的用户的体验呢,下面有这样一张表</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0到16ms</td>\n<td>用户希望看的动画能够流畅,动画卡顿会带来非常差的用户体验,在浏览器上每秒钟渲染60帧动画就能够保持流畅,这大约就是16ms渲染一帧，这16ms包括了浏览器要渲染新的元素到页面上需要的时间，也就是说程序有大约10ms的时间可以进行操作。</td>\n</tr>\n<tr>\n<td>0到100ms</td>\n<td>在这个时间内响应用户的交互,用户会觉得响应是非常及时的</td>\n</tr>\n<tr>\n<td>100到300ms</td>\n<td>用户会感觉到有一些延迟</td>\n</tr>\n<tr>\n<td>300到1000ms</td>\n<td>当执行一些页面加载或者页面跳转的时候,在这个时间内是一个正常的加载跳转时间</td>\n</tr>\n<tr>\n<td>1000ms或以上</td>\n<td>超过1000ms(1秒),用户会对之前的操作渐渐失去耐心和注意力</td>\n</tr>\n<tr>\n<td>10000ms或以上</td>\n<td>当你的响应超过10秒,用户会感到烦躁,然后终止之前操作</td>\n</tr>\n</tbody></table>\n<p>上面的延迟时间取决于你使用什么样的网络和设备,比如你使用的电脑和wifi网络,用户在1000ms是一个比较现实的目标。但是当你设备是手机网络只有3G的时候在5000ms内加载才是更现实的目标。</p>\n<h4 id=\"响应时间-处理响应用户的操作在50ms以内\"><a href=\"#响应时间-处理响应用户的操作在50ms以内\" class=\"headerlink\" title=\"响应时间:处理响应用户的操作在50ms以内\"></a>响应时间:处理响应用户的操作在50ms以内</h4><p>在大多数的时间里，用户在使用程序时大多数的时间都在等待网站响应他们的操作比如点击一个按钮,在文本框中输入内容,而不是等待网站加载。那么网站比较理想的响应用户时间是在100ms以内。</p>\n<h5 id=\"100ms-不是50ms吗\"><a href=\"#100ms-不是50ms吗\" class=\"headerlink\" title=\"100ms?不是50ms吗?\"></a>100ms?不是50ms吗?</h5><p>我们的目标是在100ms以内响应用户的操作,那为什么处理用户的响应时间只有50ms?因为在我们接受到用户的输入时,可能会有别的任务正在执行.比如我们接受到用户在文本框中输入了一个A,这个时候浏览器正在执行别的任务,浏览器会把这个操作先加入到任务队列里,等浏览器执行完之前的任务才会去处理用户的响应。那么保守的估计为了让用户在100ms以内获得响应,我们的处理用户响应的执行时间就是50ms。<br><img src=\"http://img.pandihai.com/rail-response-details.png\" alt=\"响应时间\"></p>\n<h4 id=\"动画-生产每一帧动画的时间在10ms左右\"><a href=\"#动画-生产每一帧动画的时间在10ms左右\" class=\"headerlink\" title=\"动画:生产每一帧动画的时间在10ms左右\"></a>动画:生产每一帧动画的时间在10ms左右</h4><p>理论上来说只要没16ms渲染一帧,动画就会看起来是流畅的,但是浏览器大约需要6ms的时间来将每一帧渲染到画面上.因此产生每一帧动画的时间留给程序的大约就10ms左右。</p>\n<h4 id=\"主线程闲置时间越多越好\"><a href=\"#主线程闲置时间越多越好\" class=\"headerlink\" title=\"主线程闲置时间越多越好\"></a>主线程闲置时间越多越好</h4><p>主线程能够有尽可能多的闲置时间,那么当产生用户交互时就可以立马给用户响应。当主线程闲置时,浏览器会有很多的内部程序需要执行,比如闲置GC等。</p>\n<h4 id=\"主要内容渲染完成且程序可交互时间在5秒之内\"><a href=\"#主要内容渲染完成且程序可交互时间在5秒之内\" class=\"headerlink\" title=\"主要内容渲染完成且程序可交互时间在5秒之内\"></a>主要内容渲染完成且程序可交互时间在5秒之内</h4><p>当页面加载缓慢,用户会失去耐心。网站的加载和响应速度直接影响用户的体验。</p>\n<h3 id=\"如何测试这些指标\"><a href=\"#如何测试这些指标\" class=\"headerlink\" title=\"如何测试这些指标\"></a>如何测试这些指标</h3><h4 id=\"使用测试工具或者网站\"><a href=\"#使用测试工具或者网站\" class=\"headerlink\" title=\"使用测试工具或者网站\"></a>使用测试工具或者网站</h4><ul>\n<li>Chrome DevTools-Audits</li>\n<li><a href=\"https://webpagetest.org/easy\" target=\"_blank\" rel=\"noopener\">WebPageTest</a></li>\n</ul>\n<h4 id=\"在真实的用户环境获得这些指标\"><a href=\"#在真实的用户环境获得这些指标\" class=\"headerlink\" title=\"在真实的用户环境获得这些指标\"></a>在真实的用户环境获得这些指标</h4><p>在介绍如何在用户真实环境中或者这些指标之前先介绍一些API</p>\n<ul>\n<li><a href=\"https://www.w3.org/TR/user-timing/#dom-performance-mark\" target=\"_blank\" rel=\"noopener\">performance.mark</a>:创建给定标记的一个timestamp。</li>\n<li><a href=\"https://www.w3.org/TR/user-timing/#dom-performance-measure\" target=\"_blank\" rel=\"noopener\">performance.measure</a>:两个mark之间所经历的时间</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\" target=\"_blank\" rel=\"noopener\">PerformanceObserver</a>:PerformanceObserver接口用于监控性能,可以根据传入的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType\" target=\"_blank\" rel=\"noopener\">监控事件</a>返回对应的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry\" target=\"_blank\" rel=\"noopener\">PerformanceEntry</a>对象。</li>\n</ul>\n<h5 id=\"获得FP-FCP\"><a href=\"#获得FP-FCP\" class=\"headerlink\" title=\"获得FP/FCP\"></a>获得FP/FCP</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> PerformanceObserver(<span class=\"function\">(<span class=\"params\">list</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> entry <span class=\"keyword\">of</span> list.getEntries()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//这里的name是为了区分'first-paint','first-contentful-paint'</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> metricName = entry.name;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> time = <span class=\"built_in\">Math</span>.round(entry.startTime + entry.duration);</span><br><span class=\"line\">      reportToServer(&#123;</span><br><span class=\"line\">        eventCategory: <span class=\"string\">'Performance Metrics'</span>,</span><br><span class=\"line\">        eventAction: metricName,</span><br><span class=\"line\">        eventValue: time,</span><br><span class=\"line\">        nonInteraction: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  observer.observe(&#123;<span class=\"attr\">entryTypes</span>: [<span class=\"string\">'paint'</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"根据你首屏最重要的元素获得FMP\"><a href=\"#根据你首屏最重要的元素获得FMP\" class=\"headerlink\" title=\"根据你首屏最重要的元素获得FMP\"></a>根据你首屏最重要的元素获得FMP</h5><p>之前已经介绍过对于浏览器来说很那准确的知道每个网站对重要的一块区域显示的时间,那么只有开发者自己能够准确的找到最重要的一块区域获得FMP,假设我们网站首屏最重要的元素是一个图片就可以这么写.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">\"important.jpg\"</span> onload=<span class=\"string\">\"performance.clearMarks('img displayed'); performance.mark('img displayed');\"</span>&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">performance.clearMarks(<span class=\"string\">\"img displayed\"</span>);</span><br><span class=\"line\">performance.mark(<span class=\"string\">\"img displayed\"</span>);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"获得TTI\"><a href=\"#获得TTI\" class=\"headerlink\" title=\"获得TTI\"></a>获得TTI</h5><p>目前在PerformanceObserver中还没有办法获得TTI的接口,通过这个<a href=\"https://github.com/GoogleChromeLabs/tti-polyfill\" target=\"_blank\" rel=\"noopener\">tti-polyfill</a>可以知道这个tti</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ttiPolyfill <span class=\"keyword\">from</span> <span class=\"string\">'tti-polyfill.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ttiPolyfill.getFirstConsistentlyInteractive().then(<span class=\"function\">(<span class=\"params\">tti</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reportToServer(&#123;</span><br><span class=\"line\">    eventCategory: <span class=\"string\">'Performance Metrics'</span>,</span><br><span class=\"line\">    eventAction: <span class=\"string\">'TTI'</span>,</span><br><span class=\"line\">    eventValue: tti,</span><br><span class=\"line\">    nonInteraction: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"监视长任务\"><a href=\"#监视长任务\" class=\"headerlink\" title=\"监视长任务\"></a>监视长任务</h5><p>之前提到过,长任务可能会影响浏览器对用户响应速度或者造成动画的卡顿.那么能意识到长任务的存在并且把他缩短是很有必要的。(长任务API认为50ms以上任务的为长任务)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> PerformanceObserver(<span class=\"function\">(<span class=\"params\">list</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> entry <span class=\"keyword\">of</span> list.getEntries()) &#123;</span><br><span class=\"line\">    reportToServer(&#123;</span><br><span class=\"line\">      eventCategory: <span class=\"string\">'Performance Metrics'</span>,</span><br><span class=\"line\">      eventAction: <span class=\"string\">'longtask'</span>,</span><br><span class=\"line\">      eventValue: <span class=\"built_in\">Math</span>.round(entry.startTime + entry.duration),</span><br><span class=\"line\">      <span class=\"comment\">//这里的长任务会包含一个attribute</span></span><br><span class=\"line\">      <span class=\"comment\">//https://w3c.github.io/longtasks/#sec-TaskAttributionTiming</span></span><br><span class=\"line\">      eventLabel: <span class=\"built_in\">JSON</span>.stringify(entry.attribution),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observer.observe(&#123;<span class=\"attr\">entryTypes</span>: [<span class=\"string\">'longtask'</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"监视响应延迟\"><a href=\"#监视响应延迟\" class=\"headerlink\" title=\"监视响应延迟\"></a>监视响应延迟</h5><p>长任务会阻塞线程导致浏览器无法响应用户操作,之前也提到过如果能在100ms以内响应用户的操作就不会让用户觉得卡顿,那么如果能够监控到你关键交互的响应时间也是很有必要的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> submitBtn = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#submit'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">submitBtn.addEventListener(<span class=\"string\">'click'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lag = performance.now() - event.timeStamp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lag &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    reportToServer(&#123;</span><br><span class=\"line\">      eventCategory: <span class=\"string\">'Performance Metric'</span></span><br><span class=\"line\">      eventAction: <span class=\"string\">'input-latency'</span>,</span><br><span class=\"line\">      eventLabel: <span class=\"string\">'#subscribe:click'</span>,</span><br><span class=\"line\">      eventValue: <span class=\"built_in\">Math</span>.round(lag),</span><br><span class=\"line\">      nonInteraction: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"幸存者偏差\"><a href=\"#幸存者偏差\" class=\"headerlink\" title=\"幸存者偏差\"></a>幸存者偏差</h5><p>当我们的程序如果加载速度很慢(比如加载了过多的js),那么真实用户在网络环境不一致的情况下,有些响应过慢的用户可能早早的在加载完成前就已经退出网站,那么这里就会有一个幸存者偏差的问题.你监控的用户都是已经加载完成的用户。为了能够同时检测到退出的用户.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///写在最头部</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.__trackAbandons = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 去掉事件监听那么这个方法只执行一次</span></span><br><span class=\"line\">  <span class=\"built_in\">document</span>.removeEventListener(<span class=\"string\">'visibilitychange'</span>, <span class=\"built_in\">window</span>.__trackAbandons);</span><br><span class=\"line\">  <span class=\"comment\">//因为我们还没有加载report js API 所以我们要让服务器提供一个post接口在接收这次请求</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ANALYTICS_URL = <span class=\"string\">'https://ANALYTICS_URL'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> TRACKING_ID = <span class=\"string\">'TRACKING_ID'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> CLIENT_ID = (<span class=\"built_in\">Math</span>.random() * <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">52</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send the data to Google Analytics via the Measurement Protocol.</span></span><br><span class=\"line\">  navigator.sendBeacon &amp;&amp; navigator.sendBeacon(ANALYTICS_URL, [</span><br><span class=\"line\">    <span class=\"string\">'v=1'</span>, <span class=\"string\">'t=event'</span>, <span class=\"string\">'ec=Load'</span>, <span class=\"string\">'ea=abandon'</span>, <span class=\"string\">'ni=1'</span>,</span><br><span class=\"line\">    <span class=\"string\">'dl='</span> + <span class=\"built_in\">encodeURIComponent</span>(location.href),</span><br><span class=\"line\">    <span class=\"string\">'dt='</span> + <span class=\"built_in\">encodeURIComponent</span>(<span class=\"built_in\">document</span>.title),</span><br><span class=\"line\">    <span class=\"string\">'tid='</span> + TRACKING_ID,</span><br><span class=\"line\">    <span class=\"string\">'cid='</span> + CLIENT_ID,</span><br><span class=\"line\">    <span class=\"string\">'ev='</span> + <span class=\"built_in\">Math</span>.round(performance.now()),</span><br><span class=\"line\">  ].join(<span class=\"string\">'&amp;'</span>));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//visibilitychange可以监听页面unload事件</span></span><br><span class=\"line\"><span class=\"comment\">//https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'visibilitychange'</span>, <span class=\"built_in\">window</span>.__trackAbandons);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>性能对现在的程序越来越重要,那么在一个程序需要进行性能优化的时候.个人认为可以按照这样的一个顺序进行:</p>\n<p>数据收集-&gt;讨论性能指标阀值-&gt;针对性能优化-&gt;数据重新验证优化结果</p>\n<p>这里主要讨论了我们一些性能指标和收集性能指标的方法,后面会讨论如何针对每一块进行优化。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果我们想要提高我们的前端性能,那么首先你得先只知道怎么测量你的前端性能。但是哪些前端的性能指标我们应该关注呢?<br>在Web1.0时代当我们讨论到前端性能指标用的最多的就是<code>page load time</code>。到了单页应用程序越来越多的时代,单一的<code>page load time</code>指标已经无法完全衡量前端性能了,因为一个单页应用程序<code>page load time</code>可能只触发了一次,但是用户会跟程序有很多的交互,每一个交互或者动作都需要有指标来衡量他的性能。</p>\n<p>接下来就介绍几个比较重要的前端性能指标:</p>\n<ul>\n<li>first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间</li>\n<li>first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas.</li>\n</ul>\n<p>这两个指标对用户来说都是很重要的,这两个指标可以认为我们程序正在告诉我们的用户:我们正在正确工作。</p>\n<ul>\n<li>First meaningful paint (FMP):这个指标标志着首屏最重要的一块区域的渲染,通常是用户最关注的区域。比如视频网站的视频播放区域,搜索网站的第一个搜索结果区域,又或者是购物网站的照片首图。通常来说浏览器很难清楚的了解哪一块是对于网站首屏来说是最关键的,所以开发者自己来告诉浏览器是哪一块是关键区域是很有必要的。</li>\n</ul>\n<p>这也是非常关键的一个指标,通常如果用户能够快速的看到最重要的一块区域被渲染完成,即使其他的区域都还没有被渲染用户可能也不会注意到。</p>\n<ul>\n<li>long task:我们都知道浏览器是单线程的在响应用户的操作时通过在任务队列里面增加任务,然后一个个的执行的.这意味着如果我们有一个长任务需要使用较长的时间,那么队列中的其他任务就只能等待,响应用户的操作就会变慢,或者动画就会变卡顿。</li>\n<li>Time to interactive (TTI):这个指标表示浏览器已经渲染完了我们首屏需要显示的内容并且已经准备好接受用户的交互信息了,也标志着程序是否可用。程序暂时无法响应用户的交互有下面几个原因:<ul>\n<li>需要执行的javascript还没有执行完成。</li>\n<li>有长任务阻绝着主线程.无法给用户响应。</li>\n</ul>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>指标</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>first paint (FP)/first contentful paint (FCP)</td>\n<td>程序是否正确的开始渲染</td>\n</tr>\n<tr>\n<td>First meaningful paint (FMP)</td>\n<td>用户最关注的的首屏内容显示</td>\n</tr>\n<tr>\n<td>Time to interactive (TTI)</td>\n<td>程序是否可用</td>\n</tr>\n<tr>\n<td>long task</td>\n<td>程序使用的体验(是否响应延迟,动画卡顿)</td>\n</tr>\n</tbody></table>\n<p>还有一些其他的指标比如 First Input Delay(首次接受用户响应的延迟时间) First CPU Idle(第一次CPU闲置的时间):这些指标都和上面的指标有着直接的关系。</p>\n<h3 id=\"用户体验\"><a href=\"#用户体验\" class=\"headerlink\" title=\"用户体验\"></a>用户体验</h3><p>知道了这些指标,我们要把这些指标控制在什么样的时间才能给用户带来比较好的用户的体验呢,下面有这样一张表</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>介绍</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>0到16ms</td>\n<td>用户希望看的动画能够流畅,动画卡顿会带来非常差的用户体验,在浏览器上每秒钟渲染60帧动画就能够保持流畅,这大约就是16ms渲染一帧，这16ms包括了浏览器要渲染新的元素到页面上需要的时间，也就是说程序有大约10ms的时间可以进行操作。</td>\n</tr>\n<tr>\n<td>0到100ms</td>\n<td>在这个时间内响应用户的交互,用户会觉得响应是非常及时的</td>\n</tr>\n<tr>\n<td>100到300ms</td>\n<td>用户会感觉到有一些延迟</td>\n</tr>\n<tr>\n<td>300到1000ms</td>\n<td>当执行一些页面加载或者页面跳转的时候,在这个时间内是一个正常的加载跳转时间</td>\n</tr>\n<tr>\n<td>1000ms或以上</td>\n<td>超过1000ms(1秒),用户会对之前的操作渐渐失去耐心和注意力</td>\n</tr>\n<tr>\n<td>10000ms或以上</td>\n<td>当你的响应超过10秒,用户会感到烦躁,然后终止之前操作</td>\n</tr>\n</tbody></table>\n<p>上面的延迟时间取决于你使用什么样的网络和设备,比如你使用的电脑和wifi网络,用户在1000ms是一个比较现实的目标。但是当你设备是手机网络只有3G的时候在5000ms内加载才是更现实的目标。</p>\n<h4 id=\"响应时间-处理响应用户的操作在50ms以内\"><a href=\"#响应时间-处理响应用户的操作在50ms以内\" class=\"headerlink\" title=\"响应时间:处理响应用户的操作在50ms以内\"></a>响应时间:处理响应用户的操作在50ms以内</h4><p>在大多数的时间里，用户在使用程序时大多数的时间都在等待网站响应他们的操作比如点击一个按钮,在文本框中输入内容,而不是等待网站加载。那么网站比较理想的响应用户时间是在100ms以内。</p>\n<h5 id=\"100ms-不是50ms吗\"><a href=\"#100ms-不是50ms吗\" class=\"headerlink\" title=\"100ms?不是50ms吗?\"></a>100ms?不是50ms吗?</h5><p>我们的目标是在100ms以内响应用户的操作,那为什么处理用户的响应时间只有50ms?因为在我们接受到用户的输入时,可能会有别的任务正在执行.比如我们接受到用户在文本框中输入了一个A,这个时候浏览器正在执行别的任务,浏览器会把这个操作先加入到任务队列里,等浏览器执行完之前的任务才会去处理用户的响应。那么保守的估计为了让用户在100ms以内获得响应,我们的处理用户响应的执行时间就是50ms。<br><img src=\"http://img.pandihai.com/rail-response-details.png\" alt=\"响应时间\"></p>\n<h4 id=\"动画-生产每一帧动画的时间在10ms左右\"><a href=\"#动画-生产每一帧动画的时间在10ms左右\" class=\"headerlink\" title=\"动画:生产每一帧动画的时间在10ms左右\"></a>动画:生产每一帧动画的时间在10ms左右</h4><p>理论上来说只要没16ms渲染一帧,动画就会看起来是流畅的,但是浏览器大约需要6ms的时间来将每一帧渲染到画面上.因此产生每一帧动画的时间留给程序的大约就10ms左右。</p>\n<h4 id=\"主线程闲置时间越多越好\"><a href=\"#主线程闲置时间越多越好\" class=\"headerlink\" title=\"主线程闲置时间越多越好\"></a>主线程闲置时间越多越好</h4><p>主线程能够有尽可能多的闲置时间,那么当产生用户交互时就可以立马给用户响应。当主线程闲置时,浏览器会有很多的内部程序需要执行,比如闲置GC等。</p>\n<h4 id=\"主要内容渲染完成且程序可交互时间在5秒之内\"><a href=\"#主要内容渲染完成且程序可交互时间在5秒之内\" class=\"headerlink\" title=\"主要内容渲染完成且程序可交互时间在5秒之内\"></a>主要内容渲染完成且程序可交互时间在5秒之内</h4><p>当页面加载缓慢,用户会失去耐心。网站的加载和响应速度直接影响用户的体验。</p>\n<h3 id=\"如何测试这些指标\"><a href=\"#如何测试这些指标\" class=\"headerlink\" title=\"如何测试这些指标\"></a>如何测试这些指标</h3><h4 id=\"使用测试工具或者网站\"><a href=\"#使用测试工具或者网站\" class=\"headerlink\" title=\"使用测试工具或者网站\"></a>使用测试工具或者网站</h4><ul>\n<li>Chrome DevTools-Audits</li>\n<li><a href=\"https://webpagetest.org/easy\" target=\"_blank\" rel=\"noopener\">WebPageTest</a></li>\n</ul>\n<h4 id=\"在真实的用户环境获得这些指标\"><a href=\"#在真实的用户环境获得这些指标\" class=\"headerlink\" title=\"在真实的用户环境获得这些指标\"></a>在真实的用户环境获得这些指标</h4><p>在介绍如何在用户真实环境中或者这些指标之前先介绍一些API</p>\n<ul>\n<li><a href=\"https://www.w3.org/TR/user-timing/#dom-performance-mark\" target=\"_blank\" rel=\"noopener\">performance.mark</a>:创建给定标记的一个timestamp。</li>\n<li><a href=\"https://www.w3.org/TR/user-timing/#dom-performance-measure\" target=\"_blank\" rel=\"noopener\">performance.measure</a>:两个mark之间所经历的时间</li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver\" target=\"_blank\" rel=\"noopener\">PerformanceObserver</a>:PerformanceObserver接口用于监控性能,可以根据传入的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry/entryType\" target=\"_blank\" rel=\"noopener\">监控事件</a>返回对应的<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/PerformanceEntry\" target=\"_blank\" rel=\"noopener\">PerformanceEntry</a>对象。</li>\n</ul>\n<h5 id=\"获得FP-FCP\"><a href=\"#获得FP-FCP\" class=\"headerlink\" title=\"获得FP/FCP\"></a>获得FP/FCP</h5><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> PerformanceObserver(<span class=\"function\">(<span class=\"params\">list</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> entry <span class=\"keyword\">of</span> list.getEntries()) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//这里的name是为了区分'first-paint','first-contentful-paint'</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> metricName = entry.name;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> time = <span class=\"built_in\">Math</span>.round(entry.startTime + entry.duration);</span><br><span class=\"line\">      reportToServer(&#123;</span><br><span class=\"line\">        eventCategory: <span class=\"string\">'Performance Metrics'</span>,</span><br><span class=\"line\">        eventAction: metricName,</span><br><span class=\"line\">        eventValue: time,</span><br><span class=\"line\">        nonInteraction: <span class=\"literal\">true</span>,</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  observer.observe(&#123;<span class=\"attr\">entryTypes</span>: [<span class=\"string\">'paint'</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"根据你首屏最重要的元素获得FMP\"><a href=\"#根据你首屏最重要的元素获得FMP\" class=\"headerlink\" title=\"根据你首屏最重要的元素获得FMP\"></a>根据你首屏最重要的元素获得FMP</h5><p>之前已经介绍过对于浏览器来说很那准确的知道每个网站对重要的一块区域显示的时间,那么只有开发者自己能够准确的找到最重要的一块区域获得FMP,假设我们网站首屏最重要的元素是一个图片就可以这么写.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">\"important.jpg\"</span> onload=<span class=\"string\">\"performance.clearMarks('img displayed'); performance.mark('img displayed');\"</span>&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">performance.clearMarks(<span class=\"string\">\"img displayed\"</span>);</span><br><span class=\"line\">performance.mark(<span class=\"string\">\"img displayed\"</span>);</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"获得TTI\"><a href=\"#获得TTI\" class=\"headerlink\" title=\"获得TTI\"></a>获得TTI</h5><p>目前在PerformanceObserver中还没有办法获得TTI的接口,通过这个<a href=\"https://github.com/GoogleChromeLabs/tti-polyfill\" target=\"_blank\" rel=\"noopener\">tti-polyfill</a>可以知道这个tti</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> ttiPolyfill <span class=\"keyword\">from</span> <span class=\"string\">'tti-polyfill.js'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ttiPolyfill.getFirstConsistentlyInteractive().then(<span class=\"function\">(<span class=\"params\">tti</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  reportToServer(&#123;</span><br><span class=\"line\">    eventCategory: <span class=\"string\">'Performance Metrics'</span>,</span><br><span class=\"line\">    eventAction: <span class=\"string\">'TTI'</span>,</span><br><span class=\"line\">    eventValue: tti,</span><br><span class=\"line\">    nonInteraction: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"监视长任务\"><a href=\"#监视长任务\" class=\"headerlink\" title=\"监视长任务\"></a>监视长任务</h5><p>之前提到过,长任务可能会影响浏览器对用户响应速度或者造成动画的卡顿.那么能意识到长任务的存在并且把他缩短是很有必要的。(长任务API认为50ms以上任务的为长任务)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> observer = <span class=\"keyword\">new</span> PerformanceObserver(<span class=\"function\">(<span class=\"params\">list</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> entry <span class=\"keyword\">of</span> list.getEntries()) &#123;</span><br><span class=\"line\">    reportToServer(&#123;</span><br><span class=\"line\">      eventCategory: <span class=\"string\">'Performance Metrics'</span>,</span><br><span class=\"line\">      eventAction: <span class=\"string\">'longtask'</span>,</span><br><span class=\"line\">      eventValue: <span class=\"built_in\">Math</span>.round(entry.startTime + entry.duration),</span><br><span class=\"line\">      <span class=\"comment\">//这里的长任务会包含一个attribute</span></span><br><span class=\"line\">      <span class=\"comment\">//https://w3c.github.io/longtasks/#sec-TaskAttributionTiming</span></span><br><span class=\"line\">      eventLabel: <span class=\"built_in\">JSON</span>.stringify(entry.attribution),</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">observer.observe(&#123;<span class=\"attr\">entryTypes</span>: [<span class=\"string\">'longtask'</span>]&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"监视响应延迟\"><a href=\"#监视响应延迟\" class=\"headerlink\" title=\"监视响应延迟\"></a>监视响应延迟</h5><p>长任务会阻塞线程导致浏览器无法响应用户操作,之前也提到过如果能在100ms以内响应用户的操作就不会让用户觉得卡顿,那么如果能够监控到你关键交互的响应时间也是很有必要的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> submitBtn = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#submit'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">submitBtn.addEventListener(<span class=\"string\">'click'</span>, (event) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> lag = performance.now() - event.timeStamp;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (lag &gt; <span class=\"number\">100</span>) &#123;</span><br><span class=\"line\">    reportToServer(&#123;</span><br><span class=\"line\">      eventCategory: <span class=\"string\">'Performance Metric'</span></span><br><span class=\"line\">      eventAction: <span class=\"string\">'input-latency'</span>,</span><br><span class=\"line\">      eventLabel: <span class=\"string\">'#subscribe:click'</span>,</span><br><span class=\"line\">      eventValue: <span class=\"built_in\">Math</span>.round(lag),</span><br><span class=\"line\">      nonInteraction: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"幸存者偏差\"><a href=\"#幸存者偏差\" class=\"headerlink\" title=\"幸存者偏差\"></a>幸存者偏差</h5><p>当我们的程序如果加载速度很慢(比如加载了过多的js),那么真实用户在网络环境不一致的情况下,有些响应过慢的用户可能早早的在加载完成前就已经退出网站,那么这里就会有一个幸存者偏差的问题.你监控的用户都是已经加载完成的用户。为了能够同时检测到退出的用户.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">///写在最头部</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.__trackAbandons = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 去掉事件监听那么这个方法只执行一次</span></span><br><span class=\"line\">  <span class=\"built_in\">document</span>.removeEventListener(<span class=\"string\">'visibilitychange'</span>, <span class=\"built_in\">window</span>.__trackAbandons);</span><br><span class=\"line\">  <span class=\"comment\">//因为我们还没有加载report js API 所以我们要让服务器提供一个post接口在接收这次请求</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> ANALYTICS_URL = <span class=\"string\">'https://ANALYTICS_URL'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> TRACKING_ID = <span class=\"string\">'TRACKING_ID'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> CLIENT_ID = (<span class=\"built_in\">Math</span>.random() * <span class=\"built_in\">Math</span>.pow(<span class=\"number\">2</span>, <span class=\"number\">52</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Send the data to Google Analytics via the Measurement Protocol.</span></span><br><span class=\"line\">  navigator.sendBeacon &amp;&amp; navigator.sendBeacon(ANALYTICS_URL, [</span><br><span class=\"line\">    <span class=\"string\">'v=1'</span>, <span class=\"string\">'t=event'</span>, <span class=\"string\">'ec=Load'</span>, <span class=\"string\">'ea=abandon'</span>, <span class=\"string\">'ni=1'</span>,</span><br><span class=\"line\">    <span class=\"string\">'dl='</span> + <span class=\"built_in\">encodeURIComponent</span>(location.href),</span><br><span class=\"line\">    <span class=\"string\">'dt='</span> + <span class=\"built_in\">encodeURIComponent</span>(<span class=\"built_in\">document</span>.title),</span><br><span class=\"line\">    <span class=\"string\">'tid='</span> + TRACKING_ID,</span><br><span class=\"line\">    <span class=\"string\">'cid='</span> + CLIENT_ID,</span><br><span class=\"line\">    <span class=\"string\">'ev='</span> + <span class=\"built_in\">Math</span>.round(performance.now()),</span><br><span class=\"line\">  ].join(<span class=\"string\">'&amp;'</span>));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//visibilitychange可以监听页面unload事件</span></span><br><span class=\"line\"><span class=\"comment\">//https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_event</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'visibilitychange'</span>, <span class=\"built_in\">window</span>.__trackAbandons);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h3><p>性能对现在的程序越来越重要,那么在一个程序需要进行性能优化的时候.个人认为可以按照这样的一个顺序进行:</p>\n<p>数据收集-&gt;讨论性能指标阀值-&gt;针对性能优化-&gt;数据重新验证优化结果</p>\n<p>这里主要讨论了我们一些性能指标和收集性能指标的方法,后面会讨论如何针对每一块进行优化。</p>\n"},{"title":"如何为平台设计一个插件系统","date":"2019-08-25T04:19:13.000Z","_content":"\n\n随着web浏览器的发展,浏览器的性能越来越好,WebGL和WebAssembly提供越来越多的可能性。很多原本只能在终端运行的程序都开始开发web版本例如CAD的web版本,PS的web版本,figma。这一个个的设计协作平台原本在终端都有插件机制。那么如果在web端能提供一个插件机制,对于有一点编程能力的用户,就可以提供更好的用户体验和开发更多的可能性。如何开发一个好的插件系统呢?\n\n一个javascript的插件系统需要满足以下几个方面:\n\n#### 安全性\n+ 插件不可以发送请求\n+ 插件和程序模块不可以非法的调用相互的数据\n+ 插件不可以在不受约束的情况下执行\n+ 插件不可以任意的修改UI,从而给用户造成误导\n\n#### 稳定性\n+ 插件不能影响主程序的稳定性\n+ 插件不可以修改主程序中的常量\n\n#### 易开发性\n+ 插件应该是容易开发的,即使是面对没有那么多编程经验的设计师,也应该是容易开发的。\n+ 插件要可以使用调试工具。\n\n#### 效率\n+ 插件的执行效率不能太慢从而影响整个主程序的效率。\n\n\n## 方案一:iframe沙盒实现方式\n当我们在程序中执行第三方的代码的时候,首先第一个应该会想到的就是iframe。iframe不是我们每天都会用到的html标签。要理解为什么iframe为什么安全，我们有不要想一下iframe标签是用来干什么的。\n\niframe比较典型的使用场景就是在一个网页中嵌入一个其他的网页。举个例子来说,你需要在网站中嵌入谷歌地图的页面来实现地图的展现功能。你不会希望谷歌地图的页面中的代码有能力访问你本身的一些代码和敏感数据,相应的谷歌地图也不希望你能够访问他页面中的数据和代码。\n\n这意味着一切和iframe的交互都受限于浏览器。当iframe和原网页有不同的域(imow.cn和google.com),他们是完全隔绝的。那么网页和iframe交互的唯一办法就是通过 [`postMessage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)。这个message是一个string。需要交互的双方可以选择忽略这个message或者做对应的动作。\n\niframe和原网页是完全独立的,其实,如果你想要的话浏览器允许我们通过另外一个线程来创建一个iframe。[这里](https://www.chromium.org/developers/design-documents/oop-iframes).\n\n当我们了解了iframe是如何工作了以后,我们可以在我们需要执行第三方插件的时候创一个iframe，将插件的代码在iframe中执行。在iframe中插件可以执行任何代码,也不会影响到主程序,除非通过提前申明好的message。同时我们可以给iframe的域名设置为null,这意味着根据浏览器[跨域保护策略](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS),iframe无法给域名发送任何请求。\n\niframe就这样很简单的成为我们执行第三方插件的沙盒环境,他的安全性也通过浏览器来保证。插件在沙盒中执行,通过主程序提供的api(postMeassge)和主程序进行交互。代码就像下面这个样子\n```javascript\nconst scene = await main.loadScene() // 从主程序获取界面数据\nscene.selection[0].width *= 2  // 修改界面数据\nscene.createNode({\n  type: 'RECTANGLE',\n  x: 10, y: 20,\n  ...\n})\nawait main.updateScene() // 向主程序发送修改后的界面数据\n```\n这里主要的代码是loadScene(发送消息给主程序,然后获得主程序界面的document拷贝),然后修改完以后通过调用updateScene(发送更新消息给主程序).这里需要注意的是\n+ 我们拷贝了整个document而不是在每次需要读取或者修改属性的时候通过message传输.postMessage每次传输需要0.1ms.每秒钟大约只允许1000 messages。\n+ 我们没有让插件直接使用postMessage api,而是包装了一个api给插件用户使用,这样使用起来不会太笨重。\n\n### 问题#1:async/await 使用起来不是那么方便\n这种实现方式第一个问题就是对于一些不那么了解javascript的新手或者设计师来说,`async/await`关键字还是非常陌生的。但是要使用postMessge是一个异步操作。所以不可避免的要使用`async/await`来控制异步流程。但是如果只是需要在开头和结束的时候调用我们的api还方便,我们可以告诉用户在调用我们的api时候在前面加上`async/await`即使他们不知道这个关键字的作用也不会对他们的操作造成非常大的困扰。\n\n但是问题是有些插件需要执行非常复杂的逻辑,在修改一个layout的属性的时候有时候会引起其他好几个layout的更新。比如更新外层的layout的属性之后,内部的layout的属性也可能发生了更新,这个时候你需要先提交你的属性,然后在重新或者视图的属性,那这个时候你的代码就会变成这样:\n```javascript\nawait mian.loadScene()\n... 操作 ...\nawait mian.updateScene()\nawait mian.loadScene()\n... 操作 ...\nawait mian.updateScene()\nawait mian.loadScene()\n... 操作 ...\nawait mian.updateScene()\n```\n这个代码一下子就变的不可控了,而且用户也很难确认什么时候应该要提交我的属性更新。\n\n### 问题#2:拷贝视图给iframe的操作是非常昂贵的\niframe这种实现方式的第二个问题就是,当你需要给插件发送视图信息的时候你需要序列化你的document发送给你iframe，当你的视图非常非常大的时候,这个序列化的操作是非常耗时的,甚至会导致内存溢出。\n即使我们可以使用增量的加载数据或者懒加载数据这种方式仍然有他的问题:\n+ 首先这种方式是非常难实现的,即使有比较好的方案实现了以后,面对比较大的视图,性能仍然不是很理想,而且对于插件开发者来说是非常难理解的，这违背了我们的插件易开发性。\n+ 异步方法需要等待你需要到的数据达到才能开始后面的操作,对于异步流程控制来说也是一个挑战(steam? Rx?)。\n\n总的来说如果你的主程序有非常大的document要交给第三方插件来进行操作,那么iframe的这种实现方式就不是非常理想的解决方案\n\n### eval\n如果能在主线程上执行插件代码,那么在性能上就会好很多,但是我们又不能简单的`eval(code)`执行插件代码,因为这样是很不安全的。\n\n#### 什么导致eval不安全\n如果我们退一步想:是什么使`eval`方法不安全?如果我们只是执行一段很单纯的代码\n```js\nlet code = 'let a = (7 + 1) * 8;'\neval(code)\n```\n如果只是一段逻辑代码,那么这个代码是没有什么不安全的。之所以认为eval执行的代码不安全是因为<b>在插件代码中有可能会发送网络请求,修改全局的state变量,或者直接修改dom对象等等</b>这些使得我们的插件代码变的不可控,换句话来说是<b>插件具有浏览器api访问的能力让我们插件的代码变的不可控</b>。\n\n### 是不是能把全局的对象藏起来?\n如果我们能把全局的对象藏起来,保证插件代码中只能做变量的赋值或者一些if判断的逻辑代码,没有了全局对象xhr,插件将无法发送请求,没有document对象,插件也不具备访问dom的能力,那么插件能力是不是能在我们的可控范围里面了。\n\n隐藏全局对象,理论上是可行的。但是我们很难仅仅通过隐藏全局对象来创建一个绝对安全的运行环境。举例来说,我们现在把window对象设置为null,但是代码还是可以通过`({}).constructor`来访问全局对象。所以找到所有有可能访问危险api的对象,把所有的路全部堵死是非常难的一件事情。\n\n是不是我们可以找到一个这些全局对象从一开始就不存在的沙盒环境?\n\n## 方案二:将javascript编译成WebAssembly\n[Duktape](https://github.com/svaarala/duktape)是一个轻量级的用c++写的javascript解释器,他可以将javascript编译成WebAssembly,经过[test262](https://github.com/tc39/test262/tree/es5-tests)测试之后,可以确定他全面的支持了ES5的语法。\n\n这种实现方法有以下几种优缺点\n+ 首先这是一种安全的执行环境,因为Duktape不支持任何的浏览器API。作为WebAssembly执行,他本身就是一个沙盒环境,他可以通过提供一个白名单的API和主程序进行交互。\n+ 这个解释器是运行在主线程上的。这意味着我们可以创建一个基于主线程的API。(共享document等)\n+ 他可能会比原本的javascript慢一些,因为JIT解释器在编译的时候做了很多的优化,但是作为WebAssembly我相信这个性能应该也是可以被接受的。\n+ 他需要用浏览器来编译WebAssembly,这会有一些性能消耗。\n+ 浏览器的调试工具就不能用了。\n\n看起来好像不错，但是他作为一个线上项目的表现到底怎么样呢?一个javascript引擎来执行另外一个引擎?WebAssembly本身也是比较新的一个东西，我们是不是真的需要一个相对复杂的解决方案?有没有更简单的方法了?\n\n## 方案三:Realms\n这个技术可以创建一个沙盒环境来支持插件,当我看到他readme文档的时候,就一下子提起了我的兴趣,[Intuitions](https://github.com/tc39/proposal-realms#intuitions)\n+ sandbox\n+ iframe without DOM\n+ principled version of Node's 'vm' module\n+ sync Worker\n\n这不就是我们需要的吗?他的代码看起来是这个样子\n```js\nlet g = window; // outer global\nlet r = new Realm(); // root realm\n\nlet f = r.evaluate(\"(function() { return 17 })\");\n\nf() === 17 // true\n\nReflect.getPrototypeOf(f) === g.Function.prototype // false\nReflect.getPrototypeOf(f) === r.global.Function.prototype // true\n```\n是不是很酷。这个技术其实可以用现在已有的但是不常用的一个javascript功能来实现。代码想这样\n```js\nfunction simplifiedEval(scopeProxy, code) {\n  'use strict'\n  with (scopeProxy) {\n    eval(code)\n  }\n}\n```\n这个就像一个简单版本的Realms,但是管中窥豹,我们可以看见两个关键代码`with`和`Proxy`对象。\n\n`with(obj)`表达式创建了一个作用域,当寻找变量的时候,可以使用这个`obj`的属性.看个例子:\n```js\nwith (Math) {\n  a = PI * r * r\n  x = r * cos(PI)\n  y = r * sin(PI)\n  console.log(x,  y)\n}\n```\n在这个例子里,当我们访问`PI`,`cos`,`sin`的时候,就会找到`Math`的属性。但是`console`因为`Math`没有就仍然会找到全局对象。\n\n知道了`with`表达式,接下来就是`Proxy`对象,这个对象有下面几个特性\n+ 他是一个普通的javascript对象,可以通过`obj.x`访问对象的属性值.\n+ 我们可以实现一个对象属性的`get`方法来实现`obj.x`操作,实际上只执行这个`get`方法.\n\n```js\nconst scopeProxy = new Proxy(whitelist, {\n  get(target, prop) {\n    // target === whitelist\n    if (prop in target) {\n      return target[prop]\n    }\n    return undefined\n  }\n}\n```\n接下来我们就可以把这个`scopeProxy`对象作为参数传入`with`中,他就捕获作用域所有的变量查找,在这个`scopeProxy`的get方法中进行查找这个变量:\n```js\nwith (scopeProxy) {\n  document // undefined!\n  eval(\"xhr\") // undefined!\n}\n```\n这里只有whitelist的属性会被返回,其他都会返回`undefined`.但是其实利用一些类似`({}).constructor`表达式还是有可能访问全局对象的.此外,这个沙盒其实还是需要访问一些全局对象的方法的,类似`Object.keys`\n\n为要给我们的插件系统访问受限全局api的方法然后又不会把window搞乱,Realms沙盒通过创建一个和主程序同源的`iframe`用来拷贝需要用到的全局API。这个iframe和我们第一种实现中创建的iframe不一样,他不是作为运行程序的沙盒。当你创建一个和主程序同源的iframe以后\n\n1. 他会拷贝一份分开的全局对象(比如:Object.prototype)。\n2. 这些全局对象可以从父文档中访问,也就是说我们可以在Realms访问这些全局对象. \n\n我们将这些全局对象放入到Proxy的白名单(whitelist)中，这样在插件代码中就可以访问这些全局对象了。通过创建iframe来拷贝全局对象有一个很重要的好处:即使是通过`({}).constructor`对象访问到的全局对象,也会是iframe中拷贝的全局对象。这样的实现方式有这些优点:\n+ 他在主程序中运行。\n+ 因为他本身还是javascript,所以他仍然用JIT编译解析,浏览器对javascript的优化还是有效。\n+ 浏览器开发工具也还是有效的。\n\n那么就剩下最后一个问题.他真的够安全了吗?\n\n这样看起来结合了iframe的Realms看起来似乎已经挺不错的了,而且他本身也是tc39下面的项目,所以可靠性应该也不错。但是光有一个安全的沙盒环境是不够的,你的插件肯定需要和主程序进行交互,那么我们就肯定要为我们的插件系统提供API,提供给插件的API系统也一定要是安全的。\n\n举个例子,`console.log`是浏览器的api是不是javascript功能,那么我们要为插件系统提供一个`console.log`方法,我们可以这样写:\n```js\nrealm.evaluate(USER_CODE, { log: console.log })\n```\n或者为了隐藏方法本身,我们可以要求他只传参数\n```js\nrealm.evaluate(USER_CODE, { log: (...args) => { console.log(...args) } })\n```\n看起来是这么回事,很可惜,这其实是一个安全漏洞,即使是第二种方法我们还是在Realms外面创建了一个匿名方法,然后直接传入到Realms中。<b>这意味着插件可以通过方法的原型链访问到外部。</b>\n\n正确创建`console.log`方法的方法是,将这个方法通过Realms包裹起来在Realms内部创建像这样\n```js\n// 创建一个工厂方法\n// 这个工厂方法返回一个新的方法他保存一个闭包\nconst safeLogFactory = realm.evaluate(`\n        (function safeLogFactory(unsafeLog) { \n                return function safeLog(...args) {\n                        unsafeLog(...args);\n                }\n        })\n`);\n\n// 创建一个安全的方法\nconst safeLog = safeLogFactory(console.log);\n\nconst outerIntrinsics = safeLog instanceof Function;\nconst innerIntrinsics = realm.evaluate(`log instanceof Function`, { log: safeLog });\nif (outerIntrinsics || !innerIntrinsics) throw new TypeError(); \n\n// 使用\nrealm.evaluate(`log(\"Hello outside world!\")`, { log: safeLog });\n```\n通常来说,在沙盒中不应该能够访问到外部的任何对象包括作用域。因为我们的插件和主程序运行在一个线程中，所以在提供api的时候要非常小心,特别是当你的api需要在realm内部操作外部对象的时候。这对于开发api的开发人员来说是不是有点太不友好了，一不小心就产生了安全隐患，(todo:完善起来)。\n\n## 结论\n如果我们的主程序不是特别复杂而且庞大的话,第一种通过iframe的实现方式应该是最为简单的。\n\n如果我们的主程序本身就是通过WebAssembly创建的例如CAD网页版,我们想第二种方式可能是比较适合他们的,或者他们提供更加优秀的基于WebAssembly的解决方案\n\n最后一种方式如果我们能提供一种简单又安全的开发API的办法,这应该是一种性价比比较高的解决方案。\n","source":"_posts/如何为平台设计一个插件系统.md","raw":"---\ntitle: 如何为平台设计一个插件系统\ndate: 2019-08-25 12:19:13\ntags:\n---\n\n\n随着web浏览器的发展,浏览器的性能越来越好,WebGL和WebAssembly提供越来越多的可能性。很多原本只能在终端运行的程序都开始开发web版本例如CAD的web版本,PS的web版本,figma。这一个个的设计协作平台原本在终端都有插件机制。那么如果在web端能提供一个插件机制,对于有一点编程能力的用户,就可以提供更好的用户体验和开发更多的可能性。如何开发一个好的插件系统呢?\n\n一个javascript的插件系统需要满足以下几个方面:\n\n#### 安全性\n+ 插件不可以发送请求\n+ 插件和程序模块不可以非法的调用相互的数据\n+ 插件不可以在不受约束的情况下执行\n+ 插件不可以任意的修改UI,从而给用户造成误导\n\n#### 稳定性\n+ 插件不能影响主程序的稳定性\n+ 插件不可以修改主程序中的常量\n\n#### 易开发性\n+ 插件应该是容易开发的,即使是面对没有那么多编程经验的设计师,也应该是容易开发的。\n+ 插件要可以使用调试工具。\n\n#### 效率\n+ 插件的执行效率不能太慢从而影响整个主程序的效率。\n\n\n## 方案一:iframe沙盒实现方式\n当我们在程序中执行第三方的代码的时候,首先第一个应该会想到的就是iframe。iframe不是我们每天都会用到的html标签。要理解为什么iframe为什么安全，我们有不要想一下iframe标签是用来干什么的。\n\niframe比较典型的使用场景就是在一个网页中嵌入一个其他的网页。举个例子来说,你需要在网站中嵌入谷歌地图的页面来实现地图的展现功能。你不会希望谷歌地图的页面中的代码有能力访问你本身的一些代码和敏感数据,相应的谷歌地图也不希望你能够访问他页面中的数据和代码。\n\n这意味着一切和iframe的交互都受限于浏览器。当iframe和原网页有不同的域(imow.cn和google.com),他们是完全隔绝的。那么网页和iframe交互的唯一办法就是通过 [`postMessage`](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage)。这个message是一个string。需要交互的双方可以选择忽略这个message或者做对应的动作。\n\niframe和原网页是完全独立的,其实,如果你想要的话浏览器允许我们通过另外一个线程来创建一个iframe。[这里](https://www.chromium.org/developers/design-documents/oop-iframes).\n\n当我们了解了iframe是如何工作了以后,我们可以在我们需要执行第三方插件的时候创一个iframe，将插件的代码在iframe中执行。在iframe中插件可以执行任何代码,也不会影响到主程序,除非通过提前申明好的message。同时我们可以给iframe的域名设置为null,这意味着根据浏览器[跨域保护策略](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS),iframe无法给域名发送任何请求。\n\niframe就这样很简单的成为我们执行第三方插件的沙盒环境,他的安全性也通过浏览器来保证。插件在沙盒中执行,通过主程序提供的api(postMeassge)和主程序进行交互。代码就像下面这个样子\n```javascript\nconst scene = await main.loadScene() // 从主程序获取界面数据\nscene.selection[0].width *= 2  // 修改界面数据\nscene.createNode({\n  type: 'RECTANGLE',\n  x: 10, y: 20,\n  ...\n})\nawait main.updateScene() // 向主程序发送修改后的界面数据\n```\n这里主要的代码是loadScene(发送消息给主程序,然后获得主程序界面的document拷贝),然后修改完以后通过调用updateScene(发送更新消息给主程序).这里需要注意的是\n+ 我们拷贝了整个document而不是在每次需要读取或者修改属性的时候通过message传输.postMessage每次传输需要0.1ms.每秒钟大约只允许1000 messages。\n+ 我们没有让插件直接使用postMessage api,而是包装了一个api给插件用户使用,这样使用起来不会太笨重。\n\n### 问题#1:async/await 使用起来不是那么方便\n这种实现方式第一个问题就是对于一些不那么了解javascript的新手或者设计师来说,`async/await`关键字还是非常陌生的。但是要使用postMessge是一个异步操作。所以不可避免的要使用`async/await`来控制异步流程。但是如果只是需要在开头和结束的时候调用我们的api还方便,我们可以告诉用户在调用我们的api时候在前面加上`async/await`即使他们不知道这个关键字的作用也不会对他们的操作造成非常大的困扰。\n\n但是问题是有些插件需要执行非常复杂的逻辑,在修改一个layout的属性的时候有时候会引起其他好几个layout的更新。比如更新外层的layout的属性之后,内部的layout的属性也可能发生了更新,这个时候你需要先提交你的属性,然后在重新或者视图的属性,那这个时候你的代码就会变成这样:\n```javascript\nawait mian.loadScene()\n... 操作 ...\nawait mian.updateScene()\nawait mian.loadScene()\n... 操作 ...\nawait mian.updateScene()\nawait mian.loadScene()\n... 操作 ...\nawait mian.updateScene()\n```\n这个代码一下子就变的不可控了,而且用户也很难确认什么时候应该要提交我的属性更新。\n\n### 问题#2:拷贝视图给iframe的操作是非常昂贵的\niframe这种实现方式的第二个问题就是,当你需要给插件发送视图信息的时候你需要序列化你的document发送给你iframe，当你的视图非常非常大的时候,这个序列化的操作是非常耗时的,甚至会导致内存溢出。\n即使我们可以使用增量的加载数据或者懒加载数据这种方式仍然有他的问题:\n+ 首先这种方式是非常难实现的,即使有比较好的方案实现了以后,面对比较大的视图,性能仍然不是很理想,而且对于插件开发者来说是非常难理解的，这违背了我们的插件易开发性。\n+ 异步方法需要等待你需要到的数据达到才能开始后面的操作,对于异步流程控制来说也是一个挑战(steam? Rx?)。\n\n总的来说如果你的主程序有非常大的document要交给第三方插件来进行操作,那么iframe的这种实现方式就不是非常理想的解决方案\n\n### eval\n如果能在主线程上执行插件代码,那么在性能上就会好很多,但是我们又不能简单的`eval(code)`执行插件代码,因为这样是很不安全的。\n\n#### 什么导致eval不安全\n如果我们退一步想:是什么使`eval`方法不安全?如果我们只是执行一段很单纯的代码\n```js\nlet code = 'let a = (7 + 1) * 8;'\neval(code)\n```\n如果只是一段逻辑代码,那么这个代码是没有什么不安全的。之所以认为eval执行的代码不安全是因为<b>在插件代码中有可能会发送网络请求,修改全局的state变量,或者直接修改dom对象等等</b>这些使得我们的插件代码变的不可控,换句话来说是<b>插件具有浏览器api访问的能力让我们插件的代码变的不可控</b>。\n\n### 是不是能把全局的对象藏起来?\n如果我们能把全局的对象藏起来,保证插件代码中只能做变量的赋值或者一些if判断的逻辑代码,没有了全局对象xhr,插件将无法发送请求,没有document对象,插件也不具备访问dom的能力,那么插件能力是不是能在我们的可控范围里面了。\n\n隐藏全局对象,理论上是可行的。但是我们很难仅仅通过隐藏全局对象来创建一个绝对安全的运行环境。举例来说,我们现在把window对象设置为null,但是代码还是可以通过`({}).constructor`来访问全局对象。所以找到所有有可能访问危险api的对象,把所有的路全部堵死是非常难的一件事情。\n\n是不是我们可以找到一个这些全局对象从一开始就不存在的沙盒环境?\n\n## 方案二:将javascript编译成WebAssembly\n[Duktape](https://github.com/svaarala/duktape)是一个轻量级的用c++写的javascript解释器,他可以将javascript编译成WebAssembly,经过[test262](https://github.com/tc39/test262/tree/es5-tests)测试之后,可以确定他全面的支持了ES5的语法。\n\n这种实现方法有以下几种优缺点\n+ 首先这是一种安全的执行环境,因为Duktape不支持任何的浏览器API。作为WebAssembly执行,他本身就是一个沙盒环境,他可以通过提供一个白名单的API和主程序进行交互。\n+ 这个解释器是运行在主线程上的。这意味着我们可以创建一个基于主线程的API。(共享document等)\n+ 他可能会比原本的javascript慢一些,因为JIT解释器在编译的时候做了很多的优化,但是作为WebAssembly我相信这个性能应该也是可以被接受的。\n+ 他需要用浏览器来编译WebAssembly,这会有一些性能消耗。\n+ 浏览器的调试工具就不能用了。\n\n看起来好像不错，但是他作为一个线上项目的表现到底怎么样呢?一个javascript引擎来执行另外一个引擎?WebAssembly本身也是比较新的一个东西，我们是不是真的需要一个相对复杂的解决方案?有没有更简单的方法了?\n\n## 方案三:Realms\n这个技术可以创建一个沙盒环境来支持插件,当我看到他readme文档的时候,就一下子提起了我的兴趣,[Intuitions](https://github.com/tc39/proposal-realms#intuitions)\n+ sandbox\n+ iframe without DOM\n+ principled version of Node's 'vm' module\n+ sync Worker\n\n这不就是我们需要的吗?他的代码看起来是这个样子\n```js\nlet g = window; // outer global\nlet r = new Realm(); // root realm\n\nlet f = r.evaluate(\"(function() { return 17 })\");\n\nf() === 17 // true\n\nReflect.getPrototypeOf(f) === g.Function.prototype // false\nReflect.getPrototypeOf(f) === r.global.Function.prototype // true\n```\n是不是很酷。这个技术其实可以用现在已有的但是不常用的一个javascript功能来实现。代码想这样\n```js\nfunction simplifiedEval(scopeProxy, code) {\n  'use strict'\n  with (scopeProxy) {\n    eval(code)\n  }\n}\n```\n这个就像一个简单版本的Realms,但是管中窥豹,我们可以看见两个关键代码`with`和`Proxy`对象。\n\n`with(obj)`表达式创建了一个作用域,当寻找变量的时候,可以使用这个`obj`的属性.看个例子:\n```js\nwith (Math) {\n  a = PI * r * r\n  x = r * cos(PI)\n  y = r * sin(PI)\n  console.log(x,  y)\n}\n```\n在这个例子里,当我们访问`PI`,`cos`,`sin`的时候,就会找到`Math`的属性。但是`console`因为`Math`没有就仍然会找到全局对象。\n\n知道了`with`表达式,接下来就是`Proxy`对象,这个对象有下面几个特性\n+ 他是一个普通的javascript对象,可以通过`obj.x`访问对象的属性值.\n+ 我们可以实现一个对象属性的`get`方法来实现`obj.x`操作,实际上只执行这个`get`方法.\n\n```js\nconst scopeProxy = new Proxy(whitelist, {\n  get(target, prop) {\n    // target === whitelist\n    if (prop in target) {\n      return target[prop]\n    }\n    return undefined\n  }\n}\n```\n接下来我们就可以把这个`scopeProxy`对象作为参数传入`with`中,他就捕获作用域所有的变量查找,在这个`scopeProxy`的get方法中进行查找这个变量:\n```js\nwith (scopeProxy) {\n  document // undefined!\n  eval(\"xhr\") // undefined!\n}\n```\n这里只有whitelist的属性会被返回,其他都会返回`undefined`.但是其实利用一些类似`({}).constructor`表达式还是有可能访问全局对象的.此外,这个沙盒其实还是需要访问一些全局对象的方法的,类似`Object.keys`\n\n为要给我们的插件系统访问受限全局api的方法然后又不会把window搞乱,Realms沙盒通过创建一个和主程序同源的`iframe`用来拷贝需要用到的全局API。这个iframe和我们第一种实现中创建的iframe不一样,他不是作为运行程序的沙盒。当你创建一个和主程序同源的iframe以后\n\n1. 他会拷贝一份分开的全局对象(比如:Object.prototype)。\n2. 这些全局对象可以从父文档中访问,也就是说我们可以在Realms访问这些全局对象. \n\n我们将这些全局对象放入到Proxy的白名单(whitelist)中，这样在插件代码中就可以访问这些全局对象了。通过创建iframe来拷贝全局对象有一个很重要的好处:即使是通过`({}).constructor`对象访问到的全局对象,也会是iframe中拷贝的全局对象。这样的实现方式有这些优点:\n+ 他在主程序中运行。\n+ 因为他本身还是javascript,所以他仍然用JIT编译解析,浏览器对javascript的优化还是有效。\n+ 浏览器开发工具也还是有效的。\n\n那么就剩下最后一个问题.他真的够安全了吗?\n\n这样看起来结合了iframe的Realms看起来似乎已经挺不错的了,而且他本身也是tc39下面的项目,所以可靠性应该也不错。但是光有一个安全的沙盒环境是不够的,你的插件肯定需要和主程序进行交互,那么我们就肯定要为我们的插件系统提供API,提供给插件的API系统也一定要是安全的。\n\n举个例子,`console.log`是浏览器的api是不是javascript功能,那么我们要为插件系统提供一个`console.log`方法,我们可以这样写:\n```js\nrealm.evaluate(USER_CODE, { log: console.log })\n```\n或者为了隐藏方法本身,我们可以要求他只传参数\n```js\nrealm.evaluate(USER_CODE, { log: (...args) => { console.log(...args) } })\n```\n看起来是这么回事,很可惜,这其实是一个安全漏洞,即使是第二种方法我们还是在Realms外面创建了一个匿名方法,然后直接传入到Realms中。<b>这意味着插件可以通过方法的原型链访问到外部。</b>\n\n正确创建`console.log`方法的方法是,将这个方法通过Realms包裹起来在Realms内部创建像这样\n```js\n// 创建一个工厂方法\n// 这个工厂方法返回一个新的方法他保存一个闭包\nconst safeLogFactory = realm.evaluate(`\n        (function safeLogFactory(unsafeLog) { \n                return function safeLog(...args) {\n                        unsafeLog(...args);\n                }\n        })\n`);\n\n// 创建一个安全的方法\nconst safeLog = safeLogFactory(console.log);\n\nconst outerIntrinsics = safeLog instanceof Function;\nconst innerIntrinsics = realm.evaluate(`log instanceof Function`, { log: safeLog });\nif (outerIntrinsics || !innerIntrinsics) throw new TypeError(); \n\n// 使用\nrealm.evaluate(`log(\"Hello outside world!\")`, { log: safeLog });\n```\n通常来说,在沙盒中不应该能够访问到外部的任何对象包括作用域。因为我们的插件和主程序运行在一个线程中，所以在提供api的时候要非常小心,特别是当你的api需要在realm内部操作外部对象的时候。这对于开发api的开发人员来说是不是有点太不友好了，一不小心就产生了安全隐患，(todo:完善起来)。\n\n## 结论\n如果我们的主程序不是特别复杂而且庞大的话,第一种通过iframe的实现方式应该是最为简单的。\n\n如果我们的主程序本身就是通过WebAssembly创建的例如CAD网页版,我们想第二种方式可能是比较适合他们的,或者他们提供更加优秀的基于WebAssembly的解决方案\n\n最后一种方式如果我们能提供一种简单又安全的开发API的办法,这应该是一种性价比比较高的解决方案。\n","slug":"如何为平台设计一个插件系统","published":1,"updated":"2019-09-18T01:43:40.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufxw001y4sefqirsd471","content":"<p>随着web浏览器的发展,浏览器的性能越来越好,WebGL和WebAssembly提供越来越多的可能性。很多原本只能在终端运行的程序都开始开发web版本例如CAD的web版本,PS的web版本,figma。这一个个的设计协作平台原本在终端都有插件机制。那么如果在web端能提供一个插件机制,对于有一点编程能力的用户,就可以提供更好的用户体验和开发更多的可能性。如何开发一个好的插件系统呢?</p>\n<p>一个javascript的插件系统需要满足以下几个方面:</p>\n<h4 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><ul>\n<li>插件不可以发送请求</li>\n<li>插件和程序模块不可以非法的调用相互的数据</li>\n<li>插件不可以在不受约束的情况下执行</li>\n<li>插件不可以任意的修改UI,从而给用户造成误导</li>\n</ul>\n<h4 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h4><ul>\n<li>插件不能影响主程序的稳定性</li>\n<li>插件不可以修改主程序中的常量</li>\n</ul>\n<h4 id=\"易开发性\"><a href=\"#易开发性\" class=\"headerlink\" title=\"易开发性\"></a>易开发性</h4><ul>\n<li>插件应该是容易开发的,即使是面对没有那么多编程经验的设计师,也应该是容易开发的。</li>\n<li>插件要可以使用调试工具。</li>\n</ul>\n<h4 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h4><ul>\n<li>插件的执行效率不能太慢从而影响整个主程序的效率。</li>\n</ul>\n<h2 id=\"方案一-iframe沙盒实现方式\"><a href=\"#方案一-iframe沙盒实现方式\" class=\"headerlink\" title=\"方案一:iframe沙盒实现方式\"></a>方案一:iframe沙盒实现方式</h2><p>当我们在程序中执行第三方的代码的时候,首先第一个应该会想到的就是iframe。iframe不是我们每天都会用到的html标签。要理解为什么iframe为什么安全，我们有不要想一下iframe标签是用来干什么的。</p>\n<p>iframe比较典型的使用场景就是在一个网页中嵌入一个其他的网页。举个例子来说,你需要在网站中嵌入谷歌地图的页面来实现地图的展现功能。你不会希望谷歌地图的页面中的代码有能力访问你本身的一些代码和敏感数据,相应的谷歌地图也不希望你能够访问他页面中的数据和代码。</p>\n<p>这意味着一切和iframe的交互都受限于浏览器。当iframe和原网页有不同的域(imow.cn和google.com),他们是完全隔绝的。那么网页和iframe交互的唯一办法就是通过 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\" target=\"_blank\" rel=\"noopener\"><code>postMessage</code></a>。这个message是一个string。需要交互的双方可以选择忽略这个message或者做对应的动作。</p>\n<p>iframe和原网页是完全独立的,其实,如果你想要的话浏览器允许我们通过另外一个线程来创建一个iframe。<a href=\"https://www.chromium.org/developers/design-documents/oop-iframes\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<p>当我们了解了iframe是如何工作了以后,我们可以在我们需要执行第三方插件的时候创一个iframe，将插件的代码在iframe中执行。在iframe中插件可以执行任何代码,也不会影响到主程序,除非通过提前申明好的message。同时我们可以给iframe的域名设置为null,这意味着根据浏览器<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener\">跨域保护策略</a>,iframe无法给域名发送任何请求。</p>\n<p>iframe就这样很简单的成为我们执行第三方插件的沙盒环境,他的安全性也通过浏览器来保证。插件在沙盒中执行,通过主程序提供的api(postMeassge)和主程序进行交互。代码就像下面这个样子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scene = <span class=\"keyword\">await</span> main.loadScene() <span class=\"comment\">// 从主程序获取界面数据</span></span><br><span class=\"line\">scene.selection[<span class=\"number\">0</span>].width *= <span class=\"number\">2</span>  <span class=\"comment\">// 修改界面数据</span></span><br><span class=\"line\">scene.createNode(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'RECTANGLE'</span>,</span><br><span class=\"line\">  x: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">await</span> main.updateScene() <span class=\"comment\">// 向主程序发送修改后的界面数据</span></span><br></pre></td></tr></table></figure>\n\n<p>这里主要的代码是loadScene(发送消息给主程序,然后获得主程序界面的document拷贝),然后修改完以后通过调用updateScene(发送更新消息给主程序).这里需要注意的是</p>\n<ul>\n<li>我们拷贝了整个document而不是在每次需要读取或者修改属性的时候通过message传输.postMessage每次传输需要0.1ms.每秒钟大约只允许1000 messages。</li>\n<li>我们没有让插件直接使用postMessage api,而是包装了一个api给插件用户使用,这样使用起来不会太笨重。</li>\n</ul>\n<h3 id=\"问题-1-async-await-使用起来不是那么方便\"><a href=\"#问题-1-async-await-使用起来不是那么方便\" class=\"headerlink\" title=\"问题#1:async/await 使用起来不是那么方便\"></a>问题#1:async/await 使用起来不是那么方便</h3><p>这种实现方式第一个问题就是对于一些不那么了解javascript的新手或者设计师来说,<code>async/await</code>关键字还是非常陌生的。但是要使用postMessge是一个异步操作。所以不可避免的要使用<code>async/await</code>来控制异步流程。但是如果只是需要在开头和结束的时候调用我们的api还方便,我们可以告诉用户在调用我们的api时候在前面加上<code>async/await</code>即使他们不知道这个关键字的作用也不会对他们的操作造成非常大的困扰。</p>\n<p>但是问题是有些插件需要执行非常复杂的逻辑,在修改一个layout的属性的时候有时候会引起其他好几个layout的更新。比如更新外层的layout的属性之后,内部的layout的属性也可能发生了更新,这个时候你需要先提交你的属性,然后在重新或者视图的属性,那这个时候你的代码就会变成这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> mian.loadScene()</span><br><span class=\"line\">... 操作 ...</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.updateScene()</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.loadScene()</span><br><span class=\"line\">... 操作 ...</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.updateScene()</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.loadScene()</span><br><span class=\"line\">... 操作 ...</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.updateScene()</span><br></pre></td></tr></table></figure>\n\n<p>这个代码一下子就变的不可控了,而且用户也很难确认什么时候应该要提交我的属性更新。</p>\n<h3 id=\"问题-2-拷贝视图给iframe的操作是非常昂贵的\"><a href=\"#问题-2-拷贝视图给iframe的操作是非常昂贵的\" class=\"headerlink\" title=\"问题#2:拷贝视图给iframe的操作是非常昂贵的\"></a>问题#2:拷贝视图给iframe的操作是非常昂贵的</h3><p>iframe这种实现方式的第二个问题就是,当你需要给插件发送视图信息的时候你需要序列化你的document发送给你iframe，当你的视图非常非常大的时候,这个序列化的操作是非常耗时的,甚至会导致内存溢出。<br>即使我们可以使用增量的加载数据或者懒加载数据这种方式仍然有他的问题:</p>\n<ul>\n<li>首先这种方式是非常难实现的,即使有比较好的方案实现了以后,面对比较大的视图,性能仍然不是很理想,而且对于插件开发者来说是非常难理解的，这违背了我们的插件易开发性。</li>\n<li>异步方法需要等待你需要到的数据达到才能开始后面的操作,对于异步流程控制来说也是一个挑战(steam? Rx?)。</li>\n</ul>\n<p>总的来说如果你的主程序有非常大的document要交给第三方插件来进行操作,那么iframe的这种实现方式就不是非常理想的解决方案</p>\n<h3 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h3><p>如果能在主线程上执行插件代码,那么在性能上就会好很多,但是我们又不能简单的<code>eval(code)</code>执行插件代码,因为这样是很不安全的。</p>\n<h4 id=\"什么导致eval不安全\"><a href=\"#什么导致eval不安全\" class=\"headerlink\" title=\"什么导致eval不安全\"></a>什么导致eval不安全</h4><p>如果我们退一步想:是什么使<code>eval</code>方法不安全?如果我们只是执行一段很单纯的代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> code = <span class=\"string\">'let a = (7 + 1) * 8;'</span></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(code)</span><br></pre></td></tr></table></figure>\n\n<p>如果只是一段逻辑代码,那么这个代码是没有什么不安全的。之所以认为eval执行的代码不安全是因为<b>在插件代码中有可能会发送网络请求,修改全局的state变量,或者直接修改dom对象等等</b>这些使得我们的插件代码变的不可控,换句话来说是<b>插件具有浏览器api访问的能力让我们插件的代码变的不可控</b>。</p>\n<h3 id=\"是不是能把全局的对象藏起来\"><a href=\"#是不是能把全局的对象藏起来\" class=\"headerlink\" title=\"是不是能把全局的对象藏起来?\"></a>是不是能把全局的对象藏起来?</h3><p>如果我们能把全局的对象藏起来,保证插件代码中只能做变量的赋值或者一些if判断的逻辑代码,没有了全局对象xhr,插件将无法发送请求,没有document对象,插件也不具备访问dom的能力,那么插件能力是不是能在我们的可控范围里面了。</p>\n<p>隐藏全局对象,理论上是可行的。但是我们很难仅仅通过隐藏全局对象来创建一个绝对安全的运行环境。举例来说,我们现在把window对象设置为null,但是代码还是可以通过<code>({}).constructor</code>来访问全局对象。所以找到所有有可能访问危险api的对象,把所有的路全部堵死是非常难的一件事情。</p>\n<p>是不是我们可以找到一个这些全局对象从一开始就不存在的沙盒环境?</p>\n<h2 id=\"方案二-将javascript编译成WebAssembly\"><a href=\"#方案二-将javascript编译成WebAssembly\" class=\"headerlink\" title=\"方案二:将javascript编译成WebAssembly\"></a>方案二:将javascript编译成WebAssembly</h2><p><a href=\"https://github.com/svaarala/duktape\" target=\"_blank\" rel=\"noopener\">Duktape</a>是一个轻量级的用c++写的javascript解释器,他可以将javascript编译成WebAssembly,经过<a href=\"https://github.com/tc39/test262/tree/es5-tests\" target=\"_blank\" rel=\"noopener\">test262</a>测试之后,可以确定他全面的支持了ES5的语法。</p>\n<p>这种实现方法有以下几种优缺点</p>\n<ul>\n<li>首先这是一种安全的执行环境,因为Duktape不支持任何的浏览器API。作为WebAssembly执行,他本身就是一个沙盒环境,他可以通过提供一个白名单的API和主程序进行交互。</li>\n<li>这个解释器是运行在主线程上的。这意味着我们可以创建一个基于主线程的API。(共享document等)</li>\n<li>他可能会比原本的javascript慢一些,因为JIT解释器在编译的时候做了很多的优化,但是作为WebAssembly我相信这个性能应该也是可以被接受的。</li>\n<li>他需要用浏览器来编译WebAssembly,这会有一些性能消耗。</li>\n<li>浏览器的调试工具就不能用了。</li>\n</ul>\n<p>看起来好像不错，但是他作为一个线上项目的表现到底怎么样呢?一个javascript引擎来执行另外一个引擎?WebAssembly本身也是比较新的一个东西，我们是不是真的需要一个相对复杂的解决方案?有没有更简单的方法了?</p>\n<h2 id=\"方案三-Realms\"><a href=\"#方案三-Realms\" class=\"headerlink\" title=\"方案三:Realms\"></a>方案三:Realms</h2><p>这个技术可以创建一个沙盒环境来支持插件,当我看到他readme文档的时候,就一下子提起了我的兴趣,<a href=\"https://github.com/tc39/proposal-realms#intuitions\" target=\"_blank\" rel=\"noopener\">Intuitions</a></p>\n<ul>\n<li>sandbox</li>\n<li>iframe without DOM</li>\n<li>principled version of Node’s ‘vm’ module</li>\n<li>sync Worker</li>\n</ul>\n<p>这不就是我们需要的吗?他的代码看起来是这个样子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> g = <span class=\"built_in\">window</span>; <span class=\"comment\">// outer global</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"keyword\">new</span> Realm(); <span class=\"comment\">// root realm</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = r.evaluate(<span class=\"string\">\"(function() &#123; return 17 &#125;)\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">f() === <span class=\"number\">17</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.getPrototypeOf(f) === g.Function.prototype <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.getPrototypeOf(f) === r.global.Function.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是很酷。这个技术其实可以用现在已有的但是不常用的一个javascript功能来实现。代码想这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simplifiedEval</span>(<span class=\"params\">scopeProxy, code</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span></span><br><span class=\"line\">  <span class=\"keyword\">with</span> (scopeProxy) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(code)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个就像一个简单版本的Realms,但是管中窥豹,我们可以看见两个关键代码<code>with</code>和<code>Proxy</code>对象。</p>\n<p><code>with(obj)</code>表达式创建了一个作用域,当寻找变量的时候,可以使用这个<code>obj</code>的属性.看个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> (<span class=\"built_in\">Math</span>) &#123;</span><br><span class=\"line\">  a = PI * r * r</span><br><span class=\"line\">  x = r * cos(PI)</span><br><span class=\"line\">  y = r * sin(PI)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x,  y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里,当我们访问<code>PI</code>,<code>cos</code>,<code>sin</code>的时候,就会找到<code>Math</code>的属性。但是<code>console</code>因为<code>Math</code>没有就仍然会找到全局对象。</p>\n<p>知道了<code>with</code>表达式,接下来就是<code>Proxy</code>对象,这个对象有下面几个特性</p>\n<ul>\n<li>他是一个普通的javascript对象,可以通过<code>obj.x</code>访问对象的属性值.</li>\n<li>我们可以实现一个对象属性的<code>get</code>方法来实现<code>obj.x</code>操作,实际上只执行这个<code>get</code>方法.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scopeProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(whitelist, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>(target, prop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// target === whitelist</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target[prop]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们就可以把这个<code>scopeProxy</code>对象作为参数传入<code>with</code>中,他就捕获作用域所有的变量查找,在这个<code>scopeProxy</code>的get方法中进行查找这个变量:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> (scopeProxy) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span> <span class=\"comment\">// undefined!</span></span><br><span class=\"line\">  <span class=\"built_in\">eval</span>(<span class=\"string\">\"xhr\"</span>) <span class=\"comment\">// undefined!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里只有whitelist的属性会被返回,其他都会返回<code>undefined</code>.但是其实利用一些类似<code>({}).constructor</code>表达式还是有可能访问全局对象的.此外,这个沙盒其实还是需要访问一些全局对象的方法的,类似<code>Object.keys</code></p>\n<p>为要给我们的插件系统访问受限全局api的方法然后又不会把window搞乱,Realms沙盒通过创建一个和主程序同源的<code>iframe</code>用来拷贝需要用到的全局API。这个iframe和我们第一种实现中创建的iframe不一样,他不是作为运行程序的沙盒。当你创建一个和主程序同源的iframe以后</p>\n<ol>\n<li>他会拷贝一份分开的全局对象(比如:Object.prototype)。</li>\n<li>这些全局对象可以从父文档中访问,也就是说我们可以在Realms访问这些全局对象. </li>\n</ol>\n<p>我们将这些全局对象放入到Proxy的白名单(whitelist)中，这样在插件代码中就可以访问这些全局对象了。通过创建iframe来拷贝全局对象有一个很重要的好处:即使是通过<code>({}).constructor</code>对象访问到的全局对象,也会是iframe中拷贝的全局对象。这样的实现方式有这些优点:</p>\n<ul>\n<li>他在主程序中运行。</li>\n<li>因为他本身还是javascript,所以他仍然用JIT编译解析,浏览器对javascript的优化还是有效。</li>\n<li>浏览器开发工具也还是有效的。</li>\n</ul>\n<p>那么就剩下最后一个问题.他真的够安全了吗?</p>\n<p>这样看起来结合了iframe的Realms看起来似乎已经挺不错的了,而且他本身也是tc39下面的项目,所以可靠性应该也不错。但是光有一个安全的沙盒环境是不够的,你的插件肯定需要和主程序进行交互,那么我们就肯定要为我们的插件系统提供API,提供给插件的API系统也一定要是安全的。</p>\n<p>举个例子,<code>console.log</code>是浏览器的api是不是javascript功能,那么我们要为插件系统提供一个<code>console.log</code>方法,我们可以这样写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realm.evaluate(USER_CODE, &#123; <span class=\"attr\">log</span>: <span class=\"built_in\">console</span>.log &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>或者为了隐藏方法本身,我们可以要求他只传参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realm.evaluate(USER_CODE, &#123; <span class=\"attr\">log</span>: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(...args) &#125; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>看起来是这么回事,很可惜,这其实是一个安全漏洞,即使是第二种方法我们还是在Realms外面创建了一个匿名方法,然后直接传入到Realms中。<b>这意味着插件可以通过方法的原型链访问到外部。</b></p>\n<p>正确创建<code>console.log</code>方法的方法是,将这个方法通过Realms包裹起来在Realms内部创建像这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个工厂方法</span></span><br><span class=\"line\"><span class=\"comment\">// 这个工厂方法返回一个新的方法他保存一个闭包</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> safeLogFactory = realm.evaluate(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        (function safeLogFactory(unsafeLog) &#123; </span></span><br><span class=\"line\"><span class=\"string\">                return function safeLog(...args) &#123;</span></span><br><span class=\"line\"><span class=\"string\">                        unsafeLog(...args);</span></span><br><span class=\"line\"><span class=\"string\">                &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;)</span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个安全的方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> safeLog = safeLogFactory(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> outerIntrinsics = safeLog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> innerIntrinsics = realm.evaluate(<span class=\"string\">`log instanceof Function`</span>, &#123; <span class=\"attr\">log</span>: safeLog &#125;);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (outerIntrinsics || !innerIntrinsics) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">realm.evaluate(<span class=\"string\">`log(\"Hello outside world!\")`</span>, &#123; <span class=\"attr\">log</span>: safeLog &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通常来说,在沙盒中不应该能够访问到外部的任何对象包括作用域。因为我们的插件和主程序运行在一个线程中，所以在提供api的时候要非常小心,特别是当你的api需要在realm内部操作外部对象的时候。这对于开发api的开发人员来说是不是有点太不友好了，一不小心就产生了安全隐患，(todo:完善起来)。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果我们的主程序不是特别复杂而且庞大的话,第一种通过iframe的实现方式应该是最为简单的。</p>\n<p>如果我们的主程序本身就是通过WebAssembly创建的例如CAD网页版,我们想第二种方式可能是比较适合他们的,或者他们提供更加优秀的基于WebAssembly的解决方案</p>\n<p>最后一种方式如果我们能提供一种简单又安全的开发API的办法,这应该是一种性价比比较高的解决方案。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>随着web浏览器的发展,浏览器的性能越来越好,WebGL和WebAssembly提供越来越多的可能性。很多原本只能在终端运行的程序都开始开发web版本例如CAD的web版本,PS的web版本,figma。这一个个的设计协作平台原本在终端都有插件机制。那么如果在web端能提供一个插件机制,对于有一点编程能力的用户,就可以提供更好的用户体验和开发更多的可能性。如何开发一个好的插件系统呢?</p>\n<p>一个javascript的插件系统需要满足以下几个方面:</p>\n<h4 id=\"安全性\"><a href=\"#安全性\" class=\"headerlink\" title=\"安全性\"></a>安全性</h4><ul>\n<li>插件不可以发送请求</li>\n<li>插件和程序模块不可以非法的调用相互的数据</li>\n<li>插件不可以在不受约束的情况下执行</li>\n<li>插件不可以任意的修改UI,从而给用户造成误导</li>\n</ul>\n<h4 id=\"稳定性\"><a href=\"#稳定性\" class=\"headerlink\" title=\"稳定性\"></a>稳定性</h4><ul>\n<li>插件不能影响主程序的稳定性</li>\n<li>插件不可以修改主程序中的常量</li>\n</ul>\n<h4 id=\"易开发性\"><a href=\"#易开发性\" class=\"headerlink\" title=\"易开发性\"></a>易开发性</h4><ul>\n<li>插件应该是容易开发的,即使是面对没有那么多编程经验的设计师,也应该是容易开发的。</li>\n<li>插件要可以使用调试工具。</li>\n</ul>\n<h4 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h4><ul>\n<li>插件的执行效率不能太慢从而影响整个主程序的效率。</li>\n</ul>\n<h2 id=\"方案一-iframe沙盒实现方式\"><a href=\"#方案一-iframe沙盒实现方式\" class=\"headerlink\" title=\"方案一:iframe沙盒实现方式\"></a>方案一:iframe沙盒实现方式</h2><p>当我们在程序中执行第三方的代码的时候,首先第一个应该会想到的就是iframe。iframe不是我们每天都会用到的html标签。要理解为什么iframe为什么安全，我们有不要想一下iframe标签是用来干什么的。</p>\n<p>iframe比较典型的使用场景就是在一个网页中嵌入一个其他的网页。举个例子来说,你需要在网站中嵌入谷歌地图的页面来实现地图的展现功能。你不会希望谷歌地图的页面中的代码有能力访问你本身的一些代码和敏感数据,相应的谷歌地图也不希望你能够访问他页面中的数据和代码。</p>\n<p>这意味着一切和iframe的交互都受限于浏览器。当iframe和原网页有不同的域(imow.cn和google.com),他们是完全隔绝的。那么网页和iframe交互的唯一办法就是通过 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage\" target=\"_blank\" rel=\"noopener\"><code>postMessage</code></a>。这个message是一个string。需要交互的双方可以选择忽略这个message或者做对应的动作。</p>\n<p>iframe和原网页是完全独立的,其实,如果你想要的话浏览器允许我们通过另外一个线程来创建一个iframe。<a href=\"https://www.chromium.org/developers/design-documents/oop-iframes\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<p>当我们了解了iframe是如何工作了以后,我们可以在我们需要执行第三方插件的时候创一个iframe，将插件的代码在iframe中执行。在iframe中插件可以执行任何代码,也不会影响到主程序,除非通过提前申明好的message。同时我们可以给iframe的域名设置为null,这意味着根据浏览器<a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS\" target=\"_blank\" rel=\"noopener\">跨域保护策略</a>,iframe无法给域名发送任何请求。</p>\n<p>iframe就这样很简单的成为我们执行第三方插件的沙盒环境,他的安全性也通过浏览器来保证。插件在沙盒中执行,通过主程序提供的api(postMeassge)和主程序进行交互。代码就像下面这个样子</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scene = <span class=\"keyword\">await</span> main.loadScene() <span class=\"comment\">// 从主程序获取界面数据</span></span><br><span class=\"line\">scene.selection[<span class=\"number\">0</span>].width *= <span class=\"number\">2</span>  <span class=\"comment\">// 修改界面数据</span></span><br><span class=\"line\">scene.createNode(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'RECTANGLE'</span>,</span><br><span class=\"line\">  x: <span class=\"number\">10</span>, <span class=\"attr\">y</span>: <span class=\"number\">20</span>,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">await</span> main.updateScene() <span class=\"comment\">// 向主程序发送修改后的界面数据</span></span><br></pre></td></tr></table></figure>\n\n<p>这里主要的代码是loadScene(发送消息给主程序,然后获得主程序界面的document拷贝),然后修改完以后通过调用updateScene(发送更新消息给主程序).这里需要注意的是</p>\n<ul>\n<li>我们拷贝了整个document而不是在每次需要读取或者修改属性的时候通过message传输.postMessage每次传输需要0.1ms.每秒钟大约只允许1000 messages。</li>\n<li>我们没有让插件直接使用postMessage api,而是包装了一个api给插件用户使用,这样使用起来不会太笨重。</li>\n</ul>\n<h3 id=\"问题-1-async-await-使用起来不是那么方便\"><a href=\"#问题-1-async-await-使用起来不是那么方便\" class=\"headerlink\" title=\"问题#1:async/await 使用起来不是那么方便\"></a>问题#1:async/await 使用起来不是那么方便</h3><p>这种实现方式第一个问题就是对于一些不那么了解javascript的新手或者设计师来说,<code>async/await</code>关键字还是非常陌生的。但是要使用postMessge是一个异步操作。所以不可避免的要使用<code>async/await</code>来控制异步流程。但是如果只是需要在开头和结束的时候调用我们的api还方便,我们可以告诉用户在调用我们的api时候在前面加上<code>async/await</code>即使他们不知道这个关键字的作用也不会对他们的操作造成非常大的困扰。</p>\n<p>但是问题是有些插件需要执行非常复杂的逻辑,在修改一个layout的属性的时候有时候会引起其他好几个layout的更新。比如更新外层的layout的属性之后,内部的layout的属性也可能发生了更新,这个时候你需要先提交你的属性,然后在重新或者视图的属性,那这个时候你的代码就会变成这样:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">await</span> mian.loadScene()</span><br><span class=\"line\">... 操作 ...</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.updateScene()</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.loadScene()</span><br><span class=\"line\">... 操作 ...</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.updateScene()</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.loadScene()</span><br><span class=\"line\">... 操作 ...</span><br><span class=\"line\"><span class=\"keyword\">await</span> mian.updateScene()</span><br></pre></td></tr></table></figure>\n\n<p>这个代码一下子就变的不可控了,而且用户也很难确认什么时候应该要提交我的属性更新。</p>\n<h3 id=\"问题-2-拷贝视图给iframe的操作是非常昂贵的\"><a href=\"#问题-2-拷贝视图给iframe的操作是非常昂贵的\" class=\"headerlink\" title=\"问题#2:拷贝视图给iframe的操作是非常昂贵的\"></a>问题#2:拷贝视图给iframe的操作是非常昂贵的</h3><p>iframe这种实现方式的第二个问题就是,当你需要给插件发送视图信息的时候你需要序列化你的document发送给你iframe，当你的视图非常非常大的时候,这个序列化的操作是非常耗时的,甚至会导致内存溢出。<br>即使我们可以使用增量的加载数据或者懒加载数据这种方式仍然有他的问题:</p>\n<ul>\n<li>首先这种方式是非常难实现的,即使有比较好的方案实现了以后,面对比较大的视图,性能仍然不是很理想,而且对于插件开发者来说是非常难理解的，这违背了我们的插件易开发性。</li>\n<li>异步方法需要等待你需要到的数据达到才能开始后面的操作,对于异步流程控制来说也是一个挑战(steam? Rx?)。</li>\n</ul>\n<p>总的来说如果你的主程序有非常大的document要交给第三方插件来进行操作,那么iframe的这种实现方式就不是非常理想的解决方案</p>\n<h3 id=\"eval\"><a href=\"#eval\" class=\"headerlink\" title=\"eval\"></a>eval</h3><p>如果能在主线程上执行插件代码,那么在性能上就会好很多,但是我们又不能简单的<code>eval(code)</code>执行插件代码,因为这样是很不安全的。</p>\n<h4 id=\"什么导致eval不安全\"><a href=\"#什么导致eval不安全\" class=\"headerlink\" title=\"什么导致eval不安全\"></a>什么导致eval不安全</h4><p>如果我们退一步想:是什么使<code>eval</code>方法不安全?如果我们只是执行一段很单纯的代码</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> code = <span class=\"string\">'let a = (7 + 1) * 8;'</span></span><br><span class=\"line\"><span class=\"built_in\">eval</span>(code)</span><br></pre></td></tr></table></figure>\n\n<p>如果只是一段逻辑代码,那么这个代码是没有什么不安全的。之所以认为eval执行的代码不安全是因为<b>在插件代码中有可能会发送网络请求,修改全局的state变量,或者直接修改dom对象等等</b>这些使得我们的插件代码变的不可控,换句话来说是<b>插件具有浏览器api访问的能力让我们插件的代码变的不可控</b>。</p>\n<h3 id=\"是不是能把全局的对象藏起来\"><a href=\"#是不是能把全局的对象藏起来\" class=\"headerlink\" title=\"是不是能把全局的对象藏起来?\"></a>是不是能把全局的对象藏起来?</h3><p>如果我们能把全局的对象藏起来,保证插件代码中只能做变量的赋值或者一些if判断的逻辑代码,没有了全局对象xhr,插件将无法发送请求,没有document对象,插件也不具备访问dom的能力,那么插件能力是不是能在我们的可控范围里面了。</p>\n<p>隐藏全局对象,理论上是可行的。但是我们很难仅仅通过隐藏全局对象来创建一个绝对安全的运行环境。举例来说,我们现在把window对象设置为null,但是代码还是可以通过<code>({}).constructor</code>来访问全局对象。所以找到所有有可能访问危险api的对象,把所有的路全部堵死是非常难的一件事情。</p>\n<p>是不是我们可以找到一个这些全局对象从一开始就不存在的沙盒环境?</p>\n<h2 id=\"方案二-将javascript编译成WebAssembly\"><a href=\"#方案二-将javascript编译成WebAssembly\" class=\"headerlink\" title=\"方案二:将javascript编译成WebAssembly\"></a>方案二:将javascript编译成WebAssembly</h2><p><a href=\"https://github.com/svaarala/duktape\" target=\"_blank\" rel=\"noopener\">Duktape</a>是一个轻量级的用c++写的javascript解释器,他可以将javascript编译成WebAssembly,经过<a href=\"https://github.com/tc39/test262/tree/es5-tests\" target=\"_blank\" rel=\"noopener\">test262</a>测试之后,可以确定他全面的支持了ES5的语法。</p>\n<p>这种实现方法有以下几种优缺点</p>\n<ul>\n<li>首先这是一种安全的执行环境,因为Duktape不支持任何的浏览器API。作为WebAssembly执行,他本身就是一个沙盒环境,他可以通过提供一个白名单的API和主程序进行交互。</li>\n<li>这个解释器是运行在主线程上的。这意味着我们可以创建一个基于主线程的API。(共享document等)</li>\n<li>他可能会比原本的javascript慢一些,因为JIT解释器在编译的时候做了很多的优化,但是作为WebAssembly我相信这个性能应该也是可以被接受的。</li>\n<li>他需要用浏览器来编译WebAssembly,这会有一些性能消耗。</li>\n<li>浏览器的调试工具就不能用了。</li>\n</ul>\n<p>看起来好像不错，但是他作为一个线上项目的表现到底怎么样呢?一个javascript引擎来执行另外一个引擎?WebAssembly本身也是比较新的一个东西，我们是不是真的需要一个相对复杂的解决方案?有没有更简单的方法了?</p>\n<h2 id=\"方案三-Realms\"><a href=\"#方案三-Realms\" class=\"headerlink\" title=\"方案三:Realms\"></a>方案三:Realms</h2><p>这个技术可以创建一个沙盒环境来支持插件,当我看到他readme文档的时候,就一下子提起了我的兴趣,<a href=\"https://github.com/tc39/proposal-realms#intuitions\" target=\"_blank\" rel=\"noopener\">Intuitions</a></p>\n<ul>\n<li>sandbox</li>\n<li>iframe without DOM</li>\n<li>principled version of Node’s ‘vm’ module</li>\n<li>sync Worker</li>\n</ul>\n<p>这不就是我们需要的吗?他的代码看起来是这个样子</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> g = <span class=\"built_in\">window</span>; <span class=\"comment\">// outer global</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> r = <span class=\"keyword\">new</span> Realm(); <span class=\"comment\">// root realm</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> f = r.evaluate(<span class=\"string\">\"(function() &#123; return 17 &#125;)\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">f() === <span class=\"number\">17</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.getPrototypeOf(f) === g.Function.prototype <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Reflect</span>.getPrototypeOf(f) === r.global.Function.prototype <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是很酷。这个技术其实可以用现在已有的但是不常用的一个javascript功能来实现。代码想这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">simplifiedEval</span>(<span class=\"params\">scopeProxy, code</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"meta\">  'use strict'</span></span><br><span class=\"line\">  <span class=\"keyword\">with</span> (scopeProxy) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">eval</span>(code)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个就像一个简单版本的Realms,但是管中窥豹,我们可以看见两个关键代码<code>with</code>和<code>Proxy</code>对象。</p>\n<p><code>with(obj)</code>表达式创建了一个作用域,当寻找变量的时候,可以使用这个<code>obj</code>的属性.看个例子:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> (<span class=\"built_in\">Math</span>) &#123;</span><br><span class=\"line\">  a = PI * r * r</span><br><span class=\"line\">  x = r * cos(PI)</span><br><span class=\"line\">  y = r * sin(PI)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x,  y)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子里,当我们访问<code>PI</code>,<code>cos</code>,<code>sin</code>的时候,就会找到<code>Math</code>的属性。但是<code>console</code>因为<code>Math</code>没有就仍然会找到全局对象。</p>\n<p>知道了<code>with</code>表达式,接下来就是<code>Proxy</code>对象,这个对象有下面几个特性</p>\n<ul>\n<li>他是一个普通的javascript对象,可以通过<code>obj.x</code>访问对象的属性值.</li>\n<li>我们可以实现一个对象属性的<code>get</code>方法来实现<code>obj.x</code>操作,实际上只执行这个<code>get</code>方法.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> scopeProxy = <span class=\"keyword\">new</span> <span class=\"built_in\">Proxy</span>(whitelist, &#123;</span><br><span class=\"line\">  <span class=\"keyword\">get</span>(target, prop) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// target === whitelist</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (prop <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> target[prop]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>接下来我们就可以把这个<code>scopeProxy</code>对象作为参数传入<code>with</code>中,他就捕获作用域所有的变量查找,在这个<code>scopeProxy</code>的get方法中进行查找这个变量:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> (scopeProxy) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span> <span class=\"comment\">// undefined!</span></span><br><span class=\"line\">  <span class=\"built_in\">eval</span>(<span class=\"string\">\"xhr\"</span>) <span class=\"comment\">// undefined!</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这里只有whitelist的属性会被返回,其他都会返回<code>undefined</code>.但是其实利用一些类似<code>({}).constructor</code>表达式还是有可能访问全局对象的.此外,这个沙盒其实还是需要访问一些全局对象的方法的,类似<code>Object.keys</code></p>\n<p>为要给我们的插件系统访问受限全局api的方法然后又不会把window搞乱,Realms沙盒通过创建一个和主程序同源的<code>iframe</code>用来拷贝需要用到的全局API。这个iframe和我们第一种实现中创建的iframe不一样,他不是作为运行程序的沙盒。当你创建一个和主程序同源的iframe以后</p>\n<ol>\n<li>他会拷贝一份分开的全局对象(比如:Object.prototype)。</li>\n<li>这些全局对象可以从父文档中访问,也就是说我们可以在Realms访问这些全局对象. </li>\n</ol>\n<p>我们将这些全局对象放入到Proxy的白名单(whitelist)中，这样在插件代码中就可以访问这些全局对象了。通过创建iframe来拷贝全局对象有一个很重要的好处:即使是通过<code>({}).constructor</code>对象访问到的全局对象,也会是iframe中拷贝的全局对象。这样的实现方式有这些优点:</p>\n<ul>\n<li>他在主程序中运行。</li>\n<li>因为他本身还是javascript,所以他仍然用JIT编译解析,浏览器对javascript的优化还是有效。</li>\n<li>浏览器开发工具也还是有效的。</li>\n</ul>\n<p>那么就剩下最后一个问题.他真的够安全了吗?</p>\n<p>这样看起来结合了iframe的Realms看起来似乎已经挺不错的了,而且他本身也是tc39下面的项目,所以可靠性应该也不错。但是光有一个安全的沙盒环境是不够的,你的插件肯定需要和主程序进行交互,那么我们就肯定要为我们的插件系统提供API,提供给插件的API系统也一定要是安全的。</p>\n<p>举个例子,<code>console.log</code>是浏览器的api是不是javascript功能,那么我们要为插件系统提供一个<code>console.log</code>方法,我们可以这样写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realm.evaluate(USER_CODE, &#123; <span class=\"attr\">log</span>: <span class=\"built_in\">console</span>.log &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>或者为了隐藏方法本身,我们可以要求他只传参数</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">realm.evaluate(USER_CODE, &#123; <span class=\"attr\">log</span>: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(...args) &#125; &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>看起来是这么回事,很可惜,这其实是一个安全漏洞,即使是第二种方法我们还是在Realms外面创建了一个匿名方法,然后直接传入到Realms中。<b>这意味着插件可以通过方法的原型链访问到外部。</b></p>\n<p>正确创建<code>console.log</code>方法的方法是,将这个方法通过Realms包裹起来在Realms内部创建像这样</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 创建一个工厂方法</span></span><br><span class=\"line\"><span class=\"comment\">// 这个工厂方法返回一个新的方法他保存一个闭包</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> safeLogFactory = realm.evaluate(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">        (function safeLogFactory(unsafeLog) &#123; </span></span><br><span class=\"line\"><span class=\"string\">                return function safeLog(...args) &#123;</span></span><br><span class=\"line\"><span class=\"string\">                        unsafeLog(...args);</span></span><br><span class=\"line\"><span class=\"string\">                &#125;</span></span><br><span class=\"line\"><span class=\"string\">        &#125;)</span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个安全的方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> safeLog = safeLogFactory(<span class=\"built_in\">console</span>.log);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> outerIntrinsics = safeLog <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Function</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> innerIntrinsics = realm.evaluate(<span class=\"string\">`log instanceof Function`</span>, &#123; <span class=\"attr\">log</span>: safeLog &#125;);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (outerIntrinsics || !innerIntrinsics) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(); </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用</span></span><br><span class=\"line\">realm.evaluate(<span class=\"string\">`log(\"Hello outside world!\")`</span>, &#123; <span class=\"attr\">log</span>: safeLog &#125;);</span><br></pre></td></tr></table></figure>\n\n<p>通常来说,在沙盒中不应该能够访问到外部的任何对象包括作用域。因为我们的插件和主程序运行在一个线程中，所以在提供api的时候要非常小心,特别是当你的api需要在realm内部操作外部对象的时候。这对于开发api的开发人员来说是不是有点太不友好了，一不小心就产生了安全隐患，(todo:完善起来)。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><p>如果我们的主程序不是特别复杂而且庞大的话,第一种通过iframe的实现方式应该是最为简单的。</p>\n<p>如果我们的主程序本身就是通过WebAssembly创建的例如CAD网页版,我们想第二种方式可能是比较适合他们的,或者他们提供更加优秀的基于WebAssembly的解决方案</p>\n<p>最后一种方式如果我们能提供一种简单又安全的开发API的办法,这应该是一种性价比比较高的解决方案。</p>\n"},{"title":"如何理解ES6中Promise","date":"2019-10-22T10:46:32.000Z","author":"刘涛","_content":"\n\n## 什么是Promise\n/**Promise**/是ES6中的一个内置的对象（实际上是一个构造函数，通过这个构造函数我们可以创建一个/**Promise**/对象），它的出现是为了更好地解决JavaScript中异步编程的问题，传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而/**Promise**/则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且/**Promise**/还增加了许多有用的特性，让我们处理异步编程得心应手。/**Promise**/的英文意思是承诺。\n\n## Promise的特点\n * /**Promise**/有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n * /**Promise**/一共有三种状态，但是他们之间是如何转化的呢？ 其一： 从Pending（进行中）到Resolved（完成）。其二： 从Pending（进行中）到Rejected（已失败）。 且只有这两种形式的转变，即使是Promise对象的结果也无力回天了。\n  \n  但是/**Promise**/并不是完美无缺的，也是有一定的缺点的，如在Pengding时，我们无法取消状态，另外，我们没法判断Pending究竟是刚刚开始的Pending还是即将要完成的Pending。\n\n\n\n  ## 使用Promise\n  直接上码\n  ```JavaScript\n    var promise = new Promise(function(resolve, reject) {\n    // ... some code\n    \n    if (/* 异步操作成功 */){\n    resolve(value);\n    } else {\n    reject(error);\n    }\n    });\n  ```\n  其中，由于Promise是构造函数，所以我们使用new来创建一个对象即可， 值得注意的是：function(resolve, reject){}这个函数是必须要写的，否则就不是Promise了。\n\n  这个函数是为了初始化Promise对象，其中这个函数接受了两个函数作为参数， 如果在函数体中我们执行了resolve函数，那么Promise的状态就会由pending转化为resolved（或fullfilled，两者是相同的），类似的，如果我们执行了reject函数，pending就会变成 rejected。  \n  注意： 这个例子的if语句不是必要的，这里想要表达的意思是如果得到了异步成功的相关结果，我们就将调用resolve，将pending转化为resolved，并且将异步成功后的value值传递进去以便后面使用，说是以便后面使用是因为Promise还有一个then()方法，即可以定义在异步成功（或失败）之后需要做的事情。这也就是resolve和reject内置函数存在的意义了。\n\n　当创建了这个Promise对象之后，就一定会有一个结果了，但是成功和失败还是不确定的，我们需要根据判断结果的成功和失败来做不同的事情，于是用到了then()方法，如下所示：\n ```JavaScript\n    promise.then(function(value) {\n // success\n}, function(error) {\n // failure\n});\n  ```\n  下面这个例子做了详尽的说明\n  ```JavaScript\n    var promise = new Promise(function (resolve, reject) {\n      console.log(\"good\");\n      var a = 10;\n      var b = a + 25;\n      if ( b === 35 ) {\n      // 一旦异步执行成功，我们就调用内置的 resolve函数，将pending状态转化为resolved，并且传入我们希望传出的执行成功后的结果。\n      // 注意： 这里一旦状态转变，那么后面就一定会调用then方法中的第一个参数的函数，然后将我们传入给resolve的参数传给then方法中的第一个方法作为参数，我们就可以在then的第一个方法中使用了。\n      resolve(b);\n      } else {\n      reject(\"异步执行失败\");\n      }\n    });\n    promise.then(function (value) {\n      console.log(\"异步执行成功，输出执行结果：\" + value);\n    }, function (error) {\n      console.log(\"异步执行失败，输出执行结果：\" + error);\n    });\n  ```\n\n\n## Promise的方法\n###  1. Promise.prototype.then()\n上面其实已经介绍了then()方法了，而这里需要强调的有两点。<br>\n第一：then()方法是Promise原型上定义的方法。<br>\n第二：then()方法支持链式调用，上一个then()方法调用后返回的结果回传给下一个then()方法中。\n\n第一：我们在chrome中输入Promise.prototype可以看到下面的例子：\n![Promise.prototype.then()](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/promise01.jpg)\n可以看出在Promise的原型中确实是由then方法的。（注：比如我们想看Array这个内置对象有哪些方法，我们就可以直接在chrome中输入Array.prototype，然后就可以看到对应方法的列表了）\n\n第二： then()的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\nthen()由于支持链式调用，所以也可以这样写成这样：\n ```JavaScript\n    getJSON(\"/posts.json\").then(function(json) {\n      return json.post;\n    }).then(function(post) {\n    // ...\n  });\n  ```\n  第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n  再来看看下面这个例子：\n  ```JavaScript\n    getJSON(\"/post/1.json\").then(function(post) {\n      return getJSON(post.commentURL);\n    }).then(function funcA(comments) {\n      console.log(\"Resolved: \", comments);\n    }, function funcB(err){\n      console.log(\"Rejected: \", err);\n    });\n  ```\n  即第一个then又返回了一个promise，如何这个promise的状态变成了 Resolved，那么就会执行第二个then的第一个函数， 如果变成了 Rejected，就会执行第二个第二个函数。\n\n\n  ### 2.Promise.prototype.catch()\n  Promise.prototype.catch()方法实际上是then(null, rejection)方法的别名， 这里使用catch（）纯粹是为了便于使用和理解。\n  ```JavaScript\n    getJSON('/posts.json').then(function(posts) {\n  // ...\n  }).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n  ```\n  在之前的例子中，我们讲解then()方法接受两个参数，第一个参数是pending变成resolved之后执行的函数，它是必选的； 第二个参数是pending变成rejected之后执行的函数，它是可选的。\n\n  我们建议，最后不要使用第二个参数，取而代之我们最好使用catch（），如下所示：\n   ```JavaScript\n  // bad\n    promise\n    .then(function(data) {\n    // success\n    }, function(err) {\n    // error\n    });\n    \n    // good\n    promise\n    .then(function(data) { //cb\n    // success\n    })\n    .catch(function(err) {\n    // error\n    });\n  ```\n  值得注意的是：catch()方法返回的还是一个Promise对象，我们可以在后面继续使用then进行链式调用。\n\n\n  ### 3.Promise.all()\n  Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例，如下所示：\n  ```JavaScript\n   var p = Promise.all([p1, p2, p3]);\n});\n  ```\n  其中的p1，p2，p3都是Promise对象实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。\n  p的状态由p1，p2，p3决定，分成下面的两种情况：\n  * 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n  * 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n  \n   让我们来看看具体的例子：\n   ```JavaScript\n    // 生成一个Promise对象的数组\n    var promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n    return getJSON(\"/post/\" + id + \".json\");\n    });\n    \n    Promise.all(promises).then(function (posts) {\n    // ...\n    }).catch(function(reason){\n    // ...\n  ```\n  在这个例子中，通过数组的map生成了6个Promise对象，然后作为参数传递给了Promise.all() 只有这6个Promise对象最终返回的都是 resolved时， 才会调用Promise.all()后面then（）方法。\n\n  ### 4.Promise.resolve()\n  如果我们希望将一个现有对象转化为Promise对象，我们就可以使用Promise.resolve()方法。根据参数的不同可以分为4种情况：\n  1. 参数是一个Promise实例<br>\n   如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n  2. 参数是一个thenable对象<br>\n   如果参数是一个thenable对象，即具有then()方法的对象，那么Promise.resolve()就会将该对象立即转化成 Promise对象那个，并立即执行then方法。\n  3. 参数不是具有then方法的对象，或根本就不是对象<br>\n   如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。\n  4. 不带有任何参数<br>\n\n## 总结\n![总结](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/%E6%80%BB%E7%BB%93.jpg)","source":"_posts/如何理解ES6中Promise.md","raw":"---\ntitle: 如何理解ES6中Promise\ndate: 2019-10-22 18:46:32\ntags: Javascript\nauthor: 刘涛\n---\n\n\n## 什么是Promise\n/**Promise**/是ES6中的一个内置的对象（实际上是一个构造函数，通过这个构造函数我们可以创建一个/**Promise**/对象），它的出现是为了更好地解决JavaScript中异步编程的问题，传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而/**Promise**/则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且/**Promise**/还增加了许多有用的特性，让我们处理异步编程得心应手。/**Promise**/的英文意思是承诺。\n\n## Promise的特点\n * /**Promise**/有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。\n * /**Promise**/一共有三种状态，但是他们之间是如何转化的呢？ 其一： 从Pending（进行中）到Resolved（完成）。其二： 从Pending（进行中）到Rejected（已失败）。 且只有这两种形式的转变，即使是Promise对象的结果也无力回天了。\n  \n  但是/**Promise**/并不是完美无缺的，也是有一定的缺点的，如在Pengding时，我们无法取消状态，另外，我们没法判断Pending究竟是刚刚开始的Pending还是即将要完成的Pending。\n\n\n\n  ## 使用Promise\n  直接上码\n  ```JavaScript\n    var promise = new Promise(function(resolve, reject) {\n    // ... some code\n    \n    if (/* 异步操作成功 */){\n    resolve(value);\n    } else {\n    reject(error);\n    }\n    });\n  ```\n  其中，由于Promise是构造函数，所以我们使用new来创建一个对象即可， 值得注意的是：function(resolve, reject){}这个函数是必须要写的，否则就不是Promise了。\n\n  这个函数是为了初始化Promise对象，其中这个函数接受了两个函数作为参数， 如果在函数体中我们执行了resolve函数，那么Promise的状态就会由pending转化为resolved（或fullfilled，两者是相同的），类似的，如果我们执行了reject函数，pending就会变成 rejected。  \n  注意： 这个例子的if语句不是必要的，这里想要表达的意思是如果得到了异步成功的相关结果，我们就将调用resolve，将pending转化为resolved，并且将异步成功后的value值传递进去以便后面使用，说是以便后面使用是因为Promise还有一个then()方法，即可以定义在异步成功（或失败）之后需要做的事情。这也就是resolve和reject内置函数存在的意义了。\n\n　当创建了这个Promise对象之后，就一定会有一个结果了，但是成功和失败还是不确定的，我们需要根据判断结果的成功和失败来做不同的事情，于是用到了then()方法，如下所示：\n ```JavaScript\n    promise.then(function(value) {\n // success\n}, function(error) {\n // failure\n});\n  ```\n  下面这个例子做了详尽的说明\n  ```JavaScript\n    var promise = new Promise(function (resolve, reject) {\n      console.log(\"good\");\n      var a = 10;\n      var b = a + 25;\n      if ( b === 35 ) {\n      // 一旦异步执行成功，我们就调用内置的 resolve函数，将pending状态转化为resolved，并且传入我们希望传出的执行成功后的结果。\n      // 注意： 这里一旦状态转变，那么后面就一定会调用then方法中的第一个参数的函数，然后将我们传入给resolve的参数传给then方法中的第一个方法作为参数，我们就可以在then的第一个方法中使用了。\n      resolve(b);\n      } else {\n      reject(\"异步执行失败\");\n      }\n    });\n    promise.then(function (value) {\n      console.log(\"异步执行成功，输出执行结果：\" + value);\n    }, function (error) {\n      console.log(\"异步执行失败，输出执行结果：\" + error);\n    });\n  ```\n\n\n## Promise的方法\n###  1. Promise.prototype.then()\n上面其实已经介绍了then()方法了，而这里需要强调的有两点。<br>\n第一：then()方法是Promise原型上定义的方法。<br>\n第二：then()方法支持链式调用，上一个then()方法调用后返回的结果回传给下一个then()方法中。\n\n第一：我们在chrome中输入Promise.prototype可以看到下面的例子：\n![Promise.prototype.then()](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/promise01.jpg)\n可以看出在Promise的原型中确实是由then方法的。（注：比如我们想看Array这个内置对象有哪些方法，我们就可以直接在chrome中输入Array.prototype，然后就可以看到对应方法的列表了）\n\n第二： then()的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。\nthen()由于支持链式调用，所以也可以这样写成这样：\n ```JavaScript\n    getJSON(\"/posts.json\").then(function(json) {\n      return json.post;\n    }).then(function(post) {\n    // ...\n  });\n  ```\n  第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。\n\n  再来看看下面这个例子：\n  ```JavaScript\n    getJSON(\"/post/1.json\").then(function(post) {\n      return getJSON(post.commentURL);\n    }).then(function funcA(comments) {\n      console.log(\"Resolved: \", comments);\n    }, function funcB(err){\n      console.log(\"Rejected: \", err);\n    });\n  ```\n  即第一个then又返回了一个promise，如何这个promise的状态变成了 Resolved，那么就会执行第二个then的第一个函数， 如果变成了 Rejected，就会执行第二个第二个函数。\n\n\n  ### 2.Promise.prototype.catch()\n  Promise.prototype.catch()方法实际上是then(null, rejection)方法的别名， 这里使用catch（）纯粹是为了便于使用和理解。\n  ```JavaScript\n    getJSON('/posts.json').then(function(posts) {\n  // ...\n  }).catch(function(error) {\n  // 处理 getJSON 和 前一个回调函数运行时发生的错误\n  console.log('发生错误！', error);\n});\n  ```\n  在之前的例子中，我们讲解then()方法接受两个参数，第一个参数是pending变成resolved之后执行的函数，它是必选的； 第二个参数是pending变成rejected之后执行的函数，它是可选的。\n\n  我们建议，最后不要使用第二个参数，取而代之我们最好使用catch（），如下所示：\n   ```JavaScript\n  // bad\n    promise\n    .then(function(data) {\n    // success\n    }, function(err) {\n    // error\n    });\n    \n    // good\n    promise\n    .then(function(data) { //cb\n    // success\n    })\n    .catch(function(err) {\n    // error\n    });\n  ```\n  值得注意的是：catch()方法返回的还是一个Promise对象，我们可以在后面继续使用then进行链式调用。\n\n\n  ### 3.Promise.all()\n  Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例，如下所示：\n  ```JavaScript\n   var p = Promise.all([p1, p2, p3]);\n});\n  ```\n  其中的p1，p2，p3都是Promise对象实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。\n  p的状态由p1，p2，p3决定，分成下面的两种情况：\n  * 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。\n  * 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。\n  \n   让我们来看看具体的例子：\n   ```JavaScript\n    // 生成一个Promise对象的数组\n    var promises = [2, 3, 5, 7, 11, 13].map(function (id) {\n    return getJSON(\"/post/\" + id + \".json\");\n    });\n    \n    Promise.all(promises).then(function (posts) {\n    // ...\n    }).catch(function(reason){\n    // ...\n  ```\n  在这个例子中，通过数组的map生成了6个Promise对象，然后作为参数传递给了Promise.all() 只有这6个Promise对象最终返回的都是 resolved时， 才会调用Promise.all()后面then（）方法。\n\n  ### 4.Promise.resolve()\n  如果我们希望将一个现有对象转化为Promise对象，我们就可以使用Promise.resolve()方法。根据参数的不同可以分为4种情况：\n  1. 参数是一个Promise实例<br>\n   如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。\n  2. 参数是一个thenable对象<br>\n   如果参数是一个thenable对象，即具有then()方法的对象，那么Promise.resolve()就会将该对象立即转化成 Promise对象那个，并立即执行then方法。\n  3. 参数不是具有then方法的对象，或根本就不是对象<br>\n   如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。\n  4. 不带有任何参数<br>\n\n## 总结\n![总结](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/%E6%80%BB%E7%BB%93.jpg)","slug":"如何理解ES6中Promise","published":1,"updated":"2019-10-22T12:13:48.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufxy00204sef738s1pmy","content":"<h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h2><p>/<strong>Promise</strong>/是ES6中的一个内置的对象（实际上是一个构造函数，通过这个构造函数我们可以创建一个/<strong>Promise</strong>/对象），它的出现是为了更好地解决JavaScript中异步编程的问题，传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而/<strong>Promise</strong>/则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且/<strong>Promise</strong>/还增加了许多有用的特性，让我们处理异步编程得心应手。/<strong>Promise</strong>/的英文意思是承诺。</p>\n<h2 id=\"Promise的特点\"><a href=\"#Promise的特点\" class=\"headerlink\" title=\"Promise的特点\"></a>Promise的特点</h2><ul>\n<li><p>/<strong>Promise</strong>/有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>\n</li>\n<li><p>/<strong>Promise</strong>/一共有三种状态，但是他们之间是如何转化的呢？ 其一： 从Pending（进行中）到Resolved（完成）。其二： 从Pending（进行中）到Rejected（已失败）。 且只有这两种形式的转变，即使是Promise对象的结果也无力回天了。</p>\n<p>但是/<strong>Promise</strong>/并不是完美无缺的，也是有一定的缺点的，如在Pengding时，我们无法取消状态，另外，我们没法判断Pending究竟是刚刚开始的Pending还是即将要完成的Pending。</p>\n</li>\n</ul>\n<h2 id=\"使用Promise\"><a href=\"#使用Promise\" class=\"headerlink\" title=\"使用Promise\"></a>使用Promise</h2><p>  直接上码<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">resolve(value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">reject(error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  其中，由于Promise是构造函数，所以我们使用new来创建一个对象即可， 值得注意的是：function(resolve, reject){}这个函数是必须要写的，否则就不是Promise了。</p>\n<p>  这个函数是为了初始化Promise对象，其中这个函数接受了两个函数作为参数， 如果在函数体中我们执行了resolve函数，那么Promise的状态就会由pending转化为resolved（或fullfilled，两者是相同的），类似的，如果我们执行了reject函数，pending就会变成 rejected。<br>  注意： 这个例子的if语句不是必要的，这里想要表达的意思是如果得到了异步成功的相关结果，我们就将调用resolve，将pending转化为resolved，并且将异步成功后的value值传递进去以便后面使用，说是以便后面使用是因为Promise还有一个then()方法，即可以定义在异步成功（或失败）之后需要做的事情。这也就是resolve和reject内置函数存在的意义了。</p>\n<p>　当创建了这个Promise对象之后，就一定会有一个结果了，但是成功和失败还是不确定的，我们需要根据判断结果的成功和失败来做不同的事情，于是用到了then()方法，如下所示：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  下面这个例子做了详尽的说明<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"good\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = a + <span class=\"number\">25</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( b === <span class=\"number\">35</span> ) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 一旦异步执行成功，我们就调用内置的 resolve函数，将pending状态转化为resolved，并且传入我们希望传出的执行成功后的结果。</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意： 这里一旦状态转变，那么后面就一定会调用then方法中的第一个参数的函数，然后将我们传入给resolve的参数传给then方法中的第一个方法作为参数，我们就可以在then的第一个方法中使用了。</span></span><br><span class=\"line\">  resolve(b);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"string\">\"异步执行失败\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步执行成功，输出执行结果：\"</span> + value);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步执行失败，输出执行结果：\"</span> + error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise的方法\"><a href=\"#Promise的方法\" class=\"headerlink\" title=\"Promise的方法\"></a>Promise的方法</h2><h3 id=\"1-Promise-prototype-then\"><a href=\"#1-Promise-prototype-then\" class=\"headerlink\" title=\"1. Promise.prototype.then()\"></a>1. Promise.prototype.then()</h3><p>上面其实已经介绍了then()方法了，而这里需要强调的有两点。<br><br>第一：then()方法是Promise原型上定义的方法。<br><br>第二：then()方法支持链式调用，上一个then()方法调用后返回的结果回传给下一个then()方法中。</p>\n<p>第一：我们在chrome中输入Promise.prototype可以看到下面的例子：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/promise01.jpg\" alt=\"Promise.prototype.then()\"><br>可以看出在Promise的原型中确实是由then方法的。（注：比如我们想看Array这个内置对象有哪些方法，我们就可以直接在chrome中输入Array.prototype，然后就可以看到对应方法的列表了）</p>\n<p>第二： then()的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。<br>then()由于支持链式调用，所以也可以这样写成这样：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>  再来看看下面这个例子：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  即第一个then又返回了一个promise，如何这个promise的状态变成了 Resolved，那么就会执行第二个then的第一个函数， 如果变成了 Rejected，就会执行第二个第二个函数。</p>\n<h3 id=\"2-Promise-prototype-catch\"><a href=\"#2-Promise-prototype-catch\" class=\"headerlink\" title=\"2.Promise.prototype.catch()\"></a>2.Promise.prototype.catch()</h3><p>  Promise.prototype.catch()方法实际上是then(null, rejection)方法的别名， 这里使用catch（）纯粹是为了便于使用和理解。<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  在之前的例子中，我们讲解then()方法接受两个参数，第一个参数是pending变成resolved之后执行的函数，它是必选的； 第二个参数是pending变成rejected之后执行的函数，它是可选的。</p>\n<p>  我们建议，最后不要使用第二个参数，取而代之我们最好使用catch（），如下所示：<br>   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">  promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// good</span></span><br><span class=\"line\">  promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  值得注意的是：catch()方法返回的还是一个Promise对象，我们可以在后面继续使用then进行链式调用。</p>\n<h3 id=\"3-Promise-all\"><a href=\"#3-Promise-all\" class=\"headerlink\" title=\"3.Promise.all()\"></a>3.Promise.all()</h3><p>  Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例，如下所示：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  其中的p1，p2，p3都是Promise对象实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。<br>  p的状态由p1，p2，p3决定，分成下面的两种情况：</p>\n<ul>\n<li><p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>\n</li>\n<li><p>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>\n<p>让我们来看看具体的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成一个Promise对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> getJSON(<span class=\"string\">\"/post/\"</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，通过数组的map生成了6个Promise对象，然后作为参数传递给了Promise.all() 只有这6个Promise对象最终返回的都是 resolved时， 才会调用Promise.all()后面then（）方法。</p>\n<h3 id=\"4-Promise-resolve\"><a href=\"#4-Promise-resolve\" class=\"headerlink\" title=\"4.Promise.resolve()\"></a>4.Promise.resolve()</h3><p>如果我们希望将一个现有对象转化为Promise对象，我们就可以使用Promise.resolve()方法。根据参数的不同可以分为4种情况：</p>\n</li>\n</ul>\n<ol>\n<li>参数是一个Promise实例<br><br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li>\n<li>参数是一个thenable对象<br><br>如果参数是一个thenable对象，即具有then()方法的对象，那么Promise.resolve()就会将该对象立即转化成 Promise对象那个，并立即执行then方法。</li>\n<li>参数不是具有then方法的对象，或根本就不是对象<br><br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。</li>\n<li>不带有任何参数<br></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/%E6%80%BB%E7%BB%93.jpg\" alt=\"总结\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是Promise\"><a href=\"#什么是Promise\" class=\"headerlink\" title=\"什么是Promise\"></a>什么是Promise</h2><p>/<strong>Promise</strong>/是ES6中的一个内置的对象（实际上是一个构造函数，通过这个构造函数我们可以创建一个/<strong>Promise</strong>/对象），它的出现是为了更好地解决JavaScript中异步编程的问题，传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而/<strong>Promise</strong>/则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且/<strong>Promise</strong>/还增加了许多有用的特性，让我们处理异步编程得心应手。/<strong>Promise</strong>/的英文意思是承诺。</p>\n<h2 id=\"Promise的特点\"><a href=\"#Promise的特点\" class=\"headerlink\" title=\"Promise的特点\"></a>Promise的特点</h2><ul>\n<li><p>/<strong>Promise</strong>/有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</p>\n</li>\n<li><p>/<strong>Promise</strong>/一共有三种状态，但是他们之间是如何转化的呢？ 其一： 从Pending（进行中）到Resolved（完成）。其二： 从Pending（进行中）到Rejected（已失败）。 且只有这两种形式的转变，即使是Promise对象的结果也无力回天了。</p>\n<p>但是/<strong>Promise</strong>/并不是完美无缺的，也是有一定的缺点的，如在Pengding时，我们无法取消状态，另外，我们没法判断Pending究竟是刚刚开始的Pending还是即将要完成的Pending。</p>\n</li>\n</ul>\n<h2 id=\"使用Promise\"><a href=\"#使用Promise\" class=\"headerlink\" title=\"使用Promise\"></a>使用Promise</h2><p>  直接上码<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ... some code</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"comment\">/* 异步操作成功 */</span>)&#123;</span><br><span class=\"line\">resolve(value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">reject(error);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  其中，由于Promise是构造函数，所以我们使用new来创建一个对象即可， 值得注意的是：function(resolve, reject){}这个函数是必须要写的，否则就不是Promise了。</p>\n<p>  这个函数是为了初始化Promise对象，其中这个函数接受了两个函数作为参数， 如果在函数体中我们执行了resolve函数，那么Promise的状态就会由pending转化为resolved（或fullfilled，两者是相同的），类似的，如果我们执行了reject函数，pending就会变成 rejected。<br>  注意： 这个例子的if语句不是必要的，这里想要表达的意思是如果得到了异步成功的相关结果，我们就将调用resolve，将pending转化为resolved，并且将异步成功后的value值传递进去以便后面使用，说是以便后面使用是因为Promise还有一个then()方法，即可以定义在异步成功（或失败）之后需要做的事情。这也就是resolve和reject内置函数存在的意义了。</p>\n<p>　当创建了这个Promise对象之后，就一定会有一个结果了，但是成功和失败还是不确定的，我们需要根据判断结果的成功和失败来做不同的事情，于是用到了then()方法，如下所示：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    promise.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// success</span></span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"comment\">// failure</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  下面这个例子做了详尽的说明<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"good\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = a + <span class=\"number\">25</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( b === <span class=\"number\">35</span> ) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 一旦异步执行成功，我们就调用内置的 resolve函数，将pending状态转化为resolved，并且传入我们希望传出的执行成功后的结果。</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意： 这里一旦状态转变，那么后面就一定会调用then方法中的第一个参数的函数，然后将我们传入给resolve的参数传给then方法中的第一个方法作为参数，我们就可以在then的第一个方法中使用了。</span></span><br><span class=\"line\">  resolve(b);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  reject(<span class=\"string\">\"异步执行失败\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">promise.then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步执行成功，输出执行结果：\"</span> + value);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"异步执行失败，输出执行结果：\"</span> + error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Promise的方法\"><a href=\"#Promise的方法\" class=\"headerlink\" title=\"Promise的方法\"></a>Promise的方法</h2><h3 id=\"1-Promise-prototype-then\"><a href=\"#1-Promise-prototype-then\" class=\"headerlink\" title=\"1. Promise.prototype.then()\"></a>1. Promise.prototype.then()</h3><p>上面其实已经介绍了then()方法了，而这里需要强调的有两点。<br><br>第一：then()方法是Promise原型上定义的方法。<br><br>第二：then()方法支持链式调用，上一个then()方法调用后返回的结果回传给下一个then()方法中。</p>\n<p>第一：我们在chrome中输入Promise.prototype可以看到下面的例子：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/promise01.jpg\" alt=\"Promise.prototype.then()\"><br>可以看出在Promise的原型中确实是由then方法的。（注：比如我们想看Array这个内置对象有哪些方法，我们就可以直接在chrome中输入Array.prototype，然后就可以看到对应方法的列表了）</p>\n<p>第二： then()的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。<br>then()由于支持链式调用，所以也可以这样写成这样：<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  getJSON(<span class=\"string\">\"/posts.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">json</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> json.post;</span><br><span class=\"line\">  &#125;).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。</p>\n<p>  再来看看下面这个例子：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getJSON(<span class=\"string\">\"/post/1.json\"</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> getJSON(post.commentURL);</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcA</span>(<span class=\"params\">comments</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Resolved: \"</span>, comments);</span><br><span class=\"line\">&#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">funcB</span>(<span class=\"params\">err</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Rejected: \"</span>, err);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  即第一个then又返回了一个promise，如何这个promise的状态变成了 Resolved，那么就会执行第二个then的第一个函数， 如果变成了 Rejected，就会执行第二个第二个函数。</p>\n<h3 id=\"2-Promise-prototype-catch\"><a href=\"#2-Promise-prototype-catch\" class=\"headerlink\" title=\"2.Promise.prototype.catch()\"></a>2.Promise.prototype.catch()</h3><p>  Promise.prototype.catch()方法实际上是then(null, rejection)方法的别名， 这里使用catch（）纯粹是为了便于使用和理解。<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    getJSON(<span class=\"string\">'/posts.json'</span>).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  &#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'发生错误！'</span>, error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  在之前的例子中，我们讲解then()方法接受两个参数，第一个参数是pending变成resolved之后执行的函数，它是必选的； 第二个参数是pending变成rejected之后执行的函数，它是可选的。</p>\n<p>  我们建议，最后不要使用第二个参数，取而代之我们最好使用catch（），如下所示：<br>   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bad</span></span><br><span class=\"line\">  promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// good</span></span><br><span class=\"line\">  promise</span><br><span class=\"line\">  .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123; <span class=\"comment\">//cb</span></span><br><span class=\"line\">  <span class=\"comment\">// success</span></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// error</span></span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  值得注意的是：catch()方法返回的还是一个Promise对象，我们可以在后面继续使用then进行链式调用。</p>\n<h3 id=\"3-Promise-all\"><a href=\"#3-Promise-all\" class=\"headerlink\" title=\"3.Promise.all()\"></a>3.Promise.all()</h3><p>  Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例，如下所示：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   <span class=\"keyword\">var</span> p = <span class=\"built_in\">Promise</span>.all([p1, p2, p3]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>  其中的p1，p2，p3都是Promise对象实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。<br>  p的状态由p1，p2，p3决定，分成下面的两种情况：</p>\n<ul>\n<li><p>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</p>\n</li>\n<li><p>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</p>\n<p>让我们来看看具体的例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 生成一个Promise对象的数组</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> promises = [<span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">13</span>].map(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">id</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> getJSON(<span class=\"string\">\"/post/\"</span> + id + <span class=\"string\">\".json\"</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Promise</span>.all(promises).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">posts</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;).catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，通过数组的map生成了6个Promise对象，然后作为参数传递给了Promise.all() 只有这6个Promise对象最终返回的都是 resolved时， 才会调用Promise.all()后面then（）方法。</p>\n<h3 id=\"4-Promise-resolve\"><a href=\"#4-Promise-resolve\" class=\"headerlink\" title=\"4.Promise.resolve()\"></a>4.Promise.resolve()</h3><p>如果我们希望将一个现有对象转化为Promise对象，我们就可以使用Promise.resolve()方法。根据参数的不同可以分为4种情况：</p>\n</li>\n</ul>\n<ol>\n<li>参数是一个Promise实例<br><br>如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。</li>\n<li>参数是一个thenable对象<br><br>如果参数是一个thenable对象，即具有then()方法的对象，那么Promise.resolve()就会将该对象立即转化成 Promise对象那个，并立即执行then方法。</li>\n<li>参数不是具有then方法的对象，或根本就不是对象<br><br>如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。</li>\n<li>不带有任何参数<br></li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/promise/%E6%80%BB%E7%BB%93.jpg\" alt=\"总结\"></p>\n"},{"title":"浅谈v-slot","date":"2019-11-14T05:27:30.000Z","author":"刘涛","_content":"\n## 前言\nVue 代码中的 slot 是什么，简单来说就是插槽。`<slot>`元素作为组件模板之中的内容分发插槽，传入内容后 `<slot>` 元素自身将被替换。\n\n看了上面这句官方解释，可能一样不知道 slot 指的是什么，那么就来看看在 Vue 中，什么时候你需要用到 slot 。\n\n举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如 Button 中是否显示 icon ，或者 Modal 框的中间内容展示区域的变化等，要通过子组件自己实现是不可能的。组件并不直接支持 HTML DOM 结构的传递，此时就可以通过使用 slot 作为 HTML 结构的传递入口来解决问题。\n\n\n## 什么是插槽\n* 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。\n* 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制\n\n## 插槽的作用\n让用户可以拓展组件，去更好地复用组件和对其做定制化处理。\n举一些例子，比如布局组件、表格列、下拉选项\n\n## 怎么使用插槽\n\n### 默认插槽\n**子组件编写**：在组件中添加 `<slot>` 元素，来确定渲染的位置。\n```html\n// 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 默认插槽 -->\n      <header class=\"text\">\n        <!-- slot 的后备内容：为一个插槽设置具体后备（默认）内容是很有用的，\n        当父组件不添加任何插槽内容时，默认渲染该后备内容的值。 -->\n        <slot>默认值</slot>\n      </header>\n    </div>\n  </template>\n```\n\n**父组件编写**：任何没有被包裹在带有 v-slot 的 `<template> `中的内容都会被视为默认插槽的内容。当子组件只有默认插槽时， `<v-slot>` 标签可以直接用在组件上，也就是独占默认插槽的写法\n``` html\n// 父组件\n<template>\n  <div class=\"container\">\n    <!-- 默认插槽-->\n    <child>\n      任意内容\n      <template>内容</template>\n      中间内容\n      <!-- <template v-slot:default>但如果你定义了 default 之后，其他内容就不会出现了，\n      原理同上，不能重复定义</template> -->\n    </child>\n    \n    <!-- 独占默认插槽的缩写 -->\n    <child v-slot=\"slotProps\">\n      当只有默认插槽时，此为独占默认插槽的缩写<br>\n      如果组件中有其他具名插槽，这么写会报错<br>\n      slotProps 取的是，子组件标签 slot 上属性数据的集合\n    </child>\n  </div>\n</template>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD.png)\n\n### 具名插槽\n**子组件编写**：当需要使用多个插槽时，为 `<slot>` 元素添加 name 属性，来区分不同的插槽，当不填写 name 时，默认为 default 默认插槽。\n``` html\n // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 具名插槽 -->\n      <main class=\"text\">\n        <slot name=\"main\"></slot>\n      </main>\n      <footer class=\"text\">\n        <slot name=\"footer\"></slot>\n      </footer>\n    </div>\n  </template>\n```\n\n**父组件编写**：`<template>` 标签中添加 v-slot:xxx 或者 #xxx 属性的内容， # 代表插槽的缩写。\n\n``` html\n// 父组件\n<template>\n  <div class=\"container\">\n    <!-- 具名插槽使用 -->\n    <child>\n      <template v-slot:main>\n        <a href=\"https://www.zcygov.cn\" target=\"_blank\">导航</a>\n      </template>\n      <template #footer>页脚（具名插槽的缩写#）</template>\n      <template #footer>\n        <!--  v-slot 重复定义同样的 name 后只会加载最后一个定义的插槽内容 -->\n        v-slot只会添加在一个 template 上面\n      </template>\n    </child>\n  </div>\n</template>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.png)\n\n\n### 作用域插槽\n**子组件编写**：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 `<slot>`元素上的特性称为**插槽 Prop** ，当然也可以传递一些 Function。\n```html\n // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 作用域插槽 -->\n      <footer class=\"text\">\n        <slot name=\"footer\" :user=\"user\" :testClick=\"testClick\">\n          {{user.name}}\n        </slot>\n      </footer>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: 'child',\n    data () {\n      return {\n        user: {\n          title: '测试title',\n          name: '测试name'\n        }\n      };\n    },\n    methods:{\n      testClick(){\n      \t// 子组件通用方法，可传递给父组件复用\n        alert('123');\n      }\n    }\n  };\n  </script>\n  ```\n\n  **父组件编写**：被绑定的属性的集合对象，在父元素中会被 v-slot:xxx=\"slotProps\" 或者 #xxx=\"slotProps\" 接收，xxx 代表具名插槽的 name ，slotProps 为子组件传递的数据对象，可以重命名。\n```html\n// 父组件\n<template>\n  <div class=\"container\">\n    <!-- 作用域插槽，以及解构插槽 Prop 的写法 -->\n    <child>\n      <template #footer=\"slotProps\">\n        {{slotProps.user.title}}\n        <button @click=\"slotProps.testClick\">点我</button>\n      </template>\n      <template #footer=\"{user,testClick}\">\n        {{user.title}}<br>\n        此为解构插槽prop<br>\n        <!-- 子组件中的通用方法，可传递给父组件复用 -->\n        <button @click=\"testClick\">点我</button>\n      </template>\n    </child>\n  </div>\n</template>\n\n<script>\nimport Child from './component/child.vue';\nexport default {\n  name: 'demo',\n  components: {\n    Child\n  },\n};\n</script>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD.png)\n\n### 其它拓展\n\n* 解构插槽 prop 可以重命名，例如：`v-slot=\"{ user: person }\"` 将 user 对象重命名为 person 使用。\n\n* 解构插槽 prop 可以赋值默认值，例如：`v-slot=\"{ user = { name: 'Guest' } }\"` 给属性添加自定义后备内容。\n\n* 动态插槽命名，例如：`v-slot:[dynamicSlotName]` ，支持命名变量定义。\n\n### 注意事项\n* `v-slot` 只能用在 `template` 上面，或者是独占默认插槽的写法。\n\n* 父组件引用时 ，重复定义了 `v-slot` 的 `name` 后只会加载最后一个定义的插槽内容。\n\n* 当子组件只有默认插槽时，才可以使用独占默认插槽的缩写语法，只要出现多个插槽，必须使用完整的基于 `template` 的语法。\n\n\n## slot 以及 slot-scope 的用法\n\n### 子组件编写\n```html\n  // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 默认插槽 -->\n      <header class=\"text\">\n        <slot>默认值</slot>\n      </header>\n      \n      <!-- 具名插槽 -->\n      <main class=\"text\">\n        <slot name=\"main\"></slot>\n      </main>\n      \n      <!-- 作用域插槽 -->\n      <footer class=\"text\">\n        <slot name=\"footer\" :user=\"user\" :testClick=\"testClick\">\n          {{user.name}}\n        </slot>\n      </footer>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: 'child',\n    data () {\n      return {\n        user: {\n          title: '测试title',\n          name: '测试name'\n        }\n      };\n    }\n  };\n  </script>\n```\n\n### 父组件编写\n* 具名插槽：直接使用 `slot` 属性，传值为子组件插槽的 name 属性。\n* 作用域插槽：通过 `slot-scope` 属性来接受子组件传入的属性集合，其他用法一致。\n\n``` html\n// 父组件\n <template>\n   <div class=\"container\">\n     <child>\n       <!-- 默认插槽 -->\n       <div>默认插槽</div> \n      \n       <!-- 具名插槽 -->\n       <div slot=\"main\">具名插槽</div>\n       <div slot=\"main\">具名插槽2</div>\n      \n       <!-- 作用域插槽 -->\n       <div slot=\"footer\" slot-scope=\"slotProps\">\n         {{slotProps.user.title}}\n       </div>\n     </child>\n   </div>\n </template>\n\n <script>\n import Child from './component/child.vue';\n export default {\n   name: 'demo',\n   components: {\n     Child\n   },\n };\n </script>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/slot-scope%20%E7%9A%84%E7%94%A8%E6%B3%95.png)\n\n### 注意事项\n* 不同于 `v-slot` 的是，slot 中同名可以重复定义多次。\n* `slot` 可以直接定义在子组件上。\n* v3.0 版本后不可使用 `slot` ，建议直接使用 `v-slot` 。\n\n\n## 总结\n* 插槽的 `<slot>` 的可复用特性，可以用来写一些组件结构固定，内容可替换的组件，例如表格，列表，按钮，弹窗等内容。\n* 插槽可以传递属性值或者 function 的特性，可以在子组件中写一些通用的函数，例如通用的报错提示等，传递给父组件复用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/浅谈v-slot.md","raw":"---\ntitle: 浅谈v-slot\ndate: 2019-11-14 13:27:30\nauthor: 刘涛\ncategories: \n  - vue\ntags: \n  - vue基础\n---\n\n## 前言\nVue 代码中的 slot 是什么，简单来说就是插槽。`<slot>`元素作为组件模板之中的内容分发插槽，传入内容后 `<slot>` 元素自身将被替换。\n\n看了上面这句官方解释，可能一样不知道 slot 指的是什么，那么就来看看在 Vue 中，什么时候你需要用到 slot 。\n\n举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如 Button 中是否显示 icon ，或者 Modal 框的中间内容展示区域的变化等，要通过子组件自己实现是不可能的。组件并不直接支持 HTML DOM 结构的传递，此时就可以通过使用 slot 作为 HTML 结构的传递入口来解决问题。\n\n\n## 什么是插槽\n* 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。\n* 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制\n\n## 插槽的作用\n让用户可以拓展组件，去更好地复用组件和对其做定制化处理。\n举一些例子，比如布局组件、表格列、下拉选项\n\n## 怎么使用插槽\n\n### 默认插槽\n**子组件编写**：在组件中添加 `<slot>` 元素，来确定渲染的位置。\n```html\n// 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 默认插槽 -->\n      <header class=\"text\">\n        <!-- slot 的后备内容：为一个插槽设置具体后备（默认）内容是很有用的，\n        当父组件不添加任何插槽内容时，默认渲染该后备内容的值。 -->\n        <slot>默认值</slot>\n      </header>\n    </div>\n  </template>\n```\n\n**父组件编写**：任何没有被包裹在带有 v-slot 的 `<template> `中的内容都会被视为默认插槽的内容。当子组件只有默认插槽时， `<v-slot>` 标签可以直接用在组件上，也就是独占默认插槽的写法\n``` html\n// 父组件\n<template>\n  <div class=\"container\">\n    <!-- 默认插槽-->\n    <child>\n      任意内容\n      <template>内容</template>\n      中间内容\n      <!-- <template v-slot:default>但如果你定义了 default 之后，其他内容就不会出现了，\n      原理同上，不能重复定义</template> -->\n    </child>\n    \n    <!-- 独占默认插槽的缩写 -->\n    <child v-slot=\"slotProps\">\n      当只有默认插槽时，此为独占默认插槽的缩写<br>\n      如果组件中有其他具名插槽，这么写会报错<br>\n      slotProps 取的是，子组件标签 slot 上属性数据的集合\n    </child>\n  </div>\n</template>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD.png)\n\n### 具名插槽\n**子组件编写**：当需要使用多个插槽时，为 `<slot>` 元素添加 name 属性，来区分不同的插槽，当不填写 name 时，默认为 default 默认插槽。\n``` html\n // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 具名插槽 -->\n      <main class=\"text\">\n        <slot name=\"main\"></slot>\n      </main>\n      <footer class=\"text\">\n        <slot name=\"footer\"></slot>\n      </footer>\n    </div>\n  </template>\n```\n\n**父组件编写**：`<template>` 标签中添加 v-slot:xxx 或者 #xxx 属性的内容， # 代表插槽的缩写。\n\n``` html\n// 父组件\n<template>\n  <div class=\"container\">\n    <!-- 具名插槽使用 -->\n    <child>\n      <template v-slot:main>\n        <a href=\"https://www.zcygov.cn\" target=\"_blank\">导航</a>\n      </template>\n      <template #footer>页脚（具名插槽的缩写#）</template>\n      <template #footer>\n        <!--  v-slot 重复定义同样的 name 后只会加载最后一个定义的插槽内容 -->\n        v-slot只会添加在一个 template 上面\n      </template>\n    </child>\n  </div>\n</template>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.png)\n\n\n### 作用域插槽\n**子组件编写**：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 `<slot>`元素上的特性称为**插槽 Prop** ，当然也可以传递一些 Function。\n```html\n // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 作用域插槽 -->\n      <footer class=\"text\">\n        <slot name=\"footer\" :user=\"user\" :testClick=\"testClick\">\n          {{user.name}}\n        </slot>\n      </footer>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: 'child',\n    data () {\n      return {\n        user: {\n          title: '测试title',\n          name: '测试name'\n        }\n      };\n    },\n    methods:{\n      testClick(){\n      \t// 子组件通用方法，可传递给父组件复用\n        alert('123');\n      }\n    }\n  };\n  </script>\n  ```\n\n  **父组件编写**：被绑定的属性的集合对象，在父元素中会被 v-slot:xxx=\"slotProps\" 或者 #xxx=\"slotProps\" 接收，xxx 代表具名插槽的 name ，slotProps 为子组件传递的数据对象，可以重命名。\n```html\n// 父组件\n<template>\n  <div class=\"container\">\n    <!-- 作用域插槽，以及解构插槽 Prop 的写法 -->\n    <child>\n      <template #footer=\"slotProps\">\n        {{slotProps.user.title}}\n        <button @click=\"slotProps.testClick\">点我</button>\n      </template>\n      <template #footer=\"{user,testClick}\">\n        {{user.title}}<br>\n        此为解构插槽prop<br>\n        <!-- 子组件中的通用方法，可传递给父组件复用 -->\n        <button @click=\"testClick\">点我</button>\n      </template>\n    </child>\n  </div>\n</template>\n\n<script>\nimport Child from './component/child.vue';\nexport default {\n  name: 'demo',\n  components: {\n    Child\n  },\n};\n</script>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD.png)\n\n### 其它拓展\n\n* 解构插槽 prop 可以重命名，例如：`v-slot=\"{ user: person }\"` 将 user 对象重命名为 person 使用。\n\n* 解构插槽 prop 可以赋值默认值，例如：`v-slot=\"{ user = { name: 'Guest' } }\"` 给属性添加自定义后备内容。\n\n* 动态插槽命名，例如：`v-slot:[dynamicSlotName]` ，支持命名变量定义。\n\n### 注意事项\n* `v-slot` 只能用在 `template` 上面，或者是独占默认插槽的写法。\n\n* 父组件引用时 ，重复定义了 `v-slot` 的 `name` 后只会加载最后一个定义的插槽内容。\n\n* 当子组件只有默认插槽时，才可以使用独占默认插槽的缩写语法，只要出现多个插槽，必须使用完整的基于 `template` 的语法。\n\n\n## slot 以及 slot-scope 的用法\n\n### 子组件编写\n```html\n  // 子组件\n  <template>\n    <div class=\"content\">\n      <!-- 默认插槽 -->\n      <header class=\"text\">\n        <slot>默认值</slot>\n      </header>\n      \n      <!-- 具名插槽 -->\n      <main class=\"text\">\n        <slot name=\"main\"></slot>\n      </main>\n      \n      <!-- 作用域插槽 -->\n      <footer class=\"text\">\n        <slot name=\"footer\" :user=\"user\" :testClick=\"testClick\">\n          {{user.name}}\n        </slot>\n      </footer>\n    </div>\n  </template>\n  \n  <script>\n  export default {\n    name: 'child',\n    data () {\n      return {\n        user: {\n          title: '测试title',\n          name: '测试name'\n        }\n      };\n    }\n  };\n  </script>\n```\n\n### 父组件编写\n* 具名插槽：直接使用 `slot` 属性，传值为子组件插槽的 name 属性。\n* 作用域插槽：通过 `slot-scope` 属性来接受子组件传入的属性集合，其他用法一致。\n\n``` html\n// 父组件\n <template>\n   <div class=\"container\">\n     <child>\n       <!-- 默认插槽 -->\n       <div>默认插槽</div> \n      \n       <!-- 具名插槽 -->\n       <div slot=\"main\">具名插槽</div>\n       <div slot=\"main\">具名插槽2</div>\n      \n       <!-- 作用域插槽 -->\n       <div slot=\"footer\" slot-scope=\"slotProps\">\n         {{slotProps.user.title}}\n       </div>\n     </child>\n   </div>\n </template>\n\n <script>\n import Child from './component/child.vue';\n export default {\n   name: 'demo',\n   components: {\n     Child\n   },\n };\n </script>\n```\n\n**渲染结果**：\n![](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/slot-scope%20%E7%9A%84%E7%94%A8%E6%B3%95.png)\n\n### 注意事项\n* 不同于 `v-slot` 的是，slot 中同名可以重复定义多次。\n* `slot` 可以直接定义在子组件上。\n* v3.0 版本后不可使用 `slot` ，建议直接使用 `v-slot` 。\n\n\n## 总结\n* 插槽的 `<slot>` 的可复用特性，可以用来写一些组件结构固定，内容可替换的组件，例如表格，列表，按钮，弹窗等内容。\n* 插槽可以传递属性值或者 function 的特性，可以在子组件中写一些通用的函数，例如通用的报错提示等，传递给父组件复用。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"浅谈v-slot","published":1,"updated":"2019-11-14T07:16:02.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufxz00224sefxrbprz4e","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Vue 代码中的 slot 是什么，简单来说就是插槽。<code>&lt;slot&gt;</code>元素作为组件模板之中的内容分发插槽，传入内容后 <code>&lt;slot&gt;</code> 元素自身将被替换。</p>\n<p>看了上面这句官方解释，可能一样不知道 slot 指的是什么，那么就来看看在 Vue 中，什么时候你需要用到 slot 。</p>\n<p>举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如 Button 中是否显示 icon ，或者 Modal 框的中间内容展示区域的变化等，要通过子组件自己实现是不可能的。组件并不直接支持 HTML DOM 结构的传递，此时就可以通过使用 slot 作为 HTML 结构的传递入口来解决问题。</p>\n<h2 id=\"什么是插槽\"><a href=\"#什么是插槽\" class=\"headerlink\" title=\"什么是插槽\"></a>什么是插槽</h2><ul>\n<li>插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li>\n<li>插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</li>\n</ul>\n<h2 id=\"插槽的作用\"><a href=\"#插槽的作用\" class=\"headerlink\" title=\"插槽的作用\"></a>插槽的作用</h2><p>让用户可以拓展组件，去更好地复用组件和对其做定制化处理。<br>举一些例子，比如布局组件、表格列、下拉选项</p>\n<h2 id=\"怎么使用插槽\"><a href=\"#怎么使用插槽\" class=\"headerlink\" title=\"怎么使用插槽\"></a>怎么使用插槽</h2><h3 id=\"默认插槽\"><a href=\"#默认插槽\" class=\"headerlink\" title=\"默认插槽\"></a>默认插槽</h3><p><strong>子组件编写</strong>：在组件中添加 <code>&lt;slot&gt;</code> 元素，来确定渲染的位置。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 默认插槽 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- slot 的后备内容：为一个插槽设置具体后备（默认）内容是很有用的，</span></span><br><span class=\"line\"><span class=\"comment\">        当父组件不添加任何插槽内容时，默认渲染该后备内容的值。 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span>默认值<span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>父组件编写</strong>：任何没有被包裹在带有 v-slot 的 <code>&lt;template&gt;</code>中的内容都会被视为默认插槽的内容。当子组件只有默认插槽时， <code>&lt;v-slot&gt;</code> 标签可以直接用在组件上，也就是独占默认插槽的写法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 默认插槽--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      任意内容</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      中间内容</span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- &lt;template v-slot:default&gt;但如果你定义了 default 之后，其他内容就不会出现了，</span></span><br><span class=\"line\"><span class=\"comment\">      原理同上，不能重复定义&lt;/template&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 独占默认插槽的缩写 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">v-slot</span>=<span class=\"string\">\"slotProps\"</span>&gt;</span></span><br><span class=\"line\">      当只有默认插槽时，此为独占默认插槽的缩写<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      如果组件中有其他具名插槽，这么写会报错<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      slotProps 取的是，子组件标签 slot 上属性数据的集合</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD.png\" alt></p>\n<h3 id=\"具名插槽\"><a href=\"#具名插槽\" class=\"headerlink\" title=\"具名插槽\"></a>具名插槽</h3><p><strong>子组件编写</strong>：当需要使用多个插槽时，为 <code>&lt;slot&gt;</code> 元素添加 name 属性，来区分不同的插槽，当不填写 name 时，默认为 default 默认插槽。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 具名插槽 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">main</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">footer</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>父组件编写</strong>：<code>&lt;template&gt;</code> 标签中添加 v-slot:xxx 或者 #xxx 属性的内容， # 代表插槽的缩写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 具名插槽使用 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:main</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://www.zcygov.cn\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>导航<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>&gt;</span>页脚（具名插槽的缩写#）<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--  v-slot 重复定义同样的 name 后只会加载最后一个定义的插槽内容 --&gt;</span></span><br><span class=\"line\">        v-slot只会添加在一个 template 上面</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.png\" alt></p>\n<h3 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h3><p><strong>子组件编写</strong>：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 <code>&lt;slot&gt;</code>元素上的特性称为<strong>插槽 Prop</strong> ，当然也可以传递一些 Function。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">footer</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span> <span class=\"attr\">:user</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">:testClick</span>=<span class=\"string\">\"testClick\"</span>&gt;</span></span><br><span class=\"line\">         &#123;&#123;user.name&#125;&#125;</span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">   name: <span class=\"string\">'child'</span>,</span></span><br><span class=\"line\">   data () &#123;</span><br><span class=\"line\"><span class=\"actionscript\">     <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">       user: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">         title: <span class=\"string\">'测试title'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">         name: <span class=\"string\">'测试name'</span></span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   methods:&#123;</span><br><span class=\"line\">     testClick()&#123;</span><br><span class=\"line\"><span class=\"actionscript\">     \t<span class=\"comment\">// 子组件通用方法，可传递给父组件复用</span></span></span><br><span class=\"line\"><span class=\"actionscript\">       alert(<span class=\"string\">'123'</span>);</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>  <strong>父组件编写</strong>：被绑定的属性的集合对象，在父元素中会被 v-slot:xxx=”slotProps” 或者 #xxx=”slotProps” 接收，xxx 代表具名插槽的 name ，slotProps 为子组件传递的数据对象，可以重命名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 作用域插槽，以及解构插槽 Prop 的写法 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>=<span class=\"string\">\"slotProps\"</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123;slotProps.user.title&#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"slotProps.testClick\"</span>&gt;</span>点我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>=<span class=\"string\">\"&#123;user,testClick&#125;\"</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123;user.title&#125;&#125;<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">        此为解构插槽prop<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 子组件中的通用方法，可传递给父组件复用 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"testClick\"</span>&gt;</span>点我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">import</span> Child <span class=\"keyword\">from</span> <span class=\"string\">'./component/child.vue'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">  name: <span class=\"string\">'demo'</span>,</span></span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    Child</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD.png\" alt></p>\n<h3 id=\"其它拓展\"><a href=\"#其它拓展\" class=\"headerlink\" title=\"其它拓展\"></a>其它拓展</h3><ul>\n<li><p>解构插槽 prop 可以重命名，例如：<code>v-slot=&quot;{ user: person }&quot;</code> 将 user 对象重命名为 person 使用。</p>\n</li>\n<li><p>解构插槽 prop 可以赋值默认值，例如：<code>v-slot=&quot;{ user = { name: &#39;Guest&#39; } }&quot;</code> 给属性添加自定义后备内容。</p>\n</li>\n<li><p>动态插槽命名，例如：<code>v-slot:[dynamicSlotName]</code> ，支持命名变量定义。</p>\n</li>\n</ul>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li><p><code>v-slot</code> 只能用在 <code>template</code> 上面，或者是独占默认插槽的写法。</p>\n</li>\n<li><p>父组件引用时 ，重复定义了 <code>v-slot</code> 的 <code>name</code> 后只会加载最后一个定义的插槽内容。</p>\n</li>\n<li><p>当子组件只有默认插槽时，才可以使用独占默认插槽的缩写语法，只要出现多个插槽，必须使用完整的基于 <code>template</code> 的语法。</p>\n</li>\n</ul>\n<h2 id=\"slot-以及-slot-scope-的用法\"><a href=\"#slot-以及-slot-scope-的用法\" class=\"headerlink\" title=\"slot 以及 slot-scope 的用法\"></a>slot 以及 slot-scope 的用法</h2><h3 id=\"子组件编写\"><a href=\"#子组件编写\" class=\"headerlink\" title=\"子组件编写\"></a>子组件编写</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 默认插槽 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span>默认值<span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 具名插槽 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span> <span class=\"attr\">:user</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">:testClick</span>=<span class=\"string\">\"testClick\"</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123;user.name&#125;&#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">  name: <span class=\"string\">'child'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">      user: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">        title: <span class=\"string\">'测试title'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        name: <span class=\"string\">'测试name'</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"父组件编写\"><a href=\"#父组件编写\" class=\"headerlink\" title=\"父组件编写\"></a>父组件编写</h3><ul>\n<li>具名插槽：直接使用 <code>slot</code> 属性，传值为子组件插槽的 name 属性。</li>\n<li>作用域插槽：通过 <code>slot-scope</code> 属性来接受子组件传入的属性集合，其他用法一致。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!-- 默认插槽 --&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>默认插槽<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">      </span><br><span class=\"line\">       <span class=\"comment\">&lt;!-- 具名插槽 --&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"main\"</span>&gt;</span>具名插槽<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"main\"</span>&gt;</span>具名插槽2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">       <span class=\"comment\">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span> <span class=\"attr\">slot-scope</span>=<span class=\"string\">\"slotProps\"</span>&gt;</span></span><br><span class=\"line\">         &#123;&#123;slotProps.user.title&#125;&#125;</span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">import</span> Child <span class=\"keyword\">from</span> <span class=\"string\">'./component/child.vue'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">   name: <span class=\"string\">'demo'</span>,</span></span><br><span class=\"line\">   components: &#123;</span><br><span class=\"line\">     Child</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/slot-scope%20%E7%9A%84%E7%94%A8%E6%B3%95.png\" alt></p>\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不同于 <code>v-slot</code> 的是，slot 中同名可以重复定义多次。</li>\n<li><code>slot</code> 可以直接定义在子组件上。</li>\n<li>v3.0 版本后不可使用 <code>slot</code> ，建议直接使用 <code>v-slot</code> 。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>插槽的 <code>&lt;slot&gt;</code> 的可复用特性，可以用来写一些组件结构固定，内容可替换的组件，例如表格，列表，按钮，弹窗等内容。</li>\n<li>插槽可以传递属性值或者 function 的特性，可以在子组件中写一些通用的函数，例如通用的报错提示等，传递给父组件复用。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Vue 代码中的 slot 是什么，简单来说就是插槽。<code>&lt;slot&gt;</code>元素作为组件模板之中的内容分发插槽，传入内容后 <code>&lt;slot&gt;</code> 元素自身将被替换。</p>\n<p>看了上面这句官方解释，可能一样不知道 slot 指的是什么，那么就来看看在 Vue 中，什么时候你需要用到 slot 。</p>\n<p>举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如 Button 中是否显示 icon ，或者 Modal 框的中间内容展示区域的变化等，要通过子组件自己实现是不可能的。组件并不直接支持 HTML DOM 结构的传递，此时就可以通过使用 slot 作为 HTML 结构的传递入口来解决问题。</p>\n<h2 id=\"什么是插槽\"><a href=\"#什么是插槽\" class=\"headerlink\" title=\"什么是插槽\"></a>什么是插槽</h2><ul>\n<li>插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。</li>\n<li>插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制</li>\n</ul>\n<h2 id=\"插槽的作用\"><a href=\"#插槽的作用\" class=\"headerlink\" title=\"插槽的作用\"></a>插槽的作用</h2><p>让用户可以拓展组件，去更好地复用组件和对其做定制化处理。<br>举一些例子，比如布局组件、表格列、下拉选项</p>\n<h2 id=\"怎么使用插槽\"><a href=\"#怎么使用插槽\" class=\"headerlink\" title=\"怎么使用插槽\"></a>怎么使用插槽</h2><h3 id=\"默认插槽\"><a href=\"#默认插槽\" class=\"headerlink\" title=\"默认插槽\"></a>默认插槽</h3><p><strong>子组件编写</strong>：在组件中添加 <code>&lt;slot&gt;</code> 元素，来确定渲染的位置。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- 默认插槽 --&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- slot 的后备内容：为一个插槽设置具体后备（默认）内容是很有用的，</span></span><br><span class=\"line\"><span class=\"comment\">        当父组件不添加任何插槽内容时，默认渲染该后备内容的值。 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span>默认值<span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>父组件编写</strong>：任何没有被包裹在带有 v-slot 的 <code>&lt;template&gt;</code>中的内容都会被视为默认插槽的内容。当子组件只有默认插槽时， <code>&lt;v-slot&gt;</code> 标签可以直接用在组件上，也就是独占默认插槽的写法</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 默认插槽--&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      任意内容</span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      中间内容</span><br><span class=\"line\">      <span class=\"comment\">&lt;!-- &lt;template v-slot:default&gt;但如果你定义了 default 之后，其他内容就不会出现了，</span></span><br><span class=\"line\"><span class=\"comment\">      原理同上，不能重复定义&lt;/template&gt; --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 独占默认插槽的缩写 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span> <span class=\"attr\">v-slot</span>=<span class=\"string\">\"slotProps\"</span>&gt;</span></span><br><span class=\"line\">      当只有默认插槽时，此为独占默认插槽的缩写<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      如果组件中有其他具名插槽，这么写会报错<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">      slotProps 取的是，子组件标签 slot 上属性数据的集合</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD.png\" alt></p>\n<h3 id=\"具名插槽\"><a href=\"#具名插槽\" class=\"headerlink\" title=\"具名插槽\"></a>具名插槽</h3><p><strong>子组件编写</strong>：当需要使用多个插槽时，为 <code>&lt;slot&gt;</code> 元素添加 name 属性，来区分不同的插槽，当不填写 name 时，默认为 default 默认插槽。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 具名插槽 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">main</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">footer</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>父组件编写</strong>：<code>&lt;template&gt;</code> 标签中添加 v-slot:xxx 或者 #xxx 属性的内容， # 代表插槽的缩写。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 具名插槽使用 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> <span class=\"attr\">v-slot:main</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"https://www.zcygov.cn\"</span> <span class=\"attr\">target</span>=<span class=\"string\">\"_blank\"</span>&gt;</span>导航<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>&gt;</span>页脚（具名插槽的缩写#）<span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!--  v-slot 重复定义同样的 name 后只会加载最后一个定义的插槽内容 --&gt;</span></span><br><span class=\"line\">        v-slot只会添加在一个 template 上面</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.png\" alt></p>\n<h3 id=\"作用域插槽\"><a href=\"#作用域插槽\" class=\"headerlink\" title=\"作用域插槽\"></a>作用域插槽</h3><p><strong>子组件编写</strong>：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 <code>&lt;slot&gt;</code>元素上的特性称为<strong>插槽 Prop</strong> ，当然也可以传递一些 Function。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"comment\">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">footer</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span> <span class=\"attr\">:user</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">:testClick</span>=<span class=\"string\">\"testClick\"</span>&gt;</span></span><br><span class=\"line\">         &#123;&#123;user.name&#125;&#125;</span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">   name: <span class=\"string\">'child'</span>,</span></span><br><span class=\"line\">   data () &#123;</span><br><span class=\"line\"><span class=\"actionscript\">     <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">       user: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">         title: <span class=\"string\">'测试title'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">         name: <span class=\"string\">'测试name'</span></span></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;;</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\">   methods:&#123;</span><br><span class=\"line\">     testClick()&#123;</span><br><span class=\"line\"><span class=\"actionscript\">     \t<span class=\"comment\">// 子组件通用方法，可传递给父组件复用</span></span></span><br><span class=\"line\"><span class=\"actionscript\">       alert(<span class=\"string\">'123'</span>);</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p>  <strong>父组件编写</strong>：被绑定的属性的集合对象，在父元素中会被 v-slot:xxx=”slotProps” 或者 #xxx=”slotProps” 接收，xxx 代表具名插槽的 name ，slotProps 为子组件传递的数据对象，可以重命名。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 作用域插槽，以及解构插槽 Prop 的写法 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>=<span class=\"string\">\"slotProps\"</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123;slotProps.user.title&#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"slotProps.testClick\"</span>&gt;</span>点我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">template</span> #<span class=\"attr\">footer</span>=<span class=\"string\">\"&#123;user,testClick&#125;\"</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123;user.title&#125;&#125;<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">        此为解构插槽prop<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\">        <span class=\"comment\">&lt;!-- 子组件中的通用方法，可传递给父组件复用 --&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> @<span class=\"attr\">click</span>=<span class=\"string\">\"testClick\"</span>&gt;</span>点我<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">import</span> Child <span class=\"keyword\">from</span> <span class=\"string\">'./component/child.vue'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">  name: <span class=\"string\">'demo'</span>,</span></span><br><span class=\"line\">  components: &#123;</span><br><span class=\"line\">    Child</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD.png\" alt></p>\n<h3 id=\"其它拓展\"><a href=\"#其它拓展\" class=\"headerlink\" title=\"其它拓展\"></a>其它拓展</h3><ul>\n<li><p>解构插槽 prop 可以重命名，例如：<code>v-slot=&quot;{ user: person }&quot;</code> 将 user 对象重命名为 person 使用。</p>\n</li>\n<li><p>解构插槽 prop 可以赋值默认值，例如：<code>v-slot=&quot;{ user = { name: &#39;Guest&#39; } }&quot;</code> 给属性添加自定义后备内容。</p>\n</li>\n<li><p>动态插槽命名，例如：<code>v-slot:[dynamicSlotName]</code> ，支持命名变量定义。</p>\n</li>\n</ul>\n<h3 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li><p><code>v-slot</code> 只能用在 <code>template</code> 上面，或者是独占默认插槽的写法。</p>\n</li>\n<li><p>父组件引用时 ，重复定义了 <code>v-slot</code> 的 <code>name</code> 后只会加载最后一个定义的插槽内容。</p>\n</li>\n<li><p>当子组件只有默认插槽时，才可以使用独占默认插槽的缩写语法，只要出现多个插槽，必须使用完整的基于 <code>template</code> 的语法。</p>\n</li>\n</ul>\n<h2 id=\"slot-以及-slot-scope-的用法\"><a href=\"#slot-以及-slot-scope-的用法\" class=\"headerlink\" title=\"slot 以及 slot-scope 的用法\"></a>slot 以及 slot-scope 的用法</h2><h3 id=\"子组件编写\"><a href=\"#子组件编写\" class=\"headerlink\" title=\"子组件编写\"></a>子组件编写</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 子组件</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"content\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 默认插槽 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">header</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span>&gt;</span>默认值<span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">header</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 具名插槽 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">main</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"main\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">main</span>&gt;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span> <span class=\"attr\">class</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">slot</span> <span class=\"attr\">name</span>=<span class=\"string\">\"footer\"</span> <span class=\"attr\">:user</span>=<span class=\"string\">\"user\"</span> <span class=\"attr\">:testClick</span>=<span class=\"string\">\"testClick\"</span>&gt;</span></span><br><span class=\"line\">        &#123;&#123;user.name&#125;&#125;</span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">slot</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">  name: <span class=\"string\">'child'</span>,</span></span><br><span class=\"line\">  data () &#123;</span><br><span class=\"line\"><span class=\"actionscript\">    <span class=\"keyword\">return</span> &#123;</span></span><br><span class=\"line\">      user: &#123;</span><br><span class=\"line\"><span class=\"actionscript\">        title: <span class=\"string\">'测试title'</span>,</span></span><br><span class=\"line\"><span class=\"actionscript\">        name: <span class=\"string\">'测试name'</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"父组件编写\"><a href=\"#父组件编写\" class=\"headerlink\" title=\"父组件编写\"></a>父组件编写</h3><ul>\n<li>具名插槽：直接使用 <code>slot</code> 属性，传值为子组件插槽的 name 属性。</li>\n<li>作用域插槽：通过 <code>slot-scope</code> 属性来接受子组件传入的属性集合，其他用法一致。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 父组件</span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"container\"</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">       <span class=\"comment\">&lt;!-- 默认插槽 --&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>默认插槽<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">      </span><br><span class=\"line\">       <span class=\"comment\">&lt;!-- 具名插槽 --&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"main\"</span>&gt;</span>具名插槽<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"main\"</span>&gt;</span>具名插槽2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">      </span><br><span class=\"line\">       <span class=\"comment\">&lt;!-- 作用域插槽 --&gt;</span></span><br><span class=\"line\">       <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">slot</span>=<span class=\"string\">\"footer\"</span> <span class=\"attr\">slot-scope</span>=<span class=\"string\">\"slotProps\"</span>&gt;</span></span><br><span class=\"line\">         &#123;&#123;slotProps.user.title&#125;&#125;</span><br><span class=\"line\">       <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;/<span class=\"name\">child</span>&gt;</span></span><br><span class=\"line\">   <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">template</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">import</span> Child <span class=\"keyword\">from</span> <span class=\"string\">'./component/child.vue'</span>;</span></span><br><span class=\"line\"><span class=\"javascript\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span></span><br><span class=\"line\"><span class=\"actionscript\">   name: <span class=\"string\">'demo'</span>,</span></span><br><span class=\"line\">   components: &#123;</span><br><span class=\"line\">     Child</span><br><span class=\"line\">   &#125;,</span><br><span class=\"line\"> &#125;;</span><br><span class=\"line\"> <span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>渲染结果</strong>：<br><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/%E6%B5%85%E8%B0%88v-slot/slot-scope%20%E7%9A%84%E7%94%A8%E6%B3%95.png\" alt></p>\n<h3 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h3><ul>\n<li>不同于 <code>v-slot</code> 的是，slot 中同名可以重复定义多次。</li>\n<li><code>slot</code> 可以直接定义在子组件上。</li>\n<li>v3.0 版本后不可使用 <code>slot</code> ，建议直接使用 <code>v-slot</code> 。</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><ul>\n<li>插槽的 <code>&lt;slot&gt;</code> 的可复用特性，可以用来写一些组件结构固定，内容可替换的组件，例如表格，列表，按钮，弹窗等内容。</li>\n<li>插槽可以传递属性值或者 function 的特性，可以在子组件中写一些通用的函数，例如通用的报错提示等，传递给父组件复用。</li>\n</ul>\n"},{"title":"对于Javascript执行上下文的理解","date":"2019-09-24T02:35:15.000Z","author":"刘涛","_content":"\n\n## 前言\n在这篇文章中，将比较深入地阐述下执行上下文 – JavaScript中最基础也是最重要的一个概念。相信读完这篇文章后，你就会明白javascript引擎内部在执行代码以前到底做了些什么，为什么某些函数以及变量在没有被声明以前就可以被使用，以及它们的最终的值是怎样被定义的。\n\n\n## 什么是执行上下文\nJavascript中代码的运行环境分为以下三种：\n 1. 全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。\n 2. 函数级别的代码 – 当执行一个函数时，运行函数体中的代码。\n 3. Eval的代码 – 在Eval函数内运行的代码。\n\n我们可以将“执行上下文”看做当前代码的运行环境或者作用域。下面我们来看一个示例，其中包括了全局以及函数级别的执行上下文:\n\n![执行上下文](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/u5GPF.png)\n\n上图中，一共用4个执行上下文。紫色的代表全局的上下文；绿色代表person函数内的上下文；蓝色以及橙色代表person函数内的另外两个函数的上下文。注意，不管什么情况下，只存在一个全局的上下文，该上下文能被任何其它的上下文所访问到。也就是说，我们可以在person的上下文中访问到全局上下文中的sayHello变量，当然在函数firstName或者lastName中同样可以访问到该变量。\n\n至于函数上下文的个数是没有任何限制的，每到调用执行一个函数时，引擎就会自动新建出一个函数上下文，换句话说，就是新建一个局部作用域，可以在该局部作用域中声明私有变量等，在外部的上下文中是无法直接访问到该局部作用域内的元素的。在上述例子的，内部的函数可以访问到外部上下文中的声明的变量，反之则行不通。那么，这到底是什么原因呢？引擎内部是如何处理的呢？\n\n\n## 执行上下文堆栈\n在浏览器中，javascript引擎的工作方式是单线程的。也就是说，某一时刻只有唯一的一个事件是被激活处理的，其它的事件被放入队列中，等待被处理。下面的示例图描述了这样的一个堆栈：\n\n![执行上下文](http://pic.yupoo.com/sinaweibo1623108588_v/D73pKNOG/15l3Kp.jpg)\n\n我们已经知道，当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。请看下面一个例子：\n```JavaScript\n (function foo(i) {\n    if (i === 3) {\n      return;\n      }else {\n        foo(++i);\n        }\n    }(0));\n  ```\n\n  上述foo被声明后，通过()运算符强制直接运行了。函数代码就是调用了其自身3次，每次是局部变量i增加1。每次foo函数被自身调用时，就会有一个新的执行上下文被创建。每当一个上下文执行完毕，该上上下文就被弹出堆栈，回到上一个上下文，直到再次回到全局上下文。真个过程抽象如下图:\n\n![执行上下文](http://pic.yupoo.com/sinaweibo1623108588_v/D73qmkTw/bAarT.gif)\n由此可见 ，对于执行上下文这个抽象的概念，可以归纳为以下几点：\n* 单线程\n* 同步执行\n* 唯一的一个全局上下文\n* 函数的执行上下文的个数没有限制\n* 每次某个函数被调用，就会有个新的执行行下文为其创建，即使是调用的自身函数，也是如此。\n\n## 执行上下文的建立过程\n我们现在已经知道，每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:\n1. 建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前)\n  * 建立变量，函数，arguments对象，参数\n  * 建立作用域链\n  * 确定this的值\n2. 代码执行阶段\n  * 变量赋值，函数引用，执行其它代码\n\n实际上可以把执行上下文看做一个对象，其下包含以上3个属性：\n```JavaScript\n (executionContextObj = {\n    variableObject: { /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ },\n    scopeChain: { /* variableObject 以及所有父执行上下文中的variableObject */ },\n    this: {}\n  }\n  ```\n\n\n  ## 建立阶段以及代码执行阶段的详细分析\n  确切地说，执行上下文对象（上述的executionContextObj）是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就是我上述所描述的两个阶段中的第一个阶段 – 建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行上下文对象（executionContextObj）。在这个阶段，variableObject对象，作用域链，以及this所指向的对象都会被确定。\n\n  上述第一个阶段的具体过程如下：\n  1. 找到当前上下文中的调用函数的代码\n  2. 在执行被调用的函数体中的代码以前，开始创建执行上下文\n  3. 进入第一个阶段-建立阶段:<br>\n    * 建立variableObject对象:<br>\n        * 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值<br>\n        * 检查当前上下文中的函数声明:<br>\n        每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用,如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。\n    * 初始化作用域链\n    * 确定上下文中this的指向对象\n\n\n  4. 代码执行阶段：<br>\n   执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。下面来看个具体的代码示例:\n   ```JavaScript\n  function foo(i) {\n    var a = 'hello';\n    var b = function privateB() {  \n      };\n      function c() {\n            }\n        }\n        foo(22);\n  ```\n  在调用foo(22)的时候，建立阶段如下:\n\n ```JavaScript\n   fooExecutionContext = {\n      variableObject: {\n          arguments: {\n              0: 22,\n              length: 1\n          },\n          i: 22,\n          c: pointer to function c()\n          a: undefined,\n          b: undefined\n      },\n      scopeChain: { ... },\n      this: { ... }\n    }\n  ```\n  由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:\n  ```JavaScript\n  fooExecutionContext = {\n      variableObject: {\n          arguments: {\n              0: 22,\n              length: 1\n          },\n          i: 22,\n          c: pointer to function c()\n          a: 'hello',\n          b: pointer to function privateB()\n      },\n      scopeChain: { ... },\n      this: { ... }\n   }\n  ```\n  我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。\n\n\n## 局部变量作用域提升的缘由\n在网上一直看到这样的总结： 在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，就是一进入函数体，就可以访问到其中声明的变量以及函数。这是对的，但是知道其中的缘由吗？相信你通过上述的解释应该也有所明白了。不过在这边再分析一下。看下面一段代码:\n\n```JavaScript\n  (function() {\n      console.log(typeof foo); // function pointer\n      console.log(typeof bar); // undefined\n      var foo = 'hello',\n          bar = function() {\n            return 'world';\n          };\n        \n      function foo() {\n          return 'hello';\n      }\n  }());​\n  ```\n上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过typeof输出foo为一个函数引用，bar为undefined。\n\n为什么我们可以在声明foo变量以前就可以访问到foo呢？\n\n因为在上下文的建立阶段，先是处理arguments, 参数，接着是函数的声明，最后是变量的声明。那么，发现foo函数的声明后，就会在variableObject下面建立一个foo属性，其值是一个指向函数的引用。当处理变量声明的时候，发现有var foo的声明，但是variableObject已经具有了foo属性，所以直接跳过。当进入代码执行阶段的时候，就可以通过访问到foo属性了，因为它已经就存在，并且是一个函数引用。\n\n为什么bar是undefined呢？\n\n因为bar是变量的声明，在建立阶段的时候，被赋予的默认的值为undefined。由于它只要在代码执行阶段才会被赋予具体的值，所以，当调用typeof(bar)的时候输出的值为undefined。\n\n\n\n\n\n\n\n\n\n","source":"_posts/对于Javascript执行上下文的理解.md","raw":"---\ntitle: 对于Javascript执行上下文的理解\ndate: 2019-09-24 10:35:15\ntags: Javascript\nauthor: 刘涛\n---\n\n\n## 前言\n在这篇文章中，将比较深入地阐述下执行上下文 – JavaScript中最基础也是最重要的一个概念。相信读完这篇文章后，你就会明白javascript引擎内部在执行代码以前到底做了些什么，为什么某些函数以及变量在没有被声明以前就可以被使用，以及它们的最终的值是怎样被定义的。\n\n\n## 什么是执行上下文\nJavascript中代码的运行环境分为以下三种：\n 1. 全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。\n 2. 函数级别的代码 – 当执行一个函数时，运行函数体中的代码。\n 3. Eval的代码 – 在Eval函数内运行的代码。\n\n我们可以将“执行上下文”看做当前代码的运行环境或者作用域。下面我们来看一个示例，其中包括了全局以及函数级别的执行上下文:\n\n![执行上下文](https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/u5GPF.png)\n\n上图中，一共用4个执行上下文。紫色的代表全局的上下文；绿色代表person函数内的上下文；蓝色以及橙色代表person函数内的另外两个函数的上下文。注意，不管什么情况下，只存在一个全局的上下文，该上下文能被任何其它的上下文所访问到。也就是说，我们可以在person的上下文中访问到全局上下文中的sayHello变量，当然在函数firstName或者lastName中同样可以访问到该变量。\n\n至于函数上下文的个数是没有任何限制的，每到调用执行一个函数时，引擎就会自动新建出一个函数上下文，换句话说，就是新建一个局部作用域，可以在该局部作用域中声明私有变量等，在外部的上下文中是无法直接访问到该局部作用域内的元素的。在上述例子的，内部的函数可以访问到外部上下文中的声明的变量，反之则行不通。那么，这到底是什么原因呢？引擎内部是如何处理的呢？\n\n\n## 执行上下文堆栈\n在浏览器中，javascript引擎的工作方式是单线程的。也就是说，某一时刻只有唯一的一个事件是被激活处理的，其它的事件被放入队列中，等待被处理。下面的示例图描述了这样的一个堆栈：\n\n![执行上下文](http://pic.yupoo.com/sinaweibo1623108588_v/D73pKNOG/15l3Kp.jpg)\n\n我们已经知道，当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。请看下面一个例子：\n```JavaScript\n (function foo(i) {\n    if (i === 3) {\n      return;\n      }else {\n        foo(++i);\n        }\n    }(0));\n  ```\n\n  上述foo被声明后，通过()运算符强制直接运行了。函数代码就是调用了其自身3次，每次是局部变量i增加1。每次foo函数被自身调用时，就会有一个新的执行上下文被创建。每当一个上下文执行完毕，该上上下文就被弹出堆栈，回到上一个上下文，直到再次回到全局上下文。真个过程抽象如下图:\n\n![执行上下文](http://pic.yupoo.com/sinaweibo1623108588_v/D73qmkTw/bAarT.gif)\n由此可见 ，对于执行上下文这个抽象的概念，可以归纳为以下几点：\n* 单线程\n* 同步执行\n* 唯一的一个全局上下文\n* 函数的执行上下文的个数没有限制\n* 每次某个函数被调用，就会有个新的执行行下文为其创建，即使是调用的自身函数，也是如此。\n\n## 执行上下文的建立过程\n我们现在已经知道，每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:\n1. 建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前)\n  * 建立变量，函数，arguments对象，参数\n  * 建立作用域链\n  * 确定this的值\n2. 代码执行阶段\n  * 变量赋值，函数引用，执行其它代码\n\n实际上可以把执行上下文看做一个对象，其下包含以上3个属性：\n```JavaScript\n (executionContextObj = {\n    variableObject: { /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ },\n    scopeChain: { /* variableObject 以及所有父执行上下文中的variableObject */ },\n    this: {}\n  }\n  ```\n\n\n  ## 建立阶段以及代码执行阶段的详细分析\n  确切地说，执行上下文对象（上述的executionContextObj）是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就是我上述所描述的两个阶段中的第一个阶段 – 建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行上下文对象（executionContextObj）。在这个阶段，variableObject对象，作用域链，以及this所指向的对象都会被确定。\n\n  上述第一个阶段的具体过程如下：\n  1. 找到当前上下文中的调用函数的代码\n  2. 在执行被调用的函数体中的代码以前，开始创建执行上下文\n  3. 进入第一个阶段-建立阶段:<br>\n    * 建立variableObject对象:<br>\n        * 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值<br>\n        * 检查当前上下文中的函数声明:<br>\n        每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用,如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。\n    * 初始化作用域链\n    * 确定上下文中this的指向对象\n\n\n  4. 代码执行阶段：<br>\n   执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。下面来看个具体的代码示例:\n   ```JavaScript\n  function foo(i) {\n    var a = 'hello';\n    var b = function privateB() {  \n      };\n      function c() {\n            }\n        }\n        foo(22);\n  ```\n  在调用foo(22)的时候，建立阶段如下:\n\n ```JavaScript\n   fooExecutionContext = {\n      variableObject: {\n          arguments: {\n              0: 22,\n              length: 1\n          },\n          i: 22,\n          c: pointer to function c()\n          a: undefined,\n          b: undefined\n      },\n      scopeChain: { ... },\n      this: { ... }\n    }\n  ```\n  由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:\n  ```JavaScript\n  fooExecutionContext = {\n      variableObject: {\n          arguments: {\n              0: 22,\n              length: 1\n          },\n          i: 22,\n          c: pointer to function c()\n          a: 'hello',\n          b: pointer to function privateB()\n      },\n      scopeChain: { ... },\n      this: { ... }\n   }\n  ```\n  我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。\n\n\n## 局部变量作用域提升的缘由\n在网上一直看到这样的总结： 在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，就是一进入函数体，就可以访问到其中声明的变量以及函数。这是对的，但是知道其中的缘由吗？相信你通过上述的解释应该也有所明白了。不过在这边再分析一下。看下面一段代码:\n\n```JavaScript\n  (function() {\n      console.log(typeof foo); // function pointer\n      console.log(typeof bar); // undefined\n      var foo = 'hello',\n          bar = function() {\n            return 'world';\n          };\n        \n      function foo() {\n          return 'hello';\n      }\n  }());​\n  ```\n上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过typeof输出foo为一个函数引用，bar为undefined。\n\n为什么我们可以在声明foo变量以前就可以访问到foo呢？\n\n因为在上下文的建立阶段，先是处理arguments, 参数，接着是函数的声明，最后是变量的声明。那么，发现foo函数的声明后，就会在variableObject下面建立一个foo属性，其值是一个指向函数的引用。当处理变量声明的时候，发现有var foo的声明，但是variableObject已经具有了foo属性，所以直接跳过。当进入代码执行阶段的时候，就可以通过访问到foo属性了，因为它已经就存在，并且是一个函数引用。\n\n为什么bar是undefined呢？\n\n因为bar是变量的声明，在建立阶段的时候，被赋予的默认的值为undefined。由于它只要在代码执行阶段才会被赋予具体的值，所以，当调用typeof(bar)的时候输出的值为undefined。\n\n\n\n\n\n\n\n\n\n","slug":"对于Javascript执行上下文的理解","published":1,"updated":"2019-10-10T01:08:43.908Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck2ydufy100244sef2c5329wz","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在这篇文章中，将比较深入地阐述下执行上下文 – JavaScript中最基础也是最重要的一个概念。相信读完这篇文章后，你就会明白javascript引擎内部在执行代码以前到底做了些什么，为什么某些函数以及变量在没有被声明以前就可以被使用，以及它们的最终的值是怎样被定义的。</p>\n<h2 id=\"什么是执行上下文\"><a href=\"#什么是执行上下文\" class=\"headerlink\" title=\"什么是执行上下文\"></a>什么是执行上下文</h2><p>Javascript中代码的运行环境分为以下三种：</p>\n<ol>\n<li>全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。</li>\n<li>函数级别的代码 – 当执行一个函数时，运行函数体中的代码。</li>\n<li>Eval的代码 – 在Eval函数内运行的代码。</li>\n</ol>\n<p>我们可以将“执行上下文”看做当前代码的运行环境或者作用域。下面我们来看一个示例，其中包括了全局以及函数级别的执行上下文:</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/u5GPF.png\" alt=\"执行上下文\"></p>\n<p>上图中，一共用4个执行上下文。紫色的代表全局的上下文；绿色代表person函数内的上下文；蓝色以及橙色代表person函数内的另外两个函数的上下文。注意，不管什么情况下，只存在一个全局的上下文，该上下文能被任何其它的上下文所访问到。也就是说，我们可以在person的上下文中访问到全局上下文中的sayHello变量，当然在函数firstName或者lastName中同样可以访问到该变量。</p>\n<p>至于函数上下文的个数是没有任何限制的，每到调用执行一个函数时，引擎就会自动新建出一个函数上下文，换句话说，就是新建一个局部作用域，可以在该局部作用域中声明私有变量等，在外部的上下文中是无法直接访问到该局部作用域内的元素的。在上述例子的，内部的函数可以访问到外部上下文中的声明的变量，反之则行不通。那么，这到底是什么原因呢？引擎内部是如何处理的呢？</p>\n<h2 id=\"执行上下文堆栈\"><a href=\"#执行上下文堆栈\" class=\"headerlink\" title=\"执行上下文堆栈\"></a>执行上下文堆栈</h2><p>在浏览器中，javascript引擎的工作方式是单线程的。也就是说，某一时刻只有唯一的一个事件是被激活处理的，其它的事件被放入队列中，等待被处理。下面的示例图描述了这样的一个堆栈：</p>\n<p><img src=\"http://pic.yupoo.com/sinaweibo1623108588_v/D73pKNOG/15l3Kp.jpg\" alt=\"执行上下文\"></p>\n<p>我们已经知道，当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。请看下面一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (i === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       foo(++i);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n\n<p>  上述foo被声明后，通过()运算符强制直接运行了。函数代码就是调用了其自身3次，每次是局部变量i增加1。每次foo函数被自身调用时，就会有一个新的执行上下文被创建。每当一个上下文执行完毕，该上上下文就被弹出堆栈，回到上一个上下文，直到再次回到全局上下文。真个过程抽象如下图:</p>\n<p><img src=\"http://pic.yupoo.com/sinaweibo1623108588_v/D73qmkTw/bAarT.gif\" alt=\"执行上下文\"><br>由此可见 ，对于执行上下文这个抽象的概念，可以归纳为以下几点：</p>\n<ul>\n<li>单线程</li>\n<li>同步执行</li>\n<li>唯一的一个全局上下文</li>\n<li>函数的执行上下文的个数没有限制</li>\n<li>每次某个函数被调用，就会有个新的执行行下文为其创建，即使是调用的自身函数，也是如此。</li>\n</ul>\n<h2 id=\"执行上下文的建立过程\"><a href=\"#执行上下文的建立过程\" class=\"headerlink\" title=\"执行上下文的建立过程\"></a>执行上下文的建立过程</h2><p>我们现在已经知道，每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:</p>\n<ol>\n<li>建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前)<ul>\n<li>建立变量，函数，arguments对象，参数</li>\n<li>建立作用域链</li>\n<li>确定this的值</li>\n</ul>\n</li>\n<li>代码执行阶段<ul>\n<li>变量赋值，函数引用，执行其它代码</li>\n</ul>\n</li>\n</ol>\n<p>实际上可以把执行上下文看做一个对象，其下包含以上3个属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(executionContextObj = &#123;</span><br><span class=\"line\">   variableObject: &#123; <span class=\"comment\">/* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */</span> &#125;,</span><br><span class=\"line\">   scopeChain: &#123; <span class=\"comment\">/* variableObject 以及所有父执行上下文中的variableObject */</span> &#125;,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>: &#123;&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建立阶段以及代码执行阶段的详细分析\"><a href=\"#建立阶段以及代码执行阶段的详细分析\" class=\"headerlink\" title=\"建立阶段以及代码执行阶段的详细分析\"></a>建立阶段以及代码执行阶段的详细分析</h2><p>  确切地说，执行上下文对象（上述的executionContextObj）是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就是我上述所描述的两个阶段中的第一个阶段 – 建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行上下文对象（executionContextObj）。在这个阶段，variableObject对象，作用域链，以及this所指向的对象都会被确定。</p>\n<p>  上述第一个阶段的具体过程如下：</p>\n<ol>\n<li>找到当前上下文中的调用函数的代码</li>\n<li>在执行被调用的函数体中的代码以前，开始创建执行上下文</li>\n<li>进入第一个阶段-建立阶段:<br><ul>\n<li>建立variableObject对象:<br><ul>\n<li>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值<br></li>\n<li>检查当前上下文中的函数声明:<br><br>每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用,如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。</li>\n</ul>\n</li>\n<li>初始化作用域链</li>\n<li>确定上下文中this的指向对象</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>代码执行阶段：<br><br>执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。下面来看个具体的代码示例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">privateB</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      foo(<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在调用foo(22)的时候，建立阶段如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooExecutionContext = &#123;</span><br><span class=\"line\">   variableObject: &#123;</span><br><span class=\"line\">       <span class=\"built_in\">arguments</span>: &#123;</span><br><span class=\"line\">           <span class=\"number\">0</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">           length: <span class=\"number\">1</span></span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       i: <span class=\"number\">22</span>,</span><br><span class=\"line\">       c: pointer to <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">a</span>: <span class=\"title\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">b</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\">   &#125;,</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">scopeChain</span>: </span>&#123; ... &#125;,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>: &#123; ... &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooExecutionContext = &#123;</span><br><span class=\"line\">    variableObject: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">arguments</span>: &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">            length: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        i: <span class=\"number\">22</span>,</span><br><span class=\"line\">        c: pointer to <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">a</span>: '<span class=\"title\">hello</span>',</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">b</span>: <span class=\"title\">pointer</span> <span class=\"title\">to</span> <span class=\"title\">function</span> <span class=\"title\">privateB</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    &#125;,</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">scopeChain</span>: </span>&#123; ... &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>: &#123; ... &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。</p>\n</li>\n</ol>\n<h2 id=\"局部变量作用域提升的缘由\"><a href=\"#局部变量作用域提升的缘由\" class=\"headerlink\" title=\"局部变量作用域提升的缘由\"></a>局部变量作用域提升的缘由</h2><p>在网上一直看到这样的总结： 在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，就是一进入函数体，就可以访问到其中声明的变量以及函数。这是对的，但是知道其中的缘由吗？相信你通过上述的解释应该也有所明白了。不过在这边再分析一下。看下面一段代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> foo); <span class=\"comment\">// function pointer</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> bar); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">        bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;());​</span><br></pre></td></tr></table></figure>\n\n<p>上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过typeof输出foo为一个函数引用，bar为undefined。</p>\n<p>为什么我们可以在声明foo变量以前就可以访问到foo呢？</p>\n<p>因为在上下文的建立阶段，先是处理arguments, 参数，接着是函数的声明，最后是变量的声明。那么，发现foo函数的声明后，就会在variableObject下面建立一个foo属性，其值是一个指向函数的引用。当处理变量声明的时候，发现有var foo的声明，但是variableObject已经具有了foo属性，所以直接跳过。当进入代码执行阶段的时候，就可以通过访问到foo属性了，因为它已经就存在，并且是一个函数引用。</p>\n<p>为什么bar是undefined呢？</p>\n<p>因为bar是变量的声明，在建立阶段的时候，被赋予的默认的值为undefined。由于它只要在代码执行阶段才会被赋予具体的值，所以，当调用typeof(bar)的时候输出的值为undefined。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在这篇文章中，将比较深入地阐述下执行上下文 – JavaScript中最基础也是最重要的一个概念。相信读完这篇文章后，你就会明白javascript引擎内部在执行代码以前到底做了些什么，为什么某些函数以及变量在没有被声明以前就可以被使用，以及它们的最终的值是怎样被定义的。</p>\n<h2 id=\"什么是执行上下文\"><a href=\"#什么是执行上下文\" class=\"headerlink\" title=\"什么是执行上下文\"></a>什么是执行上下文</h2><p>Javascript中代码的运行环境分为以下三种：</p>\n<ol>\n<li>全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。</li>\n<li>函数级别的代码 – 当执行一个函数时，运行函数体中的代码。</li>\n<li>Eval的代码 – 在Eval函数内运行的代码。</li>\n</ol>\n<p>我们可以将“执行上下文”看做当前代码的运行环境或者作用域。下面我们来看一个示例，其中包括了全局以及函数级别的执行上下文:</p>\n<p><img src=\"https://images-1300364015.cos.ap-shanghai.myqcloud.com/blogs/js%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/u5GPF.png\" alt=\"执行上下文\"></p>\n<p>上图中，一共用4个执行上下文。紫色的代表全局的上下文；绿色代表person函数内的上下文；蓝色以及橙色代表person函数内的另外两个函数的上下文。注意，不管什么情况下，只存在一个全局的上下文，该上下文能被任何其它的上下文所访问到。也就是说，我们可以在person的上下文中访问到全局上下文中的sayHello变量，当然在函数firstName或者lastName中同样可以访问到该变量。</p>\n<p>至于函数上下文的个数是没有任何限制的，每到调用执行一个函数时，引擎就会自动新建出一个函数上下文，换句话说，就是新建一个局部作用域，可以在该局部作用域中声明私有变量等，在外部的上下文中是无法直接访问到该局部作用域内的元素的。在上述例子的，内部的函数可以访问到外部上下文中的声明的变量，反之则行不通。那么，这到底是什么原因呢？引擎内部是如何处理的呢？</p>\n<h2 id=\"执行上下文堆栈\"><a href=\"#执行上下文堆栈\" class=\"headerlink\" title=\"执行上下文堆栈\"></a>执行上下文堆栈</h2><p>在浏览器中，javascript引擎的工作方式是单线程的。也就是说，某一时刻只有唯一的一个事件是被激活处理的，其它的事件被放入队列中，等待被处理。下面的示例图描述了这样的一个堆栈：</p>\n<p><img src=\"http://pic.yupoo.com/sinaweibo1623108588_v/D73pKNOG/15l3Kp.jpg\" alt=\"执行上下文\"></p>\n<p>我们已经知道，当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。请看下面一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> (i === <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span>;</span><br><span class=\"line\">     &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">       foo(++i);</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;(<span class=\"number\">0</span>));</span><br></pre></td></tr></table></figure>\n\n<p>  上述foo被声明后，通过()运算符强制直接运行了。函数代码就是调用了其自身3次，每次是局部变量i增加1。每次foo函数被自身调用时，就会有一个新的执行上下文被创建。每当一个上下文执行完毕，该上上下文就被弹出堆栈，回到上一个上下文，直到再次回到全局上下文。真个过程抽象如下图:</p>\n<p><img src=\"http://pic.yupoo.com/sinaweibo1623108588_v/D73qmkTw/bAarT.gif\" alt=\"执行上下文\"><br>由此可见 ，对于执行上下文这个抽象的概念，可以归纳为以下几点：</p>\n<ul>\n<li>单线程</li>\n<li>同步执行</li>\n<li>唯一的一个全局上下文</li>\n<li>函数的执行上下文的个数没有限制</li>\n<li>每次某个函数被调用，就会有个新的执行行下文为其创建，即使是调用的自身函数，也是如此。</li>\n</ul>\n<h2 id=\"执行上下文的建立过程\"><a href=\"#执行上下文的建立过程\" class=\"headerlink\" title=\"执行上下文的建立过程\"></a>执行上下文的建立过程</h2><p>我们现在已经知道，每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段:</p>\n<ol>\n<li>建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前)<ul>\n<li>建立变量，函数，arguments对象，参数</li>\n<li>建立作用域链</li>\n<li>确定this的值</li>\n</ul>\n</li>\n<li>代码执行阶段<ul>\n<li>变量赋值，函数引用，执行其它代码</li>\n</ul>\n</li>\n</ol>\n<p>实际上可以把执行上下文看做一个对象，其下包含以上3个属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(executionContextObj = &#123;</span><br><span class=\"line\">   variableObject: &#123; <span class=\"comment\">/* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */</span> &#125;,</span><br><span class=\"line\">   scopeChain: &#123; <span class=\"comment\">/* variableObject 以及所有父执行上下文中的variableObject */</span> &#125;,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>: &#123;&#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"建立阶段以及代码执行阶段的详细分析\"><a href=\"#建立阶段以及代码执行阶段的详细分析\" class=\"headerlink\" title=\"建立阶段以及代码执行阶段的详细分析\"></a>建立阶段以及代码执行阶段的详细分析</h2><p>  确切地说，执行上下文对象（上述的executionContextObj）是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就是我上述所描述的两个阶段中的第一个阶段 – 建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行上下文对象（executionContextObj）。在这个阶段，variableObject对象，作用域链，以及this所指向的对象都会被确定。</p>\n<p>  上述第一个阶段的具体过程如下：</p>\n<ol>\n<li>找到当前上下文中的调用函数的代码</li>\n<li>在执行被调用的函数体中的代码以前，开始创建执行上下文</li>\n<li>进入第一个阶段-建立阶段:<br><ul>\n<li>建立variableObject对象:<br><ul>\n<li>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值<br></li>\n<li>检查当前上下文中的函数声明:<br><br>每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用,如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。</li>\n</ul>\n</li>\n<li>初始化作用域链</li>\n<li>确定上下文中this的指向对象</li>\n</ul>\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>代码执行阶段：<br><br>执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。下面来看个具体的代码示例:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> b = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">privateB</span>(<span class=\"params\"></span>) </span>&#123;  </span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      foo(<span class=\"number\">22</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在调用foo(22)的时候，建立阶段如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooExecutionContext = &#123;</span><br><span class=\"line\">   variableObject: &#123;</span><br><span class=\"line\">       <span class=\"built_in\">arguments</span>: &#123;</span><br><span class=\"line\">           <span class=\"number\">0</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">           length: <span class=\"number\">1</span></span><br><span class=\"line\">       &#125;,</span><br><span class=\"line\">       i: <span class=\"number\">22</span>,</span><br><span class=\"line\">       c: pointer to <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">a</span>: <span class=\"title\">undefined</span>,</span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"title\">b</span>: <span class=\"title\">undefined</span></span></span><br><span class=\"line\"><span class=\"function\">   &#125;,</span></span><br><span class=\"line\"><span class=\"function\">   <span class=\"title\">scopeChain</span>: </span>&#123; ... &#125;,</span><br><span class=\"line\">   <span class=\"keyword\">this</span>: &#123; ... &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fooExecutionContext = &#123;</span><br><span class=\"line\">    variableObject: &#123;</span><br><span class=\"line\">        <span class=\"built_in\">arguments</span>: &#123;</span><br><span class=\"line\">            <span class=\"number\">0</span>: <span class=\"number\">22</span>,</span><br><span class=\"line\">            length: <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        i: <span class=\"number\">22</span>,</span><br><span class=\"line\">        c: pointer to <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">a</span>: '<span class=\"title\">hello</span>',</span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"title\">b</span>: <span class=\"title\">pointer</span> <span class=\"title\">to</span> <span class=\"title\">function</span> <span class=\"title\">privateB</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\">    &#125;,</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">scopeChain</span>: </span>&#123; ... &#125;,</span><br><span class=\"line\">    <span class=\"keyword\">this</span>: &#123; ... &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。</p>\n</li>\n</ol>\n<h2 id=\"局部变量作用域提升的缘由\"><a href=\"#局部变量作用域提升的缘由\" class=\"headerlink\" title=\"局部变量作用域提升的缘由\"></a>局部变量作用域提升的缘由</h2><p>在网上一直看到这样的总结： 在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，就是一进入函数体，就可以访问到其中声明的变量以及函数。这是对的，但是知道其中的缘由吗？相信你通过上述的解释应该也有所明白了。不过在这边再分析一下。看下面一段代码:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> foo); <span class=\"comment\">// function pointer</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> bar); <span class=\"comment\">// undefined</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> foo = <span class=\"string\">'hello'</span>,</span><br><span class=\"line\">        bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"string\">'world'</span>;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">      </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'hello'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;());​</span><br></pre></td></tr></table></figure>\n\n<p>上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过typeof输出foo为一个函数引用，bar为undefined。</p>\n<p>为什么我们可以在声明foo变量以前就可以访问到foo呢？</p>\n<p>因为在上下文的建立阶段，先是处理arguments, 参数，接着是函数的声明，最后是变量的声明。那么，发现foo函数的声明后，就会在variableObject下面建立一个foo属性，其值是一个指向函数的引用。当处理变量声明的时候，发现有var foo的声明，但是variableObject已经具有了foo属性，所以直接跳过。当进入代码执行阶段的时候，就可以通过访问到foo属性了，因为它已经就存在，并且是一个函数引用。</p>\n<p>为什么bar是undefined呢？</p>\n<p>因为bar是变量的声明，在建立阶段的时候，被赋予的默认的值为undefined。由于它只要在代码执行阶段才会被赋予具体的值，所以，当调用typeof(bar)的时候输出的值为undefined。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck2ydufvn00004sefpwxm0rmq","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufw6000d4seftqruqe8v"},{"post_id":"ck2ydufvt00024sefyj7v5e98","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwa000j4seft2iwc6yn"},{"post_id":"ck2ydufw3000b4seflxes8tlg","category_id":"ck2ydufw7000f4sefm34m9x3f","_id":"ck2ydufwh000s4sefya6scuab"},{"post_id":"ck2ydufwd000o4sef61kkbj2n","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwk000x4sefcmh3rze3"},{"post_id":"ck2ydufw5000c4sefw8spq7v5","category_id":"ck2ydufw7000f4sefm34m9x3f","_id":"ck2ydufwm00114sefb62pieiw"},{"post_id":"ck2ydufwi000u4sefwg7g7553","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwn00144sef1f3vh0iw"},{"post_id":"ck2ydufw7000h4sef4tqs1rdw","category_id":"ck2ydufw7000f4sefm34m9x3f","_id":"ck2ydufwo00174seffsp9tn4g"},{"post_id":"ck2ydufwj000w4sefvfg0x01z","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwp00194sef1ls1v1gp"},{"post_id":"ck2ydufwl00104sefrru33tr5","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwp001b4sefu983evht"},{"post_id":"ck2ydufw9000i4sef7s10hh3g","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwq001c4sefyqpljgop"},{"post_id":"ck2ydufw9000i4sef7s10hh3g","category_id":"ck2ydufwk000y4sefy6m3pk7m","_id":"ck2ydufwr001f4sef5jx38dr7"},{"post_id":"ck2ydufwf000q4sefn0mkl3ff","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufwr001g4sefqousj1mg"},{"post_id":"ck2ydufwf000q4sefn0mkl3ff","category_id":"ck2ydufwk000y4sefy6m3pk7m","_id":"ck2ydufwr001i4sef3iki2rva"},{"post_id":"ck2ydufxo001r4sef44072hc4","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufxv001x4sefyfeu05ra"},{"post_id":"ck2ydufxt001v4sefq94i7bcj","category_id":"ck2ydufvv00034sefii03bde8","_id":"ck2ydufxz00214sef1snqpddu"},{"post_id":"ck2ydufxz00224sefxrbprz4e","category_id":"ck2ydufy200254sefb2sd74w3","_id":"ck2ydufy400294sefrv258116"}],"PostTag":[{"post_id":"ck2ydufvn00004sefpwxm0rmq","tag_id":"ck2ydufvx00044sefwlkx9u9r","_id":"ck2ydufw3000a4sefvhqmjwt6"},{"post_id":"ck2ydufvt00024sefyj7v5e98","tag_id":"ck2ydufvx00044sefwlkx9u9r","_id":"ck2ydufw7000g4sef05t5bpk9"},{"post_id":"ck2ydufvx00054sef3ol78ye7","tag_id":"ck2ydufw6000e4sefdy2blkwz","_id":"ck2ydufwd000n4sef3nrpf762"},{"post_id":"ck2ydufw3000b4seflxes8tlg","tag_id":"ck2ydufwb000k4sefjomudphq","_id":"ck2ydufwh000t4sefxmevd6xr"},{"post_id":"ck2ydufw5000c4sefw8spq7v5","tag_id":"ck2ydufwb000k4sefjomudphq","_id":"ck2ydufwl000z4sef6wsbycpj"},{"post_id":"ck2ydufwi000u4sefwg7g7553","tag_id":"ck2ydufvx00044sefwlkx9u9r","_id":"ck2ydufwm00124seffve70anm"},{"post_id":"ck2ydufw7000h4sef4tqs1rdw","tag_id":"ck2ydufwb000k4sefjomudphq","_id":"ck2ydufwo00164sef6ge6ek7x"},{"post_id":"ck2ydufw9000i4sef7s10hh3g","tag_id":"ck2ydufwn00134seff9j6d7lo","_id":"ck2ydufwp001a4sef7ewcgsiu"},{"post_id":"ck2ydufwb000l4sefzkknzyfg","tag_id":"ck2ydufwp00184sefru8vzclw","_id":"ck2ydufwq001e4sefnfes6rcv"},{"post_id":"ck2ydufwd000o4sef61kkbj2n","tag_id":"ck2ydufwq001d4seffuq1yo17","_id":"ck2ydufws001j4sefcjoavd7i"},{"post_id":"ck2ydufwf000q4sefn0mkl3ff","tag_id":"ck2ydufwr001h4sefw8vs1t4k","_id":"ck2ydufwt001m4seff0vgs9xv"},{"post_id":"ck2ydufwf000q4sefn0mkl3ff","tag_id":"ck2ydufws001k4sefg0ivtvk9","_id":"ck2ydufwt001n4sefczfxmwpy"},{"post_id":"ck2ydufwj000w4sefvfg0x01z","tag_id":"ck2ydufws001l4sefg5h26mly","_id":"ck2ydufwu001p4sefdfe4hlan"},{"post_id":"ck2ydufwl00104sefrru33tr5","tag_id":"ck2ydufwt001o4sef3h3y0nha","_id":"ck2ydufwu001q4sef2f4pv57j"},{"post_id":"ck2ydufxo001r4sef44072hc4","tag_id":"ck2ydufxt001u4sefqycc5jmm","_id":"ck2ydufxx001z4sefccvjjc39"},{"post_id":"ck2ydufxy00204sef738s1pmy","tag_id":"ck2ydufy100234sefykckku5z","_id":"ck2ydufy300274sefdroxdrui"},{"post_id":"ck2ydufxz00224sefxrbprz4e","tag_id":"ck2ydufy300264sefm24hcjag","_id":"ck2ydufy5002a4sefeis7rmw8"},{"post_id":"ck2ydufy100244sef2c5329wz","tag_id":"ck2ydufy100234sefykckku5z","_id":"ck2ydufy5002b4sefu0zy51ze"}],"Tag":[{"name":"js基础","_id":"ck2ydufvx00044sefwlkx9u9r"},{"name":"javascript","_id":"ck2ydufw6000e4sefdy2blkwz"},{"name":"gulp","_id":"ck2ydufwb000k4sefjomudphq"},{"name":"vue","_id":"ck2ydufwn00134seff9j6d7lo"},{"name":"css","_id":"ck2ydufwp00184sefru8vzclw"},{"name":"性能测试","_id":"ck2ydufwq001d4seffuq1yo17"},{"name":"SSR","_id":"ck2ydufwr001h4sefw8vs1t4k"},{"name":"Nuxt","_id":"ck2ydufws001k4sefg0ivtvk9"},{"name":"前端路由","_id":"ck2ydufws001l4sefg5h26mly"},{"name":"闭包","_id":"ck2ydufwt001o4sef3h3y0nha"},{"name":"js","_id":"ck2ydufxt001u4sefqycc5jmm"},{"name":"Javascript","_id":"ck2ydufy100234sefykckku5z"},{"name":"vue基础","_id":"ck2ydufy300264sefm24hcjag"}]}}