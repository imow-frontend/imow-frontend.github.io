{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/cleanBlog/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/mixins.styl","path":"css/mixins.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/cleanBlog/LICENSE","hash":"34ac5e147727699d1bbc346b014f2e0bdfbb0947","modified":1565070791543},{"_id":"themes/cleanBlog/README.md","hash":"779e999931169acdbabf43ab0e70471e8631583a","modified":1565070791545},{"_id":"themes/cleanBlog/_config.yml","hash":"85f70d953d66d9c8a840f672d842c25a5697e679","modified":1565070791547},{"_id":"source/_posts/==的隐式转换.md","hash":"be92da53dad212c87a5824eb3cd562507e2a4413","modified":1565075987499},{"_id":"source/_posts/javascript中的Map.md","hash":"f69ba24f6824d01d859e54aaf286dcf1662d804b","modified":1566812739146},{"_id":"source/_posts/cookie、localstorage和sessionstorage三者之间的区别以及使用方式.md","hash":"19454e21bb811c19d486bf2a2962775359949296","modified":1565077318876},{"_id":"source/_posts/javascript垃圾回收机制.md","hash":"b8fb93ae09e31dd51c210e40dd4989542594a0c4","modified":1565077318883},{"_id":"themes/cleanBlog/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1565070791549},{"_id":"themes/cleanBlog/languages/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1565070791550},{"_id":"themes/cleanBlog/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1565070791553},{"_id":"themes/cleanBlog/languages/ko.yml","hash":"b52f84a08d877b545751441c45a1961105eb4372","modified":1565070791556},{"_id":"themes/cleanBlog/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1565070791553},{"_id":"themes/cleanBlog/languages/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1565070791551},{"_id":"themes/cleanBlog/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1565070791556},{"_id":"themes/cleanBlog/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1565070791559},{"_id":"themes/cleanBlog/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1565070791560},{"_id":"themes/cleanBlog/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1565070791563},{"_id":"themes/cleanBlog/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1565070791561},{"_id":"themes/cleanBlog/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1565070791564},{"_id":"themes/cleanBlog/layout/archive.ejs","hash":"c3aa4a76ee8b59b0e12ddbe951a9852176058eac","modified":1565070791587},{"_id":"themes/cleanBlog/layout/index.ejs","hash":"7dfdd9347f14b782d305a70f9ddb696ee1bb3864","modified":1565070791589},{"_id":"themes/cleanBlog/layout/layout.ejs","hash":"acc791dc4346c135ce4cac3cdeba6f96708115e5","modified":1565070791590},{"_id":"themes/cleanBlog/layout/page.ejs","hash":"b585761947e289f0e37380780cfdebee0674c378","modified":1565070791592},{"_id":"themes/cleanBlog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1565070791594},{"_id":"themes/cleanBlog/layout/_partial/after-footer.ejs","hash":"f199b6e0039a7e9f840b8fbb9971fbd673ba5ce3","modified":1565070791566},{"_id":"themes/cleanBlog/layout/_partial/article-archive.ejs","hash":"75b9b24c226eda4884752a868177b590d3e8b06f","modified":1565070791567},{"_id":"themes/cleanBlog/layout/_partial/article-categories.ejs","hash":"b494e4a50f63d66e545da449af18a7198a057bd6","modified":1565070791570},{"_id":"themes/cleanBlog/layout/_partial/article-index.ejs","hash":"ad112adf312337c60d436fdd127e948fe81b3dd1","modified":1565070791573},{"_id":"themes/cleanBlog/layout/_partial/article-full.ejs","hash":"b71cc571f43127bc0307557a201b99e7eb015fc7","modified":1565070791571},{"_id":"themes/cleanBlog/layout/_partial/article-tags.ejs","hash":"12524df0c1ce5136a8f88cea2fe550f9e1b47b19","modified":1565070791574},{"_id":"themes/cleanBlog/layout/_partial/comments.ejs","hash":"5cafed11b6cfbf22e83674676c0edc6c4420cc0d","modified":1565070791575},{"_id":"themes/cleanBlog/layout/_partial/footer.ejs","hash":"c2315e0d51296b5ab3746a100530d083274da2b6","modified":1565070791577},{"_id":"themes/cleanBlog/layout/_partial/gallery.ejs","hash":"15e9562d0f6146e25e22856693d1312cd3ade4af","modified":1565070791579},{"_id":"themes/cleanBlog/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1565070791580},{"_id":"themes/cleanBlog/layout/_partial/head.ejs","hash":"d453acf2b17665be69f209d85505e341775c2b55","modified":1565070791581},{"_id":"themes/cleanBlog/layout/_partial/menu.ejs","hash":"3c51a2a2f950ab2ca80f10d3d3941d5d8cd08ec7","modified":1565070791583},{"_id":"themes/cleanBlog/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1565070791584},{"_id":"themes/cleanBlog/layout/_partial/tag-category-index.ejs","hash":"008b4ed0b6fd6dc81bc0655ccc46e43eb310706b","modified":1565070791586},{"_id":"themes/cleanBlog/source/css/article.styl","hash":"768418ecaa2ff17f6fa81d72096627e05579fe93","modified":1565070791596},{"_id":"themes/cleanBlog/source/css/base.styl","hash":"447a0dedad485b5d79f8ab5435bd43a1c8f9ba9f","modified":1565070791598},{"_id":"themes/cleanBlog/source/css/mixins.styl","hash":"cf700a1c1c62b17d35a8f7500bf1a32d9bc6ab6a","modified":1565070791600},{"_id":"themes/cleanBlog/source/css/style.styl","hash":"7200d572751c1f5888b3d0df25bf503a3f31ca2d","modified":1565070791601},{"_id":"themes/cleanBlog/source/css/variables.styl","hash":"06e16f64020cbddf2c2c49ef45f940141a1b2ada","modified":1565070791603},{"_id":"themes/cleanBlog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1565070791605},{"_id":"themes/cleanBlog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1565070791612},{"_id":"themes/cleanBlog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1565070791608},{"_id":"public/2019/04/28/==的隐式转换/index.html","hash":"064f2644408833c295ba8e8f1fecd7a0f0c73190","modified":1566810350625},{"_id":"public/archives/index.html","hash":"987ac47a8b1080517ed0ef5a3d3e5b0653c31383","modified":1566810350625},{"_id":"public/archives/2019/index.html","hash":"c065b04c64eb1d271983432e62d4e9ccc118fa65","modified":1566810350626},{"_id":"public/archives/2019/04/index.html","hash":"c2996b0c43633ff9a8b88491b2a8a74bdf860ea2","modified":1566810350626},{"_id":"public/archives/2019/07/index.html","hash":"7e4fea428369ea2433a7348556399d2a7f5f3e74","modified":1566810350626},{"_id":"public/archives/2019/08/index.html","hash":"f11450c06b3ef18aa0f0b80f395b63acad92d0c3","modified":1566810350626},{"_id":"public/index.html","hash":"8dbe8eaf02911836eb494bd384656ff5acbefee0","modified":1566810350626},{"_id":"public/2019/08/26/javascript中的Map/index.html","hash":"5dc23207c3347ba665bbc259baffccf9a97e176a","modified":1566812749079},{"_id":"public/2019/08/06/cookie、localstorage和sessionstorage三者之间的区别以及使用方式/index.html","hash":"8693378488276375b60c549f7c278a03d24ccf0b","modified":1566810350626},{"_id":"public/2019/07/01/javascript垃圾回收机制/index.html","hash":"697d24b2d10b11a70efebaeaf1dc26ec1a578ad9","modified":1566810350626},{"_id":"public/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1566810350988},{"_id":"public/css/article.css","hash":"f0ee490e1207191946fffc9444f891e9b7ae7289","modified":1566810350993},{"_id":"public/css/mixins.css","hash":"45146e7f4346351cd7f364de344aecf9574475f9","modified":1566810350993},{"_id":"public/css/base.css","hash":"91b6c032be9e146dfd68880fe79f77f5d2771b0f","modified":1566810350993},{"_id":"public/css/style.css","hash":"029be79fde48199c77c76dbaac80cec3715f0bc8","modified":1566810350993},{"_id":"public/css/variables.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1566810350993},{"_id":"public/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1566810351007},{"_id":"public/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1566810351009}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"==的隐式转换","date":"2019-04-28T01:13:40.000Z","_content":"\n## 前言\n==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的\n \n```\n     对象\n        \\\n        字符串   布尔值\n          \\      /\n            数值\n\n\n1. 对象和布尔值比较\n对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字\n[] == true;  //false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false\n\n2. 对象和字符串比较\n对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。\n[1,2,3] == '1,2,3' // true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;\n\n3. 对象和数字比较\n对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。\n[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true\n\n4. 字符串和数字比较\n字符串和数字进行比较时，字符串转换成数字，二者再比较。\n'1' == 1 // true\n\n5. 字符串和布尔值比较\n字符串和布尔值进行比较时，二者全部转换成数值再比较。\n'1' == true; // true \n\n6. 布尔值和数字比较\n布尔值和数字进行比较时，布尔转换为数字，二者比较。\ntrue == 1 // true\n\n7. other\n来看一个有趣的题\n[] == false;\n![] == false;\n还有一些需要记住的，像：\nundefined == null //true undefined和null 比较返回true，二者和其他值比较返回false\nNumber(null) //0\n```","source":"_posts/==的隐式转换.md","raw":"---\ntitle: ==的隐式转换\ndate: 2019-04-28 09:13:40\ntags:\n---\n\n## 前言\n==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的\n \n```\n     对象\n        \\\n        字符串   布尔值\n          \\      /\n            数值\n\n\n1. 对象和布尔值比较\n对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字\n[] == true;  //false  []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false\n\n2. 对象和字符串比较\n对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。\n[1,2,3] == '1,2,3' // true  [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;\n\n3. 对象和数字比较\n对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。\n[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] => '1' => 1 所以结果为true\n\n4. 字符串和数字比较\n字符串和数字进行比较时，字符串转换成数字，二者再比较。\n'1' == 1 // true\n\n5. 字符串和布尔值比较\n字符串和布尔值进行比较时，二者全部转换成数值再比较。\n'1' == true; // true \n\n6. 布尔值和数字比较\n布尔值和数字进行比较时，布尔转换为数字，二者比较。\ntrue == 1 // true\n\n7. other\n来看一个有趣的题\n[] == false;\n![] == false;\n还有一些需要记住的，像：\nundefined == null //true undefined和null 比较返回true，二者和其他值比较返回false\nNumber(null) //0\n```","slug":"==的隐式转换","published":1,"updated":"2019-08-06T07:19:47.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjzs6ffiv0000qoucpsmr1lmd","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     对象</span><br><span class=\"line\">        \\</span><br><span class=\"line\">        字符串   布尔值</span><br><span class=\"line\">          \\      /</span><br><span class=\"line\">            数值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1. 对象和布尔值比较</span><br><span class=\"line\">对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字</span><br><span class=\"line\">[] == true;  //false  []转换为字符串&apos;&apos;,然后转换为数字0,true转换为数字1，所以为false</span><br><span class=\"line\"></span><br><span class=\"line\">2. 对象和字符串比较</span><br><span class=\"line\">对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。</span><br><span class=\"line\">[1,2,3] == &apos;1,2,3&apos; // true  [1,2,3]转化为&apos;1,2,3&apos;，然后和&apos;1,2,3&apos;， so结果为true;</span><br><span class=\"line\"></span><br><span class=\"line\">3. 对象和数字比较</span><br><span class=\"line\">对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。</span><br><span class=\"line\">[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; &apos;1&apos; =&gt; 1 所以结果为true</span><br><span class=\"line\"></span><br><span class=\"line\">4. 字符串和数字比较</span><br><span class=\"line\">字符串和数字进行比较时，字符串转换成数字，二者再比较。</span><br><span class=\"line\">&apos;1&apos; == 1 // true</span><br><span class=\"line\"></span><br><span class=\"line\">5. 字符串和布尔值比较</span><br><span class=\"line\">字符串和布尔值进行比较时，二者全部转换成数值再比较。</span><br><span class=\"line\">&apos;1&apos; == true; // true </span><br><span class=\"line\"></span><br><span class=\"line\">6. 布尔值和数字比较</span><br><span class=\"line\">布尔值和数字进行比较时，布尔转换为数字，二者比较。</span><br><span class=\"line\">true == 1 // true</span><br><span class=\"line\"></span><br><span class=\"line\">7. other</span><br><span class=\"line\">来看一个有趣的题</span><br><span class=\"line\">[] == false;</span><br><span class=\"line\">![] == false;</span><br><span class=\"line\">还有一些需要记住的，像：</span><br><span class=\"line\">undefined == null //true undefined和null 比较返回true，二者和其他值比较返回false</span><br><span class=\"line\">Number(null) //0</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     对象</span><br><span class=\"line\">        \\</span><br><span class=\"line\">        字符串   布尔值</span><br><span class=\"line\">          \\      /</span><br><span class=\"line\">            数值</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">1. 对象和布尔值比较</span><br><span class=\"line\">对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字</span><br><span class=\"line\">[] == true;  //false  []转换为字符串&apos;&apos;,然后转换为数字0,true转换为数字1，所以为false</span><br><span class=\"line\"></span><br><span class=\"line\">2. 对象和字符串比较</span><br><span class=\"line\">对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。</span><br><span class=\"line\">[1,2,3] == &apos;1,2,3&apos; // true  [1,2,3]转化为&apos;1,2,3&apos;，然后和&apos;1,2,3&apos;， so结果为true;</span><br><span class=\"line\"></span><br><span class=\"line\">3. 对象和数字比较</span><br><span class=\"line\">对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。</span><br><span class=\"line\">[1] == 1;  // true  `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; &apos;1&apos; =&gt; 1 所以结果为true</span><br><span class=\"line\"></span><br><span class=\"line\">4. 字符串和数字比较</span><br><span class=\"line\">字符串和数字进行比较时，字符串转换成数字，二者再比较。</span><br><span class=\"line\">&apos;1&apos; == 1 // true</span><br><span class=\"line\"></span><br><span class=\"line\">5. 字符串和布尔值比较</span><br><span class=\"line\">字符串和布尔值进行比较时，二者全部转换成数值再比较。</span><br><span class=\"line\">&apos;1&apos; == true; // true </span><br><span class=\"line\"></span><br><span class=\"line\">6. 布尔值和数字比较</span><br><span class=\"line\">布尔值和数字进行比较时，布尔转换为数字，二者比较。</span><br><span class=\"line\">true == 1 // true</span><br><span class=\"line\"></span><br><span class=\"line\">7. other</span><br><span class=\"line\">来看一个有趣的题</span><br><span class=\"line\">[] == false;</span><br><span class=\"line\">![] == false;</span><br><span class=\"line\">还有一些需要记住的，像：</span><br><span class=\"line\">undefined == null //true undefined和null 比较返回true，二者和其他值比较返回false</span><br><span class=\"line\">Number(null) //0</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"javascript中的Map","date":"2019-08-26T02:53:41.000Z","_content":"\n\n# 探究javascript Map\n什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。  \nMap 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。  \nECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。\n## 语法\n\n```\nnew Map([iterable])\n```\niterable (可迭代传参)\nIterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n\n## 描述\n\n一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for...of 循环在每次迭代后会返回一个形式为[key，value]的数组。\n\n键的比较是基于 \"SameValueZero\" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 \n\nObjects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：\n\n* 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。\n* Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。\n* 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。\n* Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。\n* Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。\n* Map 在涉及频繁增删键值对的场景下会有些性能优势。\n\n最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;  \nobject获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。\n\n\n## 属性\n\n* Map.length \n\n* get Map[@@species]\n\n* Map.prototype\n\n## Map 实例\n\n### *属性\nMap.prototype.constructor  \n返回一个函数，它创建了实例的原型。默认是Map函数。\n\nMap.prototype.size  \n返回Map对象的键/值对的数量。\n\n### *方法\n\nMap.prototype.clear()\n移除Map对象的所有键/值对 。\n\nMap.prototype.delete(key)\n如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false\n\nMap.prototype.entries()\n返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\nMap.prototype.forEach(callbackFn[, thisArg])\n按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。\n\nMap.prototype.get(key)\n返回键对应的值，如果不存在，则返回undefined。\n\nMap.prototype.has(key)\n返回一个布尔值，表示Map实例是否包含键对应的值。\n\nMap.prototype.keys()\n返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。\n\nMap.prototype.set(key, value)\n设置Map对象中键的值。返回该Map对象。\n\nMap.prototype.values()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。\n\nMap.prototype[@@iterator]()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\n## 实例\n\n### 使用 Map 对象\n```\nvar myMap = new Map();\n \nvar keyObj = {},\n    keyFunc = function () {},\n    keyString = \"a string\";\n \n// 添加键\nmyMap.set(keyString, \"和键'a string'关联的值\");\nmyMap.set(keyObj, \"和键keyObj关联的值\");\nmyMap.set(keyFunc, \"和键keyFunc关联的值\");\n \nmyMap.size; // 3\n \n// 读取值\nmyMap.get(keyString);    // \"和键'a string'关联的值\"\nmyMap.get(keyObj);       // \"和键keyObj关联的值\"\nmyMap.get(keyFunc);      // \"和键keyFunc关联的值\"\n \nmyMap.get(\"a string\");   // \"和键'a string'关联的值\"\n                         // 因为keyString === 'a string'\nmyMap.get({});           // undefined, 因为keyObj !== {}\nmyMap.get(function() {}) // undefined, 因为keyFunc !== function () {}\n```\n### 使用 for..of 方法迭代 Map\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\nfor (var [key, value] of myMap) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"\n\nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"\n\nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"\n\nfor (var [key, value] of myMap.entries()) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### 使用 forEach() 方法迭代 Map\n```\nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n})\n// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### Map 与数组的关系\n```\nvar kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];\n\n// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象\nvar myMap = new Map(kvArray);\n\nmyMap.get(\"key1\"); // 返回值为 \"value1\"\n\n// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组\nconsole.log(Array.from(myMap)); // 输出和kvArray相同的数组\n\n// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组\nconsole.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"]\n```\n### 复制或合并 Maps\n```\nvar original = new Map([\n  [1, 'one']\n]);\n\nvar clone = new Map(original);\n\nconsole.log(clone.get(1)); // one\nconsole.log(original === clone); // false. Useful for shallow comparison\n```\n请记住，数据本身未被克隆。\n\nMap对象间可以进行合并，但是会保持键的唯一性。\n```\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。\n// 展开运算符本质上是将Map对象转换成数组。\nvar merged = new Map([...first, ...second]);\n\nconsole.log(merged.get(1)); // uno\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\nMap对象也能与数组合并：\n```\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。\nvar merged = new Map([...first, ...second, [1, 'eins']]);\n\nconsole.log(merged.get(1)); // eins\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\n\n\n# 以上讲的是Map，那不得不说map( )是什么\n\nECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类  \nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n\n## 语法\n``` \nvar new_array = array.map(function callback(currentValue,index,arr), thisValue)\n```\n## 参数\ncallback 生成新数组元素的函数，使用三个参数：  \n* currentValue callback 数组中正在处理的当前元素。  \n* index可选 callback 数组中正在处理的当前元素的索引。  \n* array可选 callback  map 方法被调用的数组。\n\nthisArg可选 执行 callback 函数时使用的this 值。\n\n## 示例\n```\nvar array1 = [1,3,6];\nconst map1 = array1.map(x => x *2);\nconsole.log(map1);   \n// > Array [2, 6, 12]\n```\n\n```\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n});\n \nconsole.log(map1);\n\n// > Array [undefined, 6, undefined]\n```\n出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了\n```\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n    return x\n});\n \nconsole.log(map1);\n\n// > Array [2, 6, 12]\n```\n可以使用 map 重新格式化数组中的对象\n```\nvar oldArray = [{key: 1, value: 10}, \n                {key: 2, value: 20}, \n                {key: 3, value: 30}];\n\nvar nowArr = oldArray.map(function(obj) { \n   var rObj = {};\n   rObj[obj.key] = obj.value;\n   return rObj;\n});\n\n// nowArr 数组为： [{1: 10}, {2: 20}, {3: 30}], \n\n// oldArray 数组未被修改: \n// [{key: 1, value: 10}, \n//  {key: 2, value: 20}, \n//  {key: 3, value: 30}]\n```\n\n# 用ES5模拟实现ES6中的Map类\n\n与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：\n1.set(key,value):向字典中添加新元素。\n\n2.remove(key):使用键名从字典中移除相应的元素。\n\n3.has(key):如果某个键值存在于字典中，返回true，否则返回false。\n\n4.get(key):通过键名找到指定的值并返回。\n\n5.clear():清空字典。\n\n6.size():返回字典中元素个数。\n\n7.values():将字典所有值以数组形式返回。\n\n8.getItems():返回items变量，代表字典本身。\n\n\n```\nfunction Map() {\n    var items = {};\n    this.has = function(key){    //has方法判断某个键值是否在字典中\n        return key in items;\n    },\n    this.set = function(key,value){    //set方法为字典添加新元素或更新已有元素\n        items[key] = value;\n    },\n    this.remove = function(key){\n        if (this.has(key)) {\n            delete items[key];\n            return true;\n        }\n        return false;\n    },\n    this.get = function(key){\n        return this.has(key)?items[key]:undefined;\n    },\n    this.values = function(){\n        var values = [];\n         //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。\n        for(var k in items){   \n            if (this.hasOwnProperty(k)) {\n                values.push(items[k]);\n            }\n        }\n        return values;\n    },\n    this.clear = function(){\n        items = {};\n    },\n    this.size = function(){\n        return Object.Keys(items).length;\n    },\n    this.getItems = function(){\n        return items;\n    }\n}\n```","source":"_posts/javascript中的Map.md","raw":"---\nlayout: post\ntitle: javascript中的Map\ndate: 2019-08-26 10:53:41\ntags:\n---\n\n\n# 探究javascript Map\n什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。  \nMap 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。  \nECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。\n## 语法\n\n```\nnew Map([iterable])\n```\niterable (可迭代传参)\nIterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, 'one' ],[ 2, 'two' ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。\n\n## 描述\n\n一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for...of 循环在每次迭代后会返回一个形式为[key，value]的数组。\n\n键的比较是基于 \"SameValueZero\" 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 \n\nObjects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：\n\n* 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。\n* Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。\n* 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。\n* Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。\n* Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。\n* Map 在涉及频繁增删键值对的场景下会有些性能优势。\n\n最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;  \nobject获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。\n\n\n## 属性\n\n* Map.length \n\n* get Map[@@species]\n\n* Map.prototype\n\n## Map 实例\n\n### *属性\nMap.prototype.constructor  \n返回一个函数，它创建了实例的原型。默认是Map函数。\n\nMap.prototype.size  \n返回Map对象的键/值对的数量。\n\n### *方法\n\nMap.prototype.clear()\n移除Map对象的所有键/值对 。\n\nMap.prototype.delete(key)\n如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false\n\nMap.prototype.entries()\n返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\nMap.prototype.forEach(callbackFn[, thisArg])\n按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。\n\nMap.prototype.get(key)\n返回键对应的值，如果不存在，则返回undefined。\n\nMap.prototype.has(key)\n返回一个布尔值，表示Map实例是否包含键对应的值。\n\nMap.prototype.keys()\n返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。\n\nMap.prototype.set(key, value)\n设置Map对象中键的值。返回该Map对象。\n\nMap.prototype.values()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。\n\nMap.prototype[@@iterator]()\n返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。\n\n## 实例\n\n### 使用 Map 对象\n```\nvar myMap = new Map();\n \nvar keyObj = {},\n    keyFunc = function () {},\n    keyString = \"a string\";\n \n// 添加键\nmyMap.set(keyString, \"和键'a string'关联的值\");\nmyMap.set(keyObj, \"和键keyObj关联的值\");\nmyMap.set(keyFunc, \"和键keyFunc关联的值\");\n \nmyMap.size; // 3\n \n// 读取值\nmyMap.get(keyString);    // \"和键'a string'关联的值\"\nmyMap.get(keyObj);       // \"和键keyObj关联的值\"\nmyMap.get(keyFunc);      // \"和键keyFunc关联的值\"\n \nmyMap.get(\"a string\");   // \"和键'a string'关联的值\"\n                         // 因为keyString === 'a string'\nmyMap.get({});           // undefined, 因为keyObj !== {}\nmyMap.get(function() {}) // undefined, 因为keyFunc !== function () {}\n```\n### 使用 for..of 方法迭代 Map\n```\nvar myMap = new Map();\nmyMap.set(0, \"zero\");\nmyMap.set(1, \"one\");\nfor (var [key, value] of myMap) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"\n\nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"\n\nfor (var value of myMap.values()) {\n  console.log(value);\n}\n// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"\n\nfor (var [key, value] of myMap.entries()) {\n  console.log(key + \" = \" + value);\n}\n// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### 使用 forEach() 方法迭代 Map\n```\nmyMap.forEach(function(value, key) {\n  console.log(key + \" = \" + value);\n})\n// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\"\n```\n### Map 与数组的关系\n```\nvar kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];\n\n// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象\nvar myMap = new Map(kvArray);\n\nmyMap.get(\"key1\"); // 返回值为 \"value1\"\n\n// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组\nconsole.log(Array.from(myMap)); // 输出和kvArray相同的数组\n\n// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组\nconsole.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"]\n```\n### 复制或合并 Maps\n```\nvar original = new Map([\n  [1, 'one']\n]);\n\nvar clone = new Map(original);\n\nconsole.log(clone.get(1)); // one\nconsole.log(original === clone); // false. Useful for shallow comparison\n```\n请记住，数据本身未被克隆。\n\nMap对象间可以进行合并，但是会保持键的唯一性。\n```\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。\n// 展开运算符本质上是将Map对象转换成数组。\nvar merged = new Map([...first, ...second]);\n\nconsole.log(merged.get(1)); // uno\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\nMap对象也能与数组合并：\n```\nvar first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nvar second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。\nvar merged = new Map([...first, ...second, [1, 'eins']]);\n\nconsole.log(merged.get(1)); // eins\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\n\n\n# 以上讲的是Map，那不得不说map( )是什么\n\nECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类  \nmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。\n\n## 语法\n``` \nvar new_array = array.map(function callback(currentValue,index,arr), thisValue)\n```\n## 参数\ncallback 生成新数组元素的函数，使用三个参数：  \n* currentValue callback 数组中正在处理的当前元素。  \n* index可选 callback 数组中正在处理的当前元素的索引。  \n* array可选 callback  map 方法被调用的数组。\n\nthisArg可选 执行 callback 函数时使用的this 值。\n\n## 示例\n```\nvar array1 = [1,3,6];\nconst map1 = array1.map(x => x *2);\nconsole.log(map1);   \n// > Array [2, 6, 12]\n```\n\n```\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n});\n \nconsole.log(map1);\n\n// > Array [undefined, 6, undefined]\n```\n出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了\n```\nvar array1 = [1, 3,6];\n\nconst map1 = array1.map(x => {\n    if (x == 3) {\n      return x * 2;\n    }\n    return x\n});\n \nconsole.log(map1);\n\n// > Array [2, 6, 12]\n```\n可以使用 map 重新格式化数组中的对象\n```\nvar oldArray = [{key: 1, value: 10}, \n                {key: 2, value: 20}, \n                {key: 3, value: 30}];\n\nvar nowArr = oldArray.map(function(obj) { \n   var rObj = {};\n   rObj[obj.key] = obj.value;\n   return rObj;\n});\n\n// nowArr 数组为： [{1: 10}, {2: 20}, {3: 30}], \n\n// oldArray 数组未被修改: \n// [{key: 1, value: 10}, \n//  {key: 2, value: 20}, \n//  {key: 3, value: 30}]\n```\n\n# 用ES5模拟实现ES6中的Map类\n\n与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：\n1.set(key,value):向字典中添加新元素。\n\n2.remove(key):使用键名从字典中移除相应的元素。\n\n3.has(key):如果某个键值存在于字典中，返回true，否则返回false。\n\n4.get(key):通过键名找到指定的值并返回。\n\n5.clear():清空字典。\n\n6.size():返回字典中元素个数。\n\n7.values():将字典所有值以数组形式返回。\n\n8.getItems():返回items变量，代表字典本身。\n\n\n```\nfunction Map() {\n    var items = {};\n    this.has = function(key){    //has方法判断某个键值是否在字典中\n        return key in items;\n    },\n    this.set = function(key,value){    //set方法为字典添加新元素或更新已有元素\n        items[key] = value;\n    },\n    this.remove = function(key){\n        if (this.has(key)) {\n            delete items[key];\n            return true;\n        }\n        return false;\n    },\n    this.get = function(key){\n        return this.has(key)?items[key]:undefined;\n    },\n    this.values = function(){\n        var values = [];\n         //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。\n        for(var k in items){   \n            if (this.hasOwnProperty(k)) {\n                values.push(items[k]);\n            }\n        }\n        return values;\n    },\n    this.clear = function(){\n        items = {};\n    },\n    this.size = function(){\n        return Object.Keys(items).length;\n    },\n    this.getItems = function(){\n        return items;\n    }\n}\n```","slug":"javascript中的Map","published":1,"updated":"2019-08-26T09:45:39.146Z","_id":"cjzs6ffj10001qoucbl6bu7xz","comments":1,"photos":[],"link":"","content":"<h1 id=\"探究javascript-Map\"><a href=\"#探究javascript-Map\" class=\"headerlink\" title=\"探究javascript Map\"></a>探究javascript Map</h1><p>什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。<br>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。<br>ECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Map([iterable])</span><br></pre></td></tr></table></figure>\n\n<p>iterable (可迭代传参)<br>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>\n<p>键的比较是基于 “SameValueZero” 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 </p>\n<p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>\n<ul>\n<li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li>\n<li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li>\n<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>\n<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li>\n<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>\n<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>\n</ul>\n<p>最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;<br>object获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li><p>Map.length </p>\n</li>\n<li><p>get Map[@@species]</p>\n</li>\n<li><p>Map.prototype</p>\n</li>\n</ul>\n<h2 id=\"Map-实例\"><a href=\"#Map-实例\" class=\"headerlink\" title=\"Map 实例\"></a>Map 实例</h2><h3 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"*属性\"></a>*属性</h3><p>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</p>\n<p>Map.prototype.size<br>返回Map对象的键/值对的数量。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"*方法\"></a>*方法</h3><p>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</p>\n<p>Map.prototype.delete(key)<br>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false</p>\n<p>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<p>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</p>\n<p>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</p>\n<p>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</p>\n<p>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</p>\n<p>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</p>\n<p>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</p>\n<p>Map.prototype<a href>@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"使用-Map-对象\"><a href=\"#使用-Map-对象\" class=\"headerlink\" title=\"使用 Map 对象\"></a>使用 Map 对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap = new Map();</span><br><span class=\"line\"> </span><br><span class=\"line\">var keyObj = &#123;&#125;,</span><br><span class=\"line\">    keyFunc = function () &#123;&#125;,</span><br><span class=\"line\">    keyString = &quot;a string&quot;;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 添加键</span><br><span class=\"line\">myMap.set(keyString, &quot;和键&apos;a string&apos;关联的值&quot;);</span><br><span class=\"line\">myMap.set(keyObj, &quot;和键keyObj关联的值&quot;);</span><br><span class=\"line\">myMap.set(keyFunc, &quot;和键keyFunc关联的值&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.size; // 3</span><br><span class=\"line\"> </span><br><span class=\"line\">// 读取值</span><br><span class=\"line\">myMap.get(keyString);    // &quot;和键&apos;a string&apos;关联的值&quot;</span><br><span class=\"line\">myMap.get(keyObj);       // &quot;和键keyObj关联的值&quot;</span><br><span class=\"line\">myMap.get(keyFunc);      // &quot;和键keyFunc关联的值&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.get(&quot;a string&quot;);   // &quot;和键&apos;a string&apos;关联的值&quot;</span><br><span class=\"line\">                         // 因为keyString === &apos;a string&apos;</span><br><span class=\"line\">myMap.get(&#123;&#125;);           // undefined, 因为keyObj !== &#123;&#125;</span><br><span class=\"line\">myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-for-of-方法迭代-Map\"><a href=\"#使用-for-of-方法迭代-Map\" class=\"headerlink\" title=\"使用 for..of 方法迭代 Map\"></a>使用 for..of 方法迭代 Map</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap = new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\">for (var [key, value] of myMap) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。一个是&quot;0 = zero&quot;另一个是&quot;1 = one&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var [key, value] of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-forEach-方法迭代-Map\"><a href=\"#使用-forEach-方法迭代-Map\" class=\"headerlink\" title=\"使用 forEach() 方法迭代 Map\"></a>使用 forEach() 方法迭代 Map</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 将会显示两个logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-与数组的关系\"><a href=\"#Map-与数组的关系\" class=\"headerlink\" title=\"Map 与数组的关系\"></a>Map 与数组的关系</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span><br><span class=\"line\">var myMap = new Map(kvArray);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(&quot;key1&quot;); // 返回值为 &quot;value1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span><br><span class=\"line\">console.log(Array.from(myMap)); // 输出和kvArray相同的数组</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组</span><br><span class=\"line\">console.log(Array.from(myMap.keys())); // 输出 [&quot;key1&quot;, &quot;key2&quot;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复制或合并-Maps\"><a href=\"#复制或合并-Maps\" class=\"headerlink\" title=\"复制或合并 Maps\"></a>复制或合并 Maps</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var original = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">var clone = new Map(original);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(clone.get(1)); // one</span><br><span class=\"line\">console.log(original === clone); // false. Useful for shallow comparison</span><br></pre></td></tr></table></figure>\n\n<p>请记住，数据本身未被克隆。</p>\n<p>Map对象间可以进行合并，但是会保持键的唯一性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var first = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;],</span><br><span class=\"line\">  [2, &apos;two&apos;],</span><br><span class=\"line\">  [3, &apos;three&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">var second = new Map([</span><br><span class=\"line\">  [1, &apos;uno&apos;],</span><br><span class=\"line\">  [2, &apos;dos&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span><br><span class=\"line\">// 展开运算符本质上是将Map对象转换成数组。</span><br><span class=\"line\">var merged = new Map([...first, ...second]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(merged.get(1)); // uno</span><br><span class=\"line\">console.log(merged.get(2)); // dos</span><br><span class=\"line\">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>\n\n<p>Map对象也能与数组合并：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var first = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;],</span><br><span class=\"line\">  [2, &apos;two&apos;],</span><br><span class=\"line\">  [3, &apos;three&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">var second = new Map([</span><br><span class=\"line\">  [1, &apos;uno&apos;],</span><br><span class=\"line\">  [2, &apos;dos&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。</span><br><span class=\"line\">var merged = new Map([...first, ...second, [1, &apos;eins&apos;]]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(merged.get(1)); // eins</span><br><span class=\"line\">console.log(merged.get(2)); // dos</span><br><span class=\"line\">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"以上讲的是Map，那不得不说map-是什么\"><a href=\"#以上讲的是Map，那不得不说map-是什么\" class=\"headerlink\" title=\"以上讲的是Map，那不得不说map( )是什么\"></a>以上讲的是Map，那不得不说map( )是什么</h1><p>ECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类<br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var new_array = array.map(function callback(currentValue,index,arr), thisValue)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>callback 生成新数组元素的函数，使用三个参数：  </p>\n<ul>\n<li>currentValue callback 数组中正在处理的当前元素。  </li>\n<li>index可选 callback 数组中正在处理的当前元素的索引。  </li>\n<li>array可选 callback  map 方法被调用的数组。</li>\n</ul>\n<p>thisArg可选 执行 callback 函数时使用的this 值。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array1 = [1,3,6];</span><br><span class=\"line\">const map1 = array1.map(x =&gt; x *2);</span><br><span class=\"line\">console.log(map1);   </span><br><span class=\"line\">// &gt; Array [2, 6, 12]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array1 = [1, 3,6];</span><br><span class=\"line\"></span><br><span class=\"line\">const map1 = array1.map(x =&gt; &#123;</span><br><span class=\"line\">    if (x == 3) &#123;</span><br><span class=\"line\">      return x * 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\">// &gt; Array [undefined, 6, undefined]</span><br></pre></td></tr></table></figure>\n\n<p>出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array1 = [1, 3,6];</span><br><span class=\"line\"></span><br><span class=\"line\">const map1 = array1.map(x =&gt; &#123;</span><br><span class=\"line\">    if (x == 3) &#123;</span><br><span class=\"line\">      return x * 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\">// &gt; Array [2, 6, 12]</span><br></pre></td></tr></table></figure>\n\n<p>可以使用 map 重新格式化数组中的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var oldArray = [&#123;key: 1, value: 10&#125;, </span><br><span class=\"line\">                &#123;key: 2, value: 20&#125;, </span><br><span class=\"line\">                &#123;key: 3, value: 30&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">var nowArr = oldArray.map(function(obj) &#123; </span><br><span class=\"line\">   var rObj = &#123;&#125;;</span><br><span class=\"line\">   rObj[obj.key] = obj.value;</span><br><span class=\"line\">   return rObj;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// nowArr 数组为： [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;], </span><br><span class=\"line\"></span><br><span class=\"line\">// oldArray 数组未被修改: </span><br><span class=\"line\">// [&#123;key: 1, value: 10&#125;, </span><br><span class=\"line\">//  &#123;key: 2, value: 20&#125;, </span><br><span class=\"line\">//  &#123;key: 3, value: 30&#125;]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用ES5模拟实现ES6中的Map类\"><a href=\"#用ES5模拟实现ES6中的Map类\" class=\"headerlink\" title=\"用ES5模拟实现ES6中的Map类\"></a>用ES5模拟实现ES6中的Map类</h1><p>与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：<br>1.set(key,value):向字典中添加新元素。</p>\n<p>2.remove(key):使用键名从字典中移除相应的元素。</p>\n<p>3.has(key):如果某个键值存在于字典中，返回true，否则返回false。</p>\n<p>4.get(key):通过键名找到指定的值并返回。</p>\n<p>5.clear():清空字典。</p>\n<p>6.size():返回字典中元素个数。</p>\n<p>7.values():将字典所有值以数组形式返回。</p>\n<p>8.getItems():返回items变量，代表字典本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Map() &#123;</span><br><span class=\"line\">    var items = &#123;&#125;;</span><br><span class=\"line\">    this.has = function(key)&#123;    //has方法判断某个键值是否在字典中</span><br><span class=\"line\">        return key in items;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.set = function(key,value)&#123;    //set方法为字典添加新元素或更新已有元素</span><br><span class=\"line\">        items[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.remove = function(key)&#123;</span><br><span class=\"line\">        if (this.has(key)) &#123;</span><br><span class=\"line\">            delete items[key];</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.get = function(key)&#123;</span><br><span class=\"line\">        return this.has(key)?items[key]:undefined;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.values = function()&#123;</span><br><span class=\"line\">        var values = [];</span><br><span class=\"line\">         //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。</span><br><span class=\"line\">        for(var k in items)&#123;   </span><br><span class=\"line\">            if (this.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">                values.push(items[k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return values;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.clear = function()&#123;</span><br><span class=\"line\">        items = &#123;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.size = function()&#123;</span><br><span class=\"line\">        return Object.Keys(items).length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.getItems = function()&#123;</span><br><span class=\"line\">        return items;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"探究javascript-Map\"><a href=\"#探究javascript-Map\" class=\"headerlink\" title=\"探究javascript Map\"></a>探究javascript Map</h1><p>什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。<br>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。<br>ECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。</p>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Map([iterable])</span><br></pre></td></tr></table></figure>\n\n<p>iterable (可迭代传参)<br>Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。</p>\n<h2 id=\"描述\"><a href=\"#描述\" class=\"headerlink\" title=\"描述\"></a>描述</h2><p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>\n<p>键的比较是基于 “SameValueZero” 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 </p>\n<p>Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择：</p>\n<ul>\n<li>一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。</li>\n<li>Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。</li>\n<li>你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。</li>\n<li>Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li>\n<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。</li>\n<li>Map 在涉及频繁增删键值对的场景下会有些性能优势。</li>\n</ul>\n<p>最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;<br>object获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。</p>\n<h2 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h2><ul>\n<li><p>Map.length </p>\n</li>\n<li><p>get Map[@@species]</p>\n</li>\n<li><p>Map.prototype</p>\n</li>\n</ul>\n<h2 id=\"Map-实例\"><a href=\"#Map-实例\" class=\"headerlink\" title=\"Map 实例\"></a>Map 实例</h2><h3 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"*属性\"></a>*属性</h3><p>Map.prototype.constructor<br>返回一个函数，它创建了实例的原型。默认是Map函数。</p>\n<p>Map.prototype.size<br>返回Map对象的键/值对的数量。</p>\n<h3 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"*方法\"></a>*方法</h3><p>Map.prototype.clear()<br>移除Map对象的所有键/值对 。</p>\n<p>Map.prototype.delete(key)<br>如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false</p>\n<p>Map.prototype.entries()<br>返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<p>Map.prototype.forEach(callbackFn[, thisArg])<br>按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</p>\n<p>Map.prototype.get(key)<br>返回键对应的值，如果不存在，则返回undefined。</p>\n<p>Map.prototype.has(key)<br>返回一个布尔值，表示Map实例是否包含键对应的值。</p>\n<p>Map.prototype.keys()<br>返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。</p>\n<p>Map.prototype.set(key, value)<br>设置Map对象中键的值。返回该Map对象。</p>\n<p>Map.prototype.values()<br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。</p>\n<p>Map.prototype<a href>@@iterator</a><br>返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><h3 id=\"使用-Map-对象\"><a href=\"#使用-Map-对象\" class=\"headerlink\" title=\"使用 Map 对象\"></a>使用 Map 对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap = new Map();</span><br><span class=\"line\"> </span><br><span class=\"line\">var keyObj = &#123;&#125;,</span><br><span class=\"line\">    keyFunc = function () &#123;&#125;,</span><br><span class=\"line\">    keyString = &quot;a string&quot;;</span><br><span class=\"line\"> </span><br><span class=\"line\">// 添加键</span><br><span class=\"line\">myMap.set(keyString, &quot;和键&apos;a string&apos;关联的值&quot;);</span><br><span class=\"line\">myMap.set(keyObj, &quot;和键keyObj关联的值&quot;);</span><br><span class=\"line\">myMap.set(keyFunc, &quot;和键keyFunc关联的值&quot;);</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.size; // 3</span><br><span class=\"line\"> </span><br><span class=\"line\">// 读取值</span><br><span class=\"line\">myMap.get(keyString);    // &quot;和键&apos;a string&apos;关联的值&quot;</span><br><span class=\"line\">myMap.get(keyObj);       // &quot;和键keyObj关联的值&quot;</span><br><span class=\"line\">myMap.get(keyFunc);      // &quot;和键keyFunc关联的值&quot;</span><br><span class=\"line\"> </span><br><span class=\"line\">myMap.get(&quot;a string&quot;);   // &quot;和键&apos;a string&apos;关联的值&quot;</span><br><span class=\"line\">                         // 因为keyString === &apos;a string&apos;</span><br><span class=\"line\">myMap.get(&#123;&#125;);           // undefined, 因为keyObj !== &#123;&#125;</span><br><span class=\"line\">myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-for-of-方法迭代-Map\"><a href=\"#使用-for-of-方法迭代-Map\" class=\"headerlink\" title=\"使用 for..of 方法迭代 Map\"></a>使用 for..of 方法迭代 Map</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var myMap = new Map();</span><br><span class=\"line\">myMap.set(0, &quot;zero&quot;);</span><br><span class=\"line\">myMap.set(1, &quot;one&quot;);</span><br><span class=\"line\">for (var [key, value] of myMap) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。一个是&quot;0 = zero&quot;另一个是&quot;1 = one&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var key of myMap.keys()) &#123;</span><br><span class=\"line\">  console.log(key);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var value of myMap.values()) &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">for (var [key, value] of myMap.entries()) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 将会显示两个log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用-forEach-方法迭代-Map\"><a href=\"#使用-forEach-方法迭代-Map\" class=\"headerlink\" title=\"使用 forEach() 方法迭代 Map\"></a>使用 forEach() 方法迭代 Map</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myMap.forEach(function(value, key) &#123;</span><br><span class=\"line\">  console.log(key + &quot; = &quot; + value);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 将会显示两个logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map-与数组的关系\"><a href=\"#Map-与数组的关系\" class=\"headerlink\" title=\"Map 与数组的关系\"></a>Map 与数组的关系</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象</span><br><span class=\"line\">var myMap = new Map(kvArray);</span><br><span class=\"line\"></span><br><span class=\"line\">myMap.get(&quot;key1&quot;); // 返回值为 &quot;value1&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组</span><br><span class=\"line\">console.log(Array.from(myMap)); // 输出和kvArray相同的数组</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组</span><br><span class=\"line\">console.log(Array.from(myMap.keys())); // 输出 [&quot;key1&quot;, &quot;key2&quot;]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"复制或合并-Maps\"><a href=\"#复制或合并-Maps\" class=\"headerlink\" title=\"复制或合并 Maps\"></a>复制或合并 Maps</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var original = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">var clone = new Map(original);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(clone.get(1)); // one</span><br><span class=\"line\">console.log(original === clone); // false. Useful for shallow comparison</span><br></pre></td></tr></table></figure>\n\n<p>请记住，数据本身未被克隆。</p>\n<p>Map对象间可以进行合并，但是会保持键的唯一性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var first = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;],</span><br><span class=\"line\">  [2, &apos;two&apos;],</span><br><span class=\"line\">  [3, &apos;three&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">var second = new Map([</span><br><span class=\"line\">  [1, &apos;uno&apos;],</span><br><span class=\"line\">  [2, &apos;dos&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。</span><br><span class=\"line\">// 展开运算符本质上是将Map对象转换成数组。</span><br><span class=\"line\">var merged = new Map([...first, ...second]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(merged.get(1)); // uno</span><br><span class=\"line\">console.log(merged.get(2)); // dos</span><br><span class=\"line\">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>\n\n<p>Map对象也能与数组合并：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var first = new Map([</span><br><span class=\"line\">  [1, &apos;one&apos;],</span><br><span class=\"line\">  [2, &apos;two&apos;],</span><br><span class=\"line\">  [3, &apos;three&apos;],</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">var second = new Map([</span><br><span class=\"line\">  [1, &apos;uno&apos;],</span><br><span class=\"line\">  [2, &apos;dos&apos;]</span><br><span class=\"line\">]);</span><br><span class=\"line\"></span><br><span class=\"line\">// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。</span><br><span class=\"line\">var merged = new Map([...first, ...second, [1, &apos;eins&apos;]]);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(merged.get(1)); // eins</span><br><span class=\"line\">console.log(merged.get(2)); // dos</span><br><span class=\"line\">console.log(merged.get(3)); // three</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"以上讲的是Map，那不得不说map-是什么\"><a href=\"#以上讲的是Map，那不得不说map-是什么\" class=\"headerlink\" title=\"以上讲的是Map，那不得不说map( )是什么\"></a>以上讲的是Map，那不得不说map( )是什么</h1><p>ECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类<br>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p>\n<h2 id=\"语法-1\"><a href=\"#语法-1\" class=\"headerlink\" title=\"语法\"></a>语法</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var new_array = array.map(function callback(currentValue,index,arr), thisValue)</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>callback 生成新数组元素的函数，使用三个参数：  </p>\n<ul>\n<li>currentValue callback 数组中正在处理的当前元素。  </li>\n<li>index可选 callback 数组中正在处理的当前元素的索引。  </li>\n<li>array可选 callback  map 方法被调用的数组。</li>\n</ul>\n<p>thisArg可选 执行 callback 函数时使用的this 值。</p>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array1 = [1,3,6];</span><br><span class=\"line\">const map1 = array1.map(x =&gt; x *2);</span><br><span class=\"line\">console.log(map1);   </span><br><span class=\"line\">// &gt; Array [2, 6, 12]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array1 = [1, 3,6];</span><br><span class=\"line\"></span><br><span class=\"line\">const map1 = array1.map(x =&gt; &#123;</span><br><span class=\"line\">    if (x == 3) &#123;</span><br><span class=\"line\">      return x * 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\">// &gt; Array [undefined, 6, undefined]</span><br></pre></td></tr></table></figure>\n\n<p>出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var array1 = [1, 3,6];</span><br><span class=\"line\"></span><br><span class=\"line\">const map1 = array1.map(x =&gt; &#123;</span><br><span class=\"line\">    if (x == 3) &#123;</span><br><span class=\"line\">      return x * 2;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return x</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"> </span><br><span class=\"line\">console.log(map1);</span><br><span class=\"line\"></span><br><span class=\"line\">// &gt; Array [2, 6, 12]</span><br></pre></td></tr></table></figure>\n\n<p>可以使用 map 重新格式化数组中的对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var oldArray = [&#123;key: 1, value: 10&#125;, </span><br><span class=\"line\">                &#123;key: 2, value: 20&#125;, </span><br><span class=\"line\">                &#123;key: 3, value: 30&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\">var nowArr = oldArray.map(function(obj) &#123; </span><br><span class=\"line\">   var rObj = &#123;&#125;;</span><br><span class=\"line\">   rObj[obj.key] = obj.value;</span><br><span class=\"line\">   return rObj;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// nowArr 数组为： [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;], </span><br><span class=\"line\"></span><br><span class=\"line\">// oldArray 数组未被修改: </span><br><span class=\"line\">// [&#123;key: 1, value: 10&#125;, </span><br><span class=\"line\">//  &#123;key: 2, value: 20&#125;, </span><br><span class=\"line\">//  &#123;key: 3, value: 30&#125;]</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"用ES5模拟实现ES6中的Map类\"><a href=\"#用ES5模拟实现ES6中的Map类\" class=\"headerlink\" title=\"用ES5模拟实现ES6中的Map类\"></a>用ES5模拟实现ES6中的Map类</h1><p>与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：<br>1.set(key,value):向字典中添加新元素。</p>\n<p>2.remove(key):使用键名从字典中移除相应的元素。</p>\n<p>3.has(key):如果某个键值存在于字典中，返回true，否则返回false。</p>\n<p>4.get(key):通过键名找到指定的值并返回。</p>\n<p>5.clear():清空字典。</p>\n<p>6.size():返回字典中元素个数。</p>\n<p>7.values():将字典所有值以数组形式返回。</p>\n<p>8.getItems():返回items变量，代表字典本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Map() &#123;</span><br><span class=\"line\">    var items = &#123;&#125;;</span><br><span class=\"line\">    this.has = function(key)&#123;    //has方法判断某个键值是否在字典中</span><br><span class=\"line\">        return key in items;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.set = function(key,value)&#123;    //set方法为字典添加新元素或更新已有元素</span><br><span class=\"line\">        items[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.remove = function(key)&#123;</span><br><span class=\"line\">        if (this.has(key)) &#123;</span><br><span class=\"line\">            delete items[key];</span><br><span class=\"line\">            return true;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.get = function(key)&#123;</span><br><span class=\"line\">        return this.has(key)?items[key]:undefined;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.values = function()&#123;</span><br><span class=\"line\">        var values = [];</span><br><span class=\"line\">         //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。</span><br><span class=\"line\">        for(var k in items)&#123;   </span><br><span class=\"line\">            if (this.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">                values.push(items[k]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return values;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.clear = function()&#123;</span><br><span class=\"line\">        items = &#123;&#125;;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.size = function()&#123;</span><br><span class=\"line\">        return Object.Keys(items).length;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    this.getItems = function()&#123;</span><br><span class=\"line\">        return items;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"layout":"post","title":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","date":"2019-08-06T02:40:30.000Z","_content":"\n\n## 前言\n前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。\n\n## 使用方式\n### cookie：\n **保存cookie值** \n\n ``` javacript\n\n var dataCookie='110';\n    document.cookie = 'token' + \"=\" +dataCookie;\n\n```\n\n**获取指定名称的cookie值**\n``` javacript\n\n  function getCookie(name) { //获取指定名称的cookie值\n// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；\nvar arr = document.cookie.match(new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"));\nif(arr != null) {\n  console.log(arr);\n  return unescape(arr[2]);\n}\nreturn null;\n}\n var cookieData=getCookie('token'); //cookie赋值给变量。\n\n```\n\n### localStorage和sessionStorage：\n**localStorage和sessionStorage所使用的方法是一样的,** 下面以sessionStorage为例子：\n\n``` javacript\n\nvar name='sessionData';\nvar num=120;\nsessionStorage.setItem(name,num);//存储数据\nsessionStorage.setItem('value2',119);\nlet dataAll=sessionStorage.valueOf();//获取全部数据\nconsole.log(dataAll,'获取全部数据');\nvar dataSession=sessionStorage.getItem(name);//获取指定键名数据\nvar dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值\n console.log(dataSession,dataSession2,'获取指定键名数据');\nsessionStorage.removeItem(name); //删除指定键名数据\n  console.log(dataAll,'获取全部数据1');\n sessionStorage.clear();//清空缓存数据：localStorage.clear();\n  console.log(dataAll,'获取全部数据2'); \n\n```\n\n## 三者的异同：\n\n### 生命周期：\n * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\n\n * localStorage：除非被手动清除，否则将会永久保存。\n\n * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。\n\n### 存放数据大小：\n * cookie：4kb左右 \n\n * localStorage和sessionStorage：可以保存5MB的信息\n\n### http请求：\n * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n\n * localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n## 应用场景：\n从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。\n\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。\n\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\n\n## 浏览器的支持情况:\n * localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。\n ![storage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"storage\")\n\n * cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：\n\n ``` javacript\n\nif(navigator.cookieEnabled) {\n  alert(\"你的浏览器支持cookie功能\");//提示浏览器支持cookie  \n} else {\n  alert(\"你的浏览器不支持cookie\");//提示浏览器不支持cookie   }\n\n\n```\n\n### 数据存放处：\n ![dataStorage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"dataStorage\")<center><font color=gray size=2>Cookie、localStorage、sessionStorage数据存放处</font></center>\n\n ### 各浏览器Cookie大小、个数的限制\n  **1. 浏览器允许每个域名所包含的cookie数：**\n\n     Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\n     Firefox每个域名cookie限制为50个。\n\n     Opera每个域名cookie限制为30个。\n\n     Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n     注：“每个域名cookie限制为20个”将不再正确！\n\n  **2. 当很多的cookie被设置，浏览器如何去响应：**\n\n     除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n     最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\n     Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。\n\n  **3. 不同浏览器间cookie总大小也不同：**\n\n     Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\n     Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\n     Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n     注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。\n\n\n## 最后：\n不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。\n","source":"_posts/cookie、localstorage和sessionstorage三者之间的区别以及使用方式.md","raw":"---\nlayout: post\ntitle: cookie、localstorage和sessionstorage三者之间的区别以及使用方式\ndate: 2019-08-06 10:40:30\ntags:\n---\n\n\n## 前言\n前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。\n\n## 使用方式\n### cookie：\n **保存cookie值** \n\n ``` javacript\n\n var dataCookie='110';\n    document.cookie = 'token' + \"=\" +dataCookie;\n\n```\n\n**获取指定名称的cookie值**\n``` javacript\n\n  function getCookie(name) { //获取指定名称的cookie值\n// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；\nvar arr = document.cookie.match(new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"));\nif(arr != null) {\n  console.log(arr);\n  return unescape(arr[2]);\n}\nreturn null;\n}\n var cookieData=getCookie('token'); //cookie赋值给变量。\n\n```\n\n### localStorage和sessionStorage：\n**localStorage和sessionStorage所使用的方法是一样的,** 下面以sessionStorage为例子：\n\n``` javacript\n\nvar name='sessionData';\nvar num=120;\nsessionStorage.setItem(name,num);//存储数据\nsessionStorage.setItem('value2',119);\nlet dataAll=sessionStorage.valueOf();//获取全部数据\nconsole.log(dataAll,'获取全部数据');\nvar dataSession=sessionStorage.getItem(name);//获取指定键名数据\nvar dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值\n console.log(dataSession,dataSession2,'获取指定键名数据');\nsessionStorage.removeItem(name); //删除指定键名数据\n  console.log(dataAll,'获取全部数据1');\n sessionStorage.clear();//清空缓存数据：localStorage.clear();\n  console.log(dataAll,'获取全部数据2'); \n\n```\n\n## 三者的异同：\n\n### 生命周期：\n * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\n\n * localStorage：除非被手动清除，否则将会永久保存。\n\n * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。\n\n### 存放数据大小：\n * cookie：4kb左右 \n\n * localStorage和sessionStorage：可以保存5MB的信息\n\n### http请求：\n * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n\n * localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n## 应用场景：\n从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。\n\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。\n\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\n\n## 浏览器的支持情况:\n * localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。\n ![storage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"storage\")\n\n * cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：\n\n ``` javacript\n\nif(navigator.cookieEnabled) {\n  alert(\"你的浏览器支持cookie功能\");//提示浏览器支持cookie  \n} else {\n  alert(\"你的浏览器不支持cookie\");//提示浏览器不支持cookie   }\n\n\n```\n\n### 数据存放处：\n ![dataStorage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"dataStorage\")<center><font color=gray size=2>Cookie、localStorage、sessionStorage数据存放处</font></center>\n\n ### 各浏览器Cookie大小、个数的限制\n  **1. 浏览器允许每个域名所包含的cookie数：**\n\n     Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\n     Firefox每个域名cookie限制为50个。\n\n     Opera每个域名cookie限制为30个。\n\n     Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n     注：“每个域名cookie限制为20个”将不再正确！\n\n  **2. 当很多的cookie被设置，浏览器如何去响应：**\n\n     除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n     最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\n     Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。\n\n  **3. 不同浏览器间cookie总大小也不同：**\n\n     Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\n     Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\n     Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n     注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。\n\n\n## 最后：\n不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。\n","slug":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","published":1,"updated":"2019-08-06T07:41:58.876Z","comments":1,"photos":[],"link":"","_id":"cjzs6ffj90002qouc5tfq9ior","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"cookie：\"><a href=\"#cookie：\" class=\"headerlink\" title=\"cookie：\"></a>cookie：</h3><p> <strong>保存cookie值</strong> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var dataCookie=&apos;110&apos;;</span><br><span class=\"line\">   document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取指定名称的cookie值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  function getCookie(name) &#123; //获取指定名称的cookie值</span><br><span class=\"line\">// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；</span><br><span class=\"line\">var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class=\"line\">if(arr != null) &#123;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">  return unescape(arr[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage和sessionStorage：\"><a href=\"#localStorage和sessionStorage：\" class=\"headerlink\" title=\"localStorage和sessionStorage：\"></a>localStorage和sessionStorage：</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的,</strong> 下面以sessionStorage为例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var name=&apos;sessionData&apos;;</span><br><span class=\"line\">var num=120;</span><br><span class=\"line\">sessionStorage.setItem(name,num);//存储数据</span><br><span class=\"line\">sessionStorage.setItem(&apos;value2&apos;,119);</span><br><span class=\"line\">let dataAll=sessionStorage.valueOf();//获取全部数据</span><br><span class=\"line\">console.log(dataAll,&apos;获取全部数据&apos;);</span><br><span class=\"line\">var dataSession=sessionStorage.getItem(name);//获取指定键名数据</span><br><span class=\"line\">var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值</span><br><span class=\"line\"> console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);</span><br><span class=\"line\">sessionStorage.removeItem(name); //删除指定键名数据</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据1&apos;);</span><br><span class=\"line\"> sessionStorage.clear();//清空缓存数据：localStorage.clear();</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据2&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三者的异同：\"><a href=\"#三者的异同：\" class=\"headerlink\" title=\"三者的异同：\"></a>三者的异同：</h2><h3 id=\"生命周期：\"><a href=\"#生命周期：\" class=\"headerlink\" title=\"生命周期：\"></a>生命周期：</h3><ul>\n<li><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p>\n</li>\n<li><p>localStorage：除非被手动清除，否则将会永久保存。</p>\n</li>\n<li><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p>\n</li>\n</ul>\n<h3 id=\"存放数据大小：\"><a href=\"#存放数据大小：\" class=\"headerlink\" title=\"存放数据大小：\"></a>存放数据大小：</h3><ul>\n<li><p>cookie：4kb左右 </p>\n</li>\n<li><p>localStorage和sessionStorage：可以保存5MB的信息</p>\n</li>\n</ul>\n<h3 id=\"http请求：\"><a href=\"#http请求：\" class=\"headerlink\" title=\"http请求：\"></a>http请求：</h3><ul>\n<li><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</li>\n<li><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>\n</li>\n</ul>\n<h2 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p>\n<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。</p>\n<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p>\n<h2 id=\"浏览器的支持情况\"><a href=\"#浏览器的支持情况\" class=\"headerlink\" title=\"浏览器的支持情况:\"></a>浏览器的支持情况:</h2><ul>\n<li><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。<br><img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"storage\" title=\"storage\"></p>\n</li>\n<li><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(navigator.cookieEnabled) &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  </span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"数据存放处：\"><a href=\"#数据存放处：\" class=\"headerlink\" title=\"数据存放处：\"></a>数据存放处：</h3><p> <img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"dataStorage\" title=\"dataStorage\"><center><font color=\"gray\" size=\"2\">Cookie、localStorage、sessionStorage数据存放处</font></center></p>\n<h3 id=\"各浏览器Cookie大小、个数的限制\"><a href=\"#各浏览器Cookie大小、个数的限制\" class=\"headerlink\" title=\"各浏览器Cookie大小、个数的限制\"></a>各浏览器Cookie大小、个数的限制</h3><p>  <strong>1. 浏览器允许每个域名所包含的cookie数：</strong></p>\n<pre><code>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\nFirefox每个域名cookie限制为50个。\n\nOpera每个域名cookie限制为30个。\n\nSafari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n注：“每个域名cookie限制为20个”将不再正确！</code></pre><p>  <strong>2. 当很多的cookie被设置，浏览器如何去响应：</strong></p>\n<pre><code>除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\nFirefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</code></pre><p>  <strong>3. 不同浏览器间cookie总大小也不同：</strong></p>\n<pre><code>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\nOpera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\nInternet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</code></pre><h2 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h2><p>不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"cookie：\"><a href=\"#cookie：\" class=\"headerlink\" title=\"cookie：\"></a>cookie：</h3><p> <strong>保存cookie值</strong> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var dataCookie=&apos;110&apos;;</span><br><span class=\"line\">   document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取指定名称的cookie值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  function getCookie(name) &#123; //获取指定名称的cookie值</span><br><span class=\"line\">// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；</span><br><span class=\"line\">var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class=\"line\">if(arr != null) &#123;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">  return unescape(arr[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage和sessionStorage：\"><a href=\"#localStorage和sessionStorage：\" class=\"headerlink\" title=\"localStorage和sessionStorage：\"></a>localStorage和sessionStorage：</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的,</strong> 下面以sessionStorage为例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var name=&apos;sessionData&apos;;</span><br><span class=\"line\">var num=120;</span><br><span class=\"line\">sessionStorage.setItem(name,num);//存储数据</span><br><span class=\"line\">sessionStorage.setItem(&apos;value2&apos;,119);</span><br><span class=\"line\">let dataAll=sessionStorage.valueOf();//获取全部数据</span><br><span class=\"line\">console.log(dataAll,&apos;获取全部数据&apos;);</span><br><span class=\"line\">var dataSession=sessionStorage.getItem(name);//获取指定键名数据</span><br><span class=\"line\">var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值</span><br><span class=\"line\"> console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);</span><br><span class=\"line\">sessionStorage.removeItem(name); //删除指定键名数据</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据1&apos;);</span><br><span class=\"line\"> sessionStorage.clear();//清空缓存数据：localStorage.clear();</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据2&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三者的异同：\"><a href=\"#三者的异同：\" class=\"headerlink\" title=\"三者的异同：\"></a>三者的异同：</h2><h3 id=\"生命周期：\"><a href=\"#生命周期：\" class=\"headerlink\" title=\"生命周期：\"></a>生命周期：</h3><ul>\n<li><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p>\n</li>\n<li><p>localStorage：除非被手动清除，否则将会永久保存。</p>\n</li>\n<li><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p>\n</li>\n</ul>\n<h3 id=\"存放数据大小：\"><a href=\"#存放数据大小：\" class=\"headerlink\" title=\"存放数据大小：\"></a>存放数据大小：</h3><ul>\n<li><p>cookie：4kb左右 </p>\n</li>\n<li><p>localStorage和sessionStorage：可以保存5MB的信息</p>\n</li>\n</ul>\n<h3 id=\"http请求：\"><a href=\"#http请求：\" class=\"headerlink\" title=\"http请求：\"></a>http请求：</h3><ul>\n<li><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</li>\n<li><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>\n</li>\n</ul>\n<h2 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p>\n<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。</p>\n<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p>\n<h2 id=\"浏览器的支持情况\"><a href=\"#浏览器的支持情况\" class=\"headerlink\" title=\"浏览器的支持情况:\"></a>浏览器的支持情况:</h2><ul>\n<li><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。<br><img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"storage\" title=\"storage\"></p>\n</li>\n<li><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(navigator.cookieEnabled) &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  </span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"数据存放处：\"><a href=\"#数据存放处：\" class=\"headerlink\" title=\"数据存放处：\"></a>数据存放处：</h3><p> <img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"dataStorage\" title=\"dataStorage\"><center><font color=\"gray\" size=\"2\">Cookie、localStorage、sessionStorage数据存放处</font></center></p>\n<h3 id=\"各浏览器Cookie大小、个数的限制\"><a href=\"#各浏览器Cookie大小、个数的限制\" class=\"headerlink\" title=\"各浏览器Cookie大小、个数的限制\"></a>各浏览器Cookie大小、个数的限制</h3><p>  <strong>1. 浏览器允许每个域名所包含的cookie数：</strong></p>\n<pre><code>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\nFirefox每个域名cookie限制为50个。\n\nOpera每个域名cookie限制为30个。\n\nSafari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n注：“每个域名cookie限制为20个”将不再正确！</code></pre><p>  <strong>2. 当很多的cookie被设置，浏览器如何去响应：</strong></p>\n<pre><code>除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\nFirefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</code></pre><p>  <strong>3. 不同浏览器间cookie总大小也不同：</strong></p>\n<pre><code>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\nOpera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\nInternet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</code></pre><h2 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h2><p>不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p>\n"},{"layout":"post","title":"javascript垃圾回收机制","date":"2019-07-01T02:53:41.000Z","_content":"\n## 前言\n\n其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n};\n\nsetInterval(replaceThing,1000)\n\n```\n最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:\n1. 识别哪些对象需要被回收。\n2. 回收/重复使用需要被回收对象的内存。\n3. 压缩/整理内存(有些可能没有)\n\n而常见的识别对象是否需要回收的机制有下面几种:\n* 引用计数 (Python)\n* 逃逸分析 (Java)\n* Tracing/Reachable 追踪分析 (javascript)\n\n今天就主要看一下V8中GC的具体实现方式\n\n## Tracing/Reachable 追踪分析\nGC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。\n在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。\n\n\n## The Generational Hypothesis\nGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。\n这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。\n\n### Scavenger\nV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。\n\n![第一次GC](http://img.pandihai.com/03.svg)\n\n\n第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。\n\n![第二次GC](http://img.pandihai.com/04.svg)<center><font color=gray size=2>第二次GC</font></center>\n\n\n在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。\n\n#### Parallel\nParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。\n\n![Scavenger平行调度](http://img.pandihai.com/05.svg)<center><font color=gray size=2>Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center>\n\n### Major GC\nMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。\n\n#### Concurrent\nConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。\n\n![Major GC同步调度](http://img.pandihai.com/09.svg)<center><font color=gray size=2>Major GC同步调度</font></center>\n\n\n### 什么时候会执行GC\n在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。\n\n我们可以通过手动设置来设置新生代和老代的space大小:\n```js\n    node --max-old-space-size=1700 index.js\n    node --max-new-space-size=1024 index.js\n```\n\n\n#### 空闲时GC\n虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过[requestIdleCallback](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解[React 16 fiber的实现](https://www.youtube.com/watch?v=ZCuYPiUIONs))。\n\n![空闲时GC](http://img.pandihai.com/10.svg)<center><font color=gray size=2>利用主线程空闲时间进行GC</font></center>\n\n#### Incremental\n那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。\n\n![Incremental](http://img.pandihai.com/06.svg)<center><font color=gray size=2>将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center>\n\n### 总结\n不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。\n\n最后的最后将之前的内存泄漏代码一步步的推演:\n\n1. 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。\n2. 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,**闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的**,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。**另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量**,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。\n3. 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing->longStr(reachable),theThing->someMethod(reachable),execution stack -> setInterval -> closure -> originThing(reachable)。   \n所有标记完成。此时:\n```js\n          from-space                                to-space\n\n    theThing         (reachable)                theThing\n    replaceThing     (reachable)                replaceThing\n    unused                                      originThing\n    originThing      (reachable)       =>       longStr  \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n4. 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2\n5. 第二次GC开始\n\n```js\n          from-space                                to-space                           old-space\n\n    theThing         (reachable)                theThing                             originThing -> theThing\n    replaceThing     (reachable)                replaceThing                         theThing -> longStr\n    unused                                      originThing                          theThing -> someMethod\n    originThing      (reachable)       =>       longStr                    =>        someMethod -> originThing(closure)        \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n6. 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法\n\n```js\n         old-space\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n```\n\n#### 结论 \n主要导致内存泄漏的原因是\n\n![闭包是在声明的时候被创建的](http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png)<center><font color=gray size=2>闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center>\n\n然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。\n\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n\n  originalThing = null;    //手动释放局部作用域中的变量\n};\n\nsetInterval(replaceThing,1000)\n\n```\n","source":"_posts/javascript垃圾回收机制.md","raw":"---\nlayout: post\ntitle: javascript垃圾回收机制\ndate: 2019-07-01 10:53:41\ntags:\n---\n\n## 前言\n\n其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n};\n\nsetInterval(replaceThing,1000)\n\n```\n最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:\n1. 识别哪些对象需要被回收。\n2. 回收/重复使用需要被回收对象的内存。\n3. 压缩/整理内存(有些可能没有)\n\n而常见的识别对象是否需要回收的机制有下面几种:\n* 引用计数 (Python)\n* 逃逸分析 (Java)\n* Tracing/Reachable 追踪分析 (javascript)\n\n今天就主要看一下V8中GC的具体实现方式\n\n## Tracing/Reachable 追踪分析\nGC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。\n在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。\n\n\n## The Generational Hypothesis\nGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。\n这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。\n\n### Scavenger\nV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。\n\n![第一次GC](http://img.pandihai.com/03.svg)\n\n\n第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。\n\n![第二次GC](http://img.pandihai.com/04.svg)<center><font color=gray size=2>第二次GC</font></center>\n\n\n在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。\n\n#### Parallel\nParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。\n\n![Scavenger平行调度](http://img.pandihai.com/05.svg)<center><font color=gray size=2>Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center>\n\n### Major GC\nMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。\n\n#### Concurrent\nConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。\n\n![Major GC同步调度](http://img.pandihai.com/09.svg)<center><font color=gray size=2>Major GC同步调度</font></center>\n\n\n### 什么时候会执行GC\n在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。\n\n我们可以通过手动设置来设置新生代和老代的space大小:\n```js\n    node --max-old-space-size=1700 index.js\n    node --max-new-space-size=1024 index.js\n```\n\n\n#### 空闲时GC\n虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过[requestIdleCallback](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解[React 16 fiber的实现](https://www.youtube.com/watch?v=ZCuYPiUIONs))。\n\n![空闲时GC](http://img.pandihai.com/10.svg)<center><font color=gray size=2>利用主线程空闲时间进行GC</font></center>\n\n#### Incremental\n那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。\n\n![Incremental](http://img.pandihai.com/06.svg)<center><font color=gray size=2>将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center>\n\n### 总结\n不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。\n\n最后的最后将之前的内存泄漏代码一步步的推演:\n\n1. 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。\n2. 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,**闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的**,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。**另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量**,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。\n3. 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing->longStr(reachable),theThing->someMethod(reachable),execution stack -> setInterval -> closure -> originThing(reachable)。   \n所有标记完成。此时:\n```js\n          from-space                                to-space\n\n    theThing         (reachable)                theThing\n    replaceThing     (reachable)                replaceThing\n    unused                                      originThing\n    originThing      (reachable)       =>       longStr  \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n4. 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2\n5. 第二次GC开始\n\n```js\n          from-space                                to-space                           old-space\n\n    theThing         (reachable)                theThing                             originThing -> theThing\n    replaceThing     (reachable)                replaceThing                         theThing -> longStr\n    unused                                      originThing                          theThing -> someMethod\n    originThing      (reachable)       =>       longStr                    =>        someMethod -> originThing(closure)        \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n6. 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法\n\n```js\n         old-space\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n```\n\n#### 结论 \n主要导致内存泄漏的原因是\n\n![闭包是在声明的时候被创建的](http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png)<center><font color=gray size=2>闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center>\n\n然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。\n\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n\n  originalThing = null;    //手动释放局部作用域中的变量\n};\n\nsetInterval(replaceThing,1000)\n\n```\n","slug":"javascript垃圾回收机制","published":1,"updated":"2019-08-06T07:41:58.883Z","comments":1,"photos":[],"link":"","_id":"cjzs6ffjd0003qouc33n6am55","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>\n<ol>\n<li>识别哪些对象需要被回收。</li>\n<li>回收/重复使用需要被回收对象的内存。</li>\n<li>压缩/整理内存(有些可能没有)</li>\n</ol>\n<p>而常见的识别对象是否需要回收的机制有下面几种:</p>\n<ul>\n<li>引用计数 (Python)</li>\n<li>逃逸分析 (Java)</li>\n<li>Tracing/Reachable 追踪分析 (javascript)</li>\n</ul>\n<p>今天就主要看一下V8中GC的具体实现方式</p>\n<h2 id=\"Tracing-Reachable-追踪分析\"><a href=\"#Tracing-Reachable-追踪分析\" class=\"headerlink\" title=\"Tracing/Reachable 追踪分析\"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>\n<h2 id=\"The-Generational-Hypothesis\"><a href=\"#The-Generational-Hypothesis\" class=\"headerlink\" title=\"The Generational Hypothesis\"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>\n<h3 id=\"Scavenger\"><a href=\"#Scavenger\" class=\"headerlink\" title=\"Scavenger\"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>\n<p><img src=\"http://img.pandihai.com/03.svg\" alt=\"第一次GC\"></p>\n<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>\n<p><img src=\"http://img.pandihai.com/04.svg\" alt=\"第二次GC\"><center><font color=\"gray\" size=\"2\">第二次GC</font></center></p>\n<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>\n<h4 id=\"Parallel\"><a href=\"#Parallel\" class=\"headerlink\" title=\"Parallel\"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>\n<p><img src=\"http://img.pandihai.com/05.svg\" alt=\"Scavenger平行调度\"><center><font color=\"gray\" size=\"2\">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>\n<h4 id=\"Concurrent\"><a href=\"#Concurrent\" class=\"headerlink\" title=\"Concurrent\"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>\n<p><img src=\"http://img.pandihai.com/09.svg\" alt=\"Major GC同步调度\"><center><font color=\"gray\" size=\"2\">Major GC同步调度</font></center></p>\n<h3 id=\"什么时候会执行GC\"><a href=\"#什么时候会执行GC\" class=\"headerlink\" title=\"什么时候会执行GC\"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>\n<p>我们可以通过手动设置来设置新生代和老代的space大小:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-old-space-size=<span class=\"number\">1700</span> index.js</span><br><span class=\"line\">node --max-<span class=\"keyword\">new</span>-space-size=<span class=\"number\">1024</span> index.js</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"空闲时GC\"><a href=\"#空闲时GC\" class=\"headerlink\" title=\"空闲时GC\"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"noopener\">React 16 fiber的实现</a>)。</p>\n<p><img src=\"http://img.pandihai.com/10.svg\" alt=\"空闲时GC\"><center><font color=\"gray\" size=\"2\">利用主线程空闲时间进行GC</font></center></p>\n<h4 id=\"Incremental\"><a href=\"#Incremental\" class=\"headerlink\" title=\"Incremental\"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>\n<p><img src=\"http://img.pandihai.com/06.svg\" alt=\"Incremental\"><center><font color=\"gray\" size=\"2\">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>\n<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>\n<ol>\n<li><p>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</p>\n</li>\n<li><p>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</p>\n</li>\n<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing</span><br><span class=\"line\">unused                                      originThing</span><br><span class=\"line\">originThing      (reachable)       =&gt;       longStr  </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>\n</li>\n<li><p>第二次GC开始</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space                           old-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class=\"line\">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class=\"line\">originThing      (reachable)       =&gt;       <span class=\"function\"><span class=\"params\">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     old-space</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>主要导致内存泄漏的原因是</p>\n<p><img src=\"http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png\" alt=\"闭包是在声明的时候被创建的\"><center><font color=\"gray\" size=\"2\">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>\n<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>\n<ol>\n<li>识别哪些对象需要被回收。</li>\n<li>回收/重复使用需要被回收对象的内存。</li>\n<li>压缩/整理内存(有些可能没有)</li>\n</ol>\n<p>而常见的识别对象是否需要回收的机制有下面几种:</p>\n<ul>\n<li>引用计数 (Python)</li>\n<li>逃逸分析 (Java)</li>\n<li>Tracing/Reachable 追踪分析 (javascript)</li>\n</ul>\n<p>今天就主要看一下V8中GC的具体实现方式</p>\n<h2 id=\"Tracing-Reachable-追踪分析\"><a href=\"#Tracing-Reachable-追踪分析\" class=\"headerlink\" title=\"Tracing/Reachable 追踪分析\"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>\n<h2 id=\"The-Generational-Hypothesis\"><a href=\"#The-Generational-Hypothesis\" class=\"headerlink\" title=\"The Generational Hypothesis\"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>\n<h3 id=\"Scavenger\"><a href=\"#Scavenger\" class=\"headerlink\" title=\"Scavenger\"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>\n<p><img src=\"http://img.pandihai.com/03.svg\" alt=\"第一次GC\"></p>\n<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>\n<p><img src=\"http://img.pandihai.com/04.svg\" alt=\"第二次GC\"><center><font color=\"gray\" size=\"2\">第二次GC</font></center></p>\n<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>\n<h4 id=\"Parallel\"><a href=\"#Parallel\" class=\"headerlink\" title=\"Parallel\"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>\n<p><img src=\"http://img.pandihai.com/05.svg\" alt=\"Scavenger平行调度\"><center><font color=\"gray\" size=\"2\">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>\n<h4 id=\"Concurrent\"><a href=\"#Concurrent\" class=\"headerlink\" title=\"Concurrent\"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>\n<p><img src=\"http://img.pandihai.com/09.svg\" alt=\"Major GC同步调度\"><center><font color=\"gray\" size=\"2\">Major GC同步调度</font></center></p>\n<h3 id=\"什么时候会执行GC\"><a href=\"#什么时候会执行GC\" class=\"headerlink\" title=\"什么时候会执行GC\"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>\n<p>我们可以通过手动设置来设置新生代和老代的space大小:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-old-space-size=<span class=\"number\">1700</span> index.js</span><br><span class=\"line\">node --max-<span class=\"keyword\">new</span>-space-size=<span class=\"number\">1024</span> index.js</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"空闲时GC\"><a href=\"#空闲时GC\" class=\"headerlink\" title=\"空闲时GC\"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"noopener\">React 16 fiber的实现</a>)。</p>\n<p><img src=\"http://img.pandihai.com/10.svg\" alt=\"空闲时GC\"><center><font color=\"gray\" size=\"2\">利用主线程空闲时间进行GC</font></center></p>\n<h4 id=\"Incremental\"><a href=\"#Incremental\" class=\"headerlink\" title=\"Incremental\"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>\n<p><img src=\"http://img.pandihai.com/06.svg\" alt=\"Incremental\"><center><font color=\"gray\" size=\"2\">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>\n<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>\n<ol>\n<li><p>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</p>\n</li>\n<li><p>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</p>\n</li>\n<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing</span><br><span class=\"line\">unused                                      originThing</span><br><span class=\"line\">originThing      (reachable)       =&gt;       longStr  </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>\n</li>\n<li><p>第二次GC开始</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space                           old-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class=\"line\">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class=\"line\">originThing      (reachable)       =&gt;       <span class=\"function\"><span class=\"params\">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     old-space</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>主要导致内存泄漏的原因是</p>\n<p><img src=\"http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png\" alt=\"闭包是在声明的时候被创建的\"><center><font color=\"gray\" size=\"2\">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>\n<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}