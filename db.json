{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/cleanBlog/source/css/article.styl","path":"css/article.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/mixins.styl","path":"css/mixins.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/css/variables.styl","path":"css/variables.styl","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/img/about-bg.jpg","path":"img/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/img/home-bg.jpg","path":"img/home-bg.jpg","modified":0,"renderable":1},{"_id":"themes/cleanBlog/source/img/contact-bg.jpg","path":"img/contact-bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/cleanBlog/README.md","hash":"779e999931169acdbabf43ab0e70471e8631583a","modified":1565058488931},{"_id":"themes/cleanBlog/LICENSE","hash":"34ac5e147727699d1bbc346b014f2e0bdfbb0947","modified":1565058488930},{"_id":"themes/cleanBlog/_config.yml","hash":"85f70d953d66d9c8a840f672d842c25a5697e679","modified":1565058488932},{"_id":"source/_posts/javascript垃圾回收机制.md","hash":"b8fb93ae09e31dd51c210e40dd4989542594a0c4","modified":1565072334576},{"_id":"source/_posts/三者之间的区别以及使用方式.md","hash":"3198b88fa96b829b2a718403233dca311c252ff4","modified":1565073242540},{"_id":"themes/cleanBlog/languages/de.yml","hash":"02a98ba2b93e30a00ae7979fbe90b767a27290f0","modified":1565058488933},{"_id":"themes/cleanBlog/languages/default.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1565058488936},{"_id":"themes/cleanBlog/languages/en.yml","hash":"3cd0873b310cbf2fe022ee18d55a6113b347ea09","modified":1565058488937},{"_id":"themes/cleanBlog/languages/es.yml","hash":"fb089145368422ac47da9eb00fed05b15c904aa2","modified":1565058488937},{"_id":"themes/cleanBlog/languages/fr.yml","hash":"10e3529b8492d7a7601d5b35b44d8fc9e8ea8d1b","modified":1565058488938},{"_id":"themes/cleanBlog/languages/ko.yml","hash":"b52f84a08d877b545751441c45a1961105eb4372","modified":1565058488939},{"_id":"themes/cleanBlog/languages/no.yml","hash":"5ce3a1043ff85cecf83f3b5b0cdad2df44fa0192","modified":1565058488939},{"_id":"themes/cleanBlog/languages/pl.yml","hash":"6dc5d1b2aa75ae4c527089a770f43bafb91d80f4","modified":1565058488940},{"_id":"themes/cleanBlog/languages/pt.yml","hash":"6a31d548092af8af9f25d859063b0589c23ce13a","modified":1565058488941},{"_id":"themes/cleanBlog/languages/ru.yml","hash":"2cfaf93704ea4ac3f374c69bab89ca31916faa33","modified":1565058488941},{"_id":"themes/cleanBlog/languages/zh-CN.yml","hash":"6d712d9eb6ba12213dcd76b532cd86e9da83cfa3","modified":1565058488942},{"_id":"themes/cleanBlog/languages/zh-TW.yml","hash":"45c84384a05fdb7e32a3e2d498ea180be7dccfa9","modified":1565058488942},{"_id":"themes/cleanBlog/layout/archive.ejs","hash":"c3aa4a76ee8b59b0e12ddbe951a9852176058eac","modified":1565058488962},{"_id":"themes/cleanBlog/layout/index.ejs","hash":"7dfdd9347f14b782d305a70f9ddb696ee1bb3864","modified":1565058488963},{"_id":"themes/cleanBlog/layout/layout.ejs","hash":"acc791dc4346c135ce4cac3cdeba6f96708115e5","modified":1565058488964},{"_id":"themes/cleanBlog/layout/page.ejs","hash":"b585761947e289f0e37380780cfdebee0674c378","modified":1565058488964},{"_id":"themes/cleanBlog/layout/post.ejs","hash":"38382e9bbeb6b8d2eafbd53fff2984111f524c1a","modified":1565058488965},{"_id":"themes/cleanBlog/layout/_partial/after-footer.ejs","hash":"f199b6e0039a7e9f840b8fbb9971fbd673ba5ce3","modified":1565058488944},{"_id":"themes/cleanBlog/layout/_partial/article-archive.ejs","hash":"75b9b24c226eda4884752a868177b590d3e8b06f","modified":1565058488944},{"_id":"themes/cleanBlog/layout/_partial/article-categories.ejs","hash":"b494e4a50f63d66e545da449af18a7198a057bd6","modified":1565058488945},{"_id":"themes/cleanBlog/layout/_partial/article-full.ejs","hash":"b71cc571f43127bc0307557a201b99e7eb015fc7","modified":1565058488946},{"_id":"themes/cleanBlog/layout/_partial/article-index.ejs","hash":"ad112adf312337c60d436fdd127e948fe81b3dd1","modified":1565058488946},{"_id":"themes/cleanBlog/layout/_partial/article-tags.ejs","hash":"12524df0c1ce5136a8f88cea2fe550f9e1b47b19","modified":1565058488947},{"_id":"themes/cleanBlog/layout/_partial/comments.ejs","hash":"5cafed11b6cfbf22e83674676c0edc6c4420cc0d","modified":1565058488957},{"_id":"themes/cleanBlog/layout/_partial/footer.ejs","hash":"c2315e0d51296b5ab3746a100530d083274da2b6","modified":1565058488958},{"_id":"themes/cleanBlog/layout/_partial/gallery.ejs","hash":"15e9562d0f6146e25e22856693d1312cd3ade4af","modified":1565058488958},{"_id":"themes/cleanBlog/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1565058488959},{"_id":"themes/cleanBlog/layout/_partial/head.ejs","hash":"d453acf2b17665be69f209d85505e341775c2b55","modified":1565058488960},{"_id":"themes/cleanBlog/layout/_partial/menu.ejs","hash":"3c51a2a2f950ab2ca80f10d3d3941d5d8cd08ec7","modified":1565058488960},{"_id":"themes/cleanBlog/layout/_partial/pagination.ejs","hash":"cd61e4dbbf6020ad094c8e66ec06e8c38ebcd122","modified":1565058488961},{"_id":"themes/cleanBlog/layout/_partial/tag-category-index.ejs","hash":"008b4ed0b6fd6dc81bc0655ccc46e43eb310706b","modified":1565058488962},{"_id":"themes/cleanBlog/source/css/article.styl","hash":"768418ecaa2ff17f6fa81d72096627e05579fe93","modified":1565058488966},{"_id":"themes/cleanBlog/source/css/base.styl","hash":"447a0dedad485b5d79f8ab5435bd43a1c8f9ba9f","modified":1565058488967},{"_id":"themes/cleanBlog/source/css/mixins.styl","hash":"cf700a1c1c62b17d35a8f7500bf1a32d9bc6ab6a","modified":1565058488967},{"_id":"themes/cleanBlog/source/css/style.styl","hash":"7200d572751c1f5888b3d0df25bf503a3f31ca2d","modified":1565058488968},{"_id":"themes/cleanBlog/source/css/variables.styl","hash":"06e16f64020cbddf2c2c49ef45f940141a1b2ada","modified":1565058488969},{"_id":"themes/cleanBlog/source/img/about-bg.jpg","hash":"d39126a6456f2bac0169d1779304725f179c9900","modified":1565058488970},{"_id":"themes/cleanBlog/source/img/home-bg.jpg","hash":"990f6f9dd0ecb5348bfcc47305553d58c0d8f326","modified":1565058488974},{"_id":"themes/cleanBlog/source/img/contact-bg.jpg","hash":"6af63305c923899017e727b5ca968a2703bc08cf","modified":1565058488972}],"Category":[],"Data":[],"Page":[],"Post":[{"layout":"cookie、localstorage和sessionstorage","title":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","date":"2019-08-06T02:40:30.000Z","_content":"\n\n## 前言\n前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。\n\n## 使用方式\n### cookie：\n **保存cookie值** \n\n ``` javacript\n\n var dataCookie='110';\n    document.cookie = 'token' + \"=\" +dataCookie;\n\n```\n\n**获取指定名称的cookie值**\n``` javacript\n\n  function getCookie(name) { //获取指定名称的cookie值\n// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；\nvar arr = document.cookie.match(new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"));\nif(arr != null) {\n  console.log(arr);\n  return unescape(arr[2]);\n}\nreturn null;\n}\n var cookieData=getCookie('token'); //cookie赋值给变量。\n\n```\n\n### localStorage和sessionStorage：\n**localStorage和sessionStorage所使用的方法是一样的,** 下面以sessionStorage为例子：\n\n``` javacript\n\nvar name='sessionData';\nvar num=120;\nsessionStorage.setItem(name,num);//存储数据\nsessionStorage.setItem('value2',119);\nlet dataAll=sessionStorage.valueOf();//获取全部数据\nconsole.log(dataAll,'获取全部数据');\nvar dataSession=sessionStorage.getItem(name);//获取指定键名数据\nvar dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值\n console.log(dataSession,dataSession2,'获取指定键名数据');\nsessionStorage.removeItem(name); //删除指定键名数据\n  console.log(dataAll,'获取全部数据1');\n sessionStorage.clear();//清空缓存数据：localStorage.clear();\n  console.log(dataAll,'获取全部数据2'); \n\n```\n\n## 三者的异同：\n\n### 生命周期：\n * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\n\n * localStorage：除非被手动清除，否则将会永久保存。\n\n * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。\n\n### 存放数据大小：\n * cookie：4kb左右 \n\n * localStorage和sessionStorage：可以保存5MB的信息\n\n### http请求：\n * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n\n * localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n## 应用场景：\n从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。\n\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。\n\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\n\n## 浏览器的支持情况:\n * localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。\n ![storage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"storage\")\n\n * cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：\n\n ``` javacript\n\nif(navigator.cookieEnabled) {\n  alert(\"你的浏览器支持cookie功能\");//提示浏览器支持cookie  \n} else {\n  alert(\"你的浏览器不支持cookie\");//提示浏览器不支持cookie   }\n\n\n```\n\n### 数据存放处：\n ![dataStorage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"dataStorage\")<center><font color=gray size=2>Cookie、localStorage、sessionStorage数据存放处</font></center>\n\n ### 各浏览器Cookie大小、个数的限制\n  **1. 浏览器允许每个域名所包含的cookie数：**\n\n     Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\n     Firefox每个域名cookie限制为50个。\n\n     Opera每个域名cookie限制为30个。\n\n     Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n     注：“每个域名cookie限制为20个”将不再正确！\n\n  **2. 当很多的cookie被设置，浏览器如何去响应：**\n\n     除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n     最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\n     Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。\n\n  **3. 不同浏览器间cookie总大小也不同：**\n\n     Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\n     Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\n     Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n     注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。\n\n\n## 最后：\n不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。\n","source":"_posts/三者之间的区别以及使用方式.md","raw":"---\nlayout: cookie、localstorage和sessionstorage\ntitle: cookie、localstorage和sessionstorage三者之间的区别以及使用方式\ndate: 2019-08-06 10:40:30\ntags:\n---\n\n\n## 前言\n前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。\n\n## 使用方式\n### cookie：\n **保存cookie值** \n\n ``` javacript\n\n var dataCookie='110';\n    document.cookie = 'token' + \"=\" +dataCookie;\n\n```\n\n**获取指定名称的cookie值**\n``` javacript\n\n  function getCookie(name) { //获取指定名称的cookie值\n// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；\nvar arr = document.cookie.match(new RegExp(\"(^| )\"+name+\"=([^;]*)(;|$)\"));\nif(arr != null) {\n  console.log(arr);\n  return unescape(arr[2]);\n}\nreturn null;\n}\n var cookieData=getCookie('token'); //cookie赋值给变量。\n\n```\n\n### localStorage和sessionStorage：\n**localStorage和sessionStorage所使用的方法是一样的,** 下面以sessionStorage为例子：\n\n``` javacript\n\nvar name='sessionData';\nvar num=120;\nsessionStorage.setItem(name,num);//存储数据\nsessionStorage.setItem('value2',119);\nlet dataAll=sessionStorage.valueOf();//获取全部数据\nconsole.log(dataAll,'获取全部数据');\nvar dataSession=sessionStorage.getItem(name);//获取指定键名数据\nvar dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值\n console.log(dataSession,dataSession2,'获取指定键名数据');\nsessionStorage.removeItem(name); //删除指定键名数据\n  console.log(dataAll,'获取全部数据1');\n sessionStorage.clear();//清空缓存数据：localStorage.clear();\n  console.log(dataAll,'获取全部数据2'); \n\n```\n\n## 三者的异同：\n\n### 生命周期：\n * cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效\n\n * localStorage：除非被手动清除，否则将会永久保存。\n\n * sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。\n\n### 存放数据大小：\n * cookie：4kb左右 \n\n * localStorage和sessionStorage：可以保存5MB的信息\n\n### http请求：\n * cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题\n\n * localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持\n\n\n## 应用场景：\n从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。\n\nstorage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。\n\nlocalStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。\n\n## 浏览器的支持情况:\n * localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。\n ![storage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"storage\")\n\n * cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：\n\n ``` javacript\n\nif(navigator.cookieEnabled) {\n  alert(\"你的浏览器支持cookie功能\");//提示浏览器支持cookie  \n} else {\n  alert(\"你的浏览器不支持cookie\");//提示浏览器不支持cookie   }\n\n\n```\n\n### 数据存放处：\n ![dataStorage](https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1 \"dataStorage\")<center><font color=gray size=2>Cookie、localStorage、sessionStorage数据存放处</font></center>\n\n ### 各浏览器Cookie大小、个数的限制\n  **1. 浏览器允许每个域名所包含的cookie数：**\n\n     Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\n     Firefox每个域名cookie限制为50个。\n\n     Opera每个域名cookie限制为30个。\n\n     Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n     注：“每个域名cookie限制为20个”将不再正确！\n\n  **2. 当很多的cookie被设置，浏览器如何去响应：**\n\n     除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n     最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\n     Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。\n\n  **3. 不同浏览器间cookie总大小也不同：**\n\n     Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\n     Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\n     Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n     注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。\n\n\n## 最后：\n不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。\n","slug":"三者之间的区别以及使用方式","published":1,"updated":"2019-08-06T06:34:29.473Z","_id":"cjyzfvx000000ykef5g06h3d9","comments":1,"photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"cookie：\"><a href=\"#cookie：\" class=\"headerlink\" title=\"cookie：\"></a>cookie：</h3><p> <strong>保存cookie值</strong> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var dataCookie=&apos;110&apos;;</span><br><span class=\"line\">   document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取指定名称的cookie值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  function getCookie(name) &#123; //获取指定名称的cookie值</span><br><span class=\"line\">// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；</span><br><span class=\"line\">var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class=\"line\">if(arr != null) &#123;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">  return unescape(arr[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage和sessionStorage：\"><a href=\"#localStorage和sessionStorage：\" class=\"headerlink\" title=\"localStorage和sessionStorage：\"></a>localStorage和sessionStorage：</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的,</strong> 下面以sessionStorage为例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var name=&apos;sessionData&apos;;</span><br><span class=\"line\">var num=120;</span><br><span class=\"line\">sessionStorage.setItem(name,num);//存储数据</span><br><span class=\"line\">sessionStorage.setItem(&apos;value2&apos;,119);</span><br><span class=\"line\">let dataAll=sessionStorage.valueOf();//获取全部数据</span><br><span class=\"line\">console.log(dataAll,&apos;获取全部数据&apos;);</span><br><span class=\"line\">var dataSession=sessionStorage.getItem(name);//获取指定键名数据</span><br><span class=\"line\">var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值</span><br><span class=\"line\"> console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);</span><br><span class=\"line\">sessionStorage.removeItem(name); //删除指定键名数据</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据1&apos;);</span><br><span class=\"line\"> sessionStorage.clear();//清空缓存数据：localStorage.clear();</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据2&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三者的异同：\"><a href=\"#三者的异同：\" class=\"headerlink\" title=\"三者的异同：\"></a>三者的异同：</h2><h3 id=\"生命周期：\"><a href=\"#生命周期：\" class=\"headerlink\" title=\"生命周期：\"></a>生命周期：</h3><ul>\n<li><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p>\n</li>\n<li><p>localStorage：除非被手动清除，否则将会永久保存。</p>\n</li>\n<li><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p>\n</li>\n</ul>\n<h3 id=\"存放数据大小：\"><a href=\"#存放数据大小：\" class=\"headerlink\" title=\"存放数据大小：\"></a>存放数据大小：</h3><ul>\n<li><p>cookie：4kb左右 </p>\n</li>\n<li><p>localStorage和sessionStorage：可以保存5MB的信息</p>\n</li>\n</ul>\n<h3 id=\"http请求：\"><a href=\"#http请求：\" class=\"headerlink\" title=\"http请求：\"></a>http请求：</h3><ul>\n<li><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</li>\n<li><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>\n</li>\n</ul>\n<h2 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p>\n<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。</p>\n<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p>\n<h2 id=\"浏览器的支持情况\"><a href=\"#浏览器的支持情况\" class=\"headerlink\" title=\"浏览器的支持情况:\"></a>浏览器的支持情况:</h2><ul>\n<li><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。<br><img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"storage\" title=\"storage\"></p>\n</li>\n<li><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(navigator.cookieEnabled) &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  </span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"数据存放处：\"><a href=\"#数据存放处：\" class=\"headerlink\" title=\"数据存放处：\"></a>数据存放处：</h3><p> <img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"dataStorage\" title=\"dataStorage\"><center><font color=\"gray\" size=\"2\">Cookie、localStorage、sessionStorage数据存放处</font></center></p>\n<h3 id=\"各浏览器Cookie大小、个数的限制\"><a href=\"#各浏览器Cookie大小、个数的限制\" class=\"headerlink\" title=\"各浏览器Cookie大小、个数的限制\"></a>各浏览器Cookie大小、个数的限制</h3><p>  <strong>1. 浏览器允许每个域名所包含的cookie数：</strong></p>\n<pre><code>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\nFirefox每个域名cookie限制为50个。\n\nOpera每个域名cookie限制为30个。\n\nSafari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n注：“每个域名cookie限制为20个”将不再正确！</code></pre><p>  <strong>2. 当很多的cookie被设置，浏览器如何去响应：</strong></p>\n<pre><code>除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\nFirefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</code></pre><p>  <strong>3. 不同浏览器间cookie总大小也不同：</strong></p>\n<pre><code>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\nOpera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\nInternet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</code></pre><h2 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h2><p>不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。</p>\n<h2 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h2><h3 id=\"cookie：\"><a href=\"#cookie：\" class=\"headerlink\" title=\"cookie：\"></a>cookie：</h3><p> <strong>保存cookie值</strong> </p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var dataCookie=&apos;110&apos;;</span><br><span class=\"line\">   document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie;</span><br></pre></td></tr></table></figure>\n\n<p><strong>获取指定名称的cookie值</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">  function getCookie(name) &#123; //获取指定名称的cookie值</span><br><span class=\"line\">// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；</span><br><span class=\"line\">var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));</span><br><span class=\"line\">if(arr != null) &#123;</span><br><span class=\"line\">  console.log(arr);</span><br><span class=\"line\">  return unescape(arr[2]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return null;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"localStorage和sessionStorage：\"><a href=\"#localStorage和sessionStorage：\" class=\"headerlink\" title=\"localStorage和sessionStorage：\"></a>localStorage和sessionStorage：</h3><p><strong>localStorage和sessionStorage所使用的方法是一样的,</strong> 下面以sessionStorage为例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var name=&apos;sessionData&apos;;</span><br><span class=\"line\">var num=120;</span><br><span class=\"line\">sessionStorage.setItem(name,num);//存储数据</span><br><span class=\"line\">sessionStorage.setItem(&apos;value2&apos;,119);</span><br><span class=\"line\">let dataAll=sessionStorage.valueOf();//获取全部数据</span><br><span class=\"line\">console.log(dataAll,&apos;获取全部数据&apos;);</span><br><span class=\"line\">var dataSession=sessionStorage.getItem(name);//获取指定键名数据</span><br><span class=\"line\">var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值</span><br><span class=\"line\"> console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);</span><br><span class=\"line\">sessionStorage.removeItem(name); //删除指定键名数据</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据1&apos;);</span><br><span class=\"line\"> sessionStorage.clear();//清空缓存数据：localStorage.clear();</span><br><span class=\"line\">  console.log(dataAll,&apos;获取全部数据2&apos;);</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"三者的异同：\"><a href=\"#三者的异同：\" class=\"headerlink\" title=\"三者的异同：\"></a>三者的异同：</h2><h3 id=\"生命周期：\"><a href=\"#生命周期：\" class=\"headerlink\" title=\"生命周期：\"></a>生命周期：</h3><ul>\n<li><p>cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效</p>\n</li>\n<li><p>localStorage：除非被手动清除，否则将会永久保存。</p>\n</li>\n<li><p>sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。</p>\n</li>\n</ul>\n<h3 id=\"存放数据大小：\"><a href=\"#存放数据大小：\" class=\"headerlink\" title=\"存放数据大小：\"></a>存放数据大小：</h3><ul>\n<li><p>cookie：4kb左右 </p>\n</li>\n<li><p>localStorage和sessionStorage：可以保存5MB的信息</p>\n</li>\n</ul>\n<h3 id=\"http请求：\"><a href=\"#http请求：\" class=\"headerlink\" title=\"http请求：\"></a>http请求：</h3><ul>\n<li><p>cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题</p>\n</li>\n<li><p>localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持</p>\n</li>\n</ul>\n<h2 id=\"应用场景：\"><a href=\"#应用场景：\" class=\"headerlink\" title=\"应用场景：\"></a>应用场景：</h2><p>从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。</p>\n<p>storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。</p>\n<p>localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。</p>\n<h2 id=\"浏览器的支持情况\"><a href=\"#浏览器的支持情况\" class=\"headerlink\" title=\"浏览器的支持情况:\"></a>浏览器的支持情况:</h2><ul>\n<li><p>localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。<br><img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2d54764e53af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"storage\" title=\"storage\"></p>\n</li>\n<li><p>cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">if(navigator.cookieEnabled) &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie  </span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">  alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie   &#125;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<h3 id=\"数据存放处：\"><a href=\"#数据存放处：\" class=\"headerlink\" title=\"数据存放处：\"></a>数据存放处：</h3><p> <img src=\"https://user-gold-cdn.xitu.io/2017/11/25/15ff2f727028f37b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\" alt=\"dataStorage\" title=\"dataStorage\"><center><font color=\"gray\" size=\"2\">Cookie、localStorage、sessionStorage数据存放处</font></center></p>\n<h3 id=\"各浏览器Cookie大小、个数的限制\"><a href=\"#各浏览器Cookie大小、个数的限制\" class=\"headerlink\" title=\"各浏览器Cookie大小、个数的限制\"></a>各浏览器Cookie大小、个数的限制</h3><p>  <strong>1. 浏览器允许每个域名所包含的cookie数：</strong></p>\n<pre><code>Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。\n\nFirefox每个域名cookie限制为50个。\n\nOpera每个域名cookie限制为30个。\n\nSafari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。\n\n注：“每个域名cookie限制为20个”将不再正确！</code></pre><p>  <strong>2. 当很多的cookie被设置，浏览器如何去响应：</strong></p>\n<pre><code>除Safari（可以设置全部cookie，不管数量多少），有两个方法：\n\n最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。\n\nFirefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。</code></pre><p>  <strong>3. 不同浏览器间cookie总大小也不同：</strong></p>\n<pre><code>Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。\n\nOpera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。\n\nInternet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。\n\n注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。</code></pre><h2 id=\"最后：\"><a href=\"#最后：\" class=\"headerlink\" title=\"最后：\"></a>最后：</h2><p>不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。</p>\n"},{"layout":"post","title":"javascript垃圾回收机制","date":"2019-07-01T02:53:41.000Z","_content":"\n## 前言\n\n其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n};\n\nsetInterval(replaceThing,1000)\n\n```\n最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:\n1. 识别哪些对象需要被回收。\n2. 回收/重复使用需要被回收对象的内存。\n3. 压缩/整理内存(有些可能没有)\n\n而常见的识别对象是否需要回收的机制有下面几种:\n* 引用计数 (Python)\n* 逃逸分析 (Java)\n* Tracing/Reachable 追踪分析 (javascript)\n\n今天就主要看一下V8中GC的具体实现方式\n\n## Tracing/Reachable 追踪分析\nGC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。\n在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。\n\n\n## The Generational Hypothesis\nGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。\n这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。\n\n### Scavenger\nV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。\n\n![第一次GC](http://img.pandihai.com/03.svg)\n\n\n第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。\n\n![第二次GC](http://img.pandihai.com/04.svg)<center><font color=gray size=2>第二次GC</font></center>\n\n\n在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。\n\n#### Parallel\nParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。\n\n![Scavenger平行调度](http://img.pandihai.com/05.svg)<center><font color=gray size=2>Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center>\n\n### Major GC\nMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。\n\n#### Concurrent\nConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。\n\n![Major GC同步调度](http://img.pandihai.com/09.svg)<center><font color=gray size=2>Major GC同步调度</font></center>\n\n\n### 什么时候会执行GC\n在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。\n\n我们可以通过手动设置来设置新生代和老代的space大小:\n```js\n    node --max-old-space-size=1700 index.js\n    node --max-new-space-size=1024 index.js\n```\n\n\n#### 空闲时GC\n虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过[requestIdleCallback](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解[React 16 fiber的实现](https://www.youtube.com/watch?v=ZCuYPiUIONs))。\n\n![空闲时GC](http://img.pandihai.com/10.svg)<center><font color=gray size=2>利用主线程空闲时间进行GC</font></center>\n\n#### Incremental\n那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。\n\n![Incremental](http://img.pandihai.com/06.svg)<center><font color=gray size=2>将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center>\n\n### 总结\n不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。\n\n最后的最后将之前的内存泄漏代码一步步的推演:\n\n1. 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。\n2. 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,**闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的**,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。**另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量**,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。\n3. 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing->longStr(reachable),theThing->someMethod(reachable),execution stack -> setInterval -> closure -> originThing(reachable)。   \n所有标记完成。此时:\n```js\n          from-space                                to-space\n\n    theThing         (reachable)                theThing\n    replaceThing     (reachable)                replaceThing\n    unused                                      originThing\n    originThing      (reachable)       =>       longStr  \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n4. 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2\n5. 第二次GC开始\n\n```js\n          from-space                                to-space                           old-space\n\n    theThing         (reachable)                theThing                             originThing -> theThing\n    replaceThing     (reachable)                replaceThing                         theThing -> longStr\n    unused                                      originThing                          theThing -> someMethod\n    originThing      (reachable)       =>       longStr                    =>        someMethod -> originThing(closure)        \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n6. 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法\n\n```js\n         old-space\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n```\n\n#### 结论 \n主要导致内存泄漏的原因是\n\n![闭包是在声明的时候被创建的](http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png)<center><font color=gray size=2>闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center>\n\n然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。\n\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n\n  originalThing = null;    //手动释放局部作用域中的变量\n};\n\nsetInterval(replaceThing,1000)\n\n```\n","source":"_posts/javascript垃圾回收机制.md","raw":"---\nlayout: post\ntitle: javascript垃圾回收机制\ndate: 2019-07-01 10:53:41\ntags:\n---\n\n## 前言\n\n其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n};\n\nsetInterval(replaceThing,1000)\n\n```\n最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:\n1. 识别哪些对象需要被回收。\n2. 回收/重复使用需要被回收对象的内存。\n3. 压缩/整理内存(有些可能没有)\n\n而常见的识别对象是否需要回收的机制有下面几种:\n* 引用计数 (Python)\n* 逃逸分析 (Java)\n* Tracing/Reachable 追踪分析 (javascript)\n\n今天就主要看一下V8中GC的具体实现方式\n\n## Tracing/Reachable 追踪分析\nGC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。\n在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。\n\n\n## The Generational Hypothesis\nGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。\n这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。\n\n### Scavenger\nV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。\n\n![第一次GC](http://img.pandihai.com/03.svg)\n\n\n第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。\n\n![第二次GC](http://img.pandihai.com/04.svg)<center><font color=gray size=2>第二次GC</font></center>\n\n\n在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。\n\n#### Parallel\nParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。\n\n![Scavenger平行调度](http://img.pandihai.com/05.svg)<center><font color=gray size=2>Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center>\n\n### Major GC\nMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。\n\n#### Concurrent\nConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。\n\n![Major GC同步调度](http://img.pandihai.com/09.svg)<center><font color=gray size=2>Major GC同步调度</font></center>\n\n\n### 什么时候会执行GC\n在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。\n\n我们可以通过手动设置来设置新生代和老代的space大小:\n```js\n    node --max-old-space-size=1700 index.js\n    node --max-new-space-size=1024 index.js\n```\n\n\n#### 空闲时GC\n虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过[requestIdleCallback](https://developers.google.com/web/updates/2015/08/using-requestidlecallback)事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解[React 16 fiber的实现](https://www.youtube.com/watch?v=ZCuYPiUIONs))。\n\n![空闲时GC](http://img.pandihai.com/10.svg)<center><font color=gray size=2>利用主线程空闲时间进行GC</font></center>\n\n#### Incremental\n那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。\n\n![Incremental](http://img.pandihai.com/06.svg)<center><font color=gray size=2>将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center>\n\n### 总结\n不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。\n\n最后的最后将之前的内存泄漏代码一步步的推演:\n\n1. 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。\n2. 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,**闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的**,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。**另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量**,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。\n3. 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing->longStr(reachable),theThing->someMethod(reachable),execution stack -> setInterval -> closure -> originThing(reachable)。   \n所有标记完成。此时:\n```js\n          from-space                                to-space\n\n    theThing         (reachable)                theThing\n    replaceThing     (reachable)                replaceThing\n    unused                                      originThing\n    originThing      (reachable)       =>       longStr  \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n4. 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2\n5. 第二次GC开始\n\n```js\n          from-space                                to-space                           old-space\n\n    theThing         (reachable)                theThing                             originThing -> theThing\n    replaceThing     (reachable)                replaceThing                         theThing -> longStr\n    unused                                      originThing                          theThing -> someMethod\n    originThing      (reachable)       =>       longStr                    =>        someMethod -> originThing(closure)        \n    c                                           someMethod\n    longStr          (reachable)                \n    someMethod       (reachable)                \n```\n6. 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法\n\n```js\n         old-space\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n    originThing -> theThing -> longStr & someMethod -> originThing(closure)\n```\n\n#### 结论 \n主要导致内存泄漏的原因是\n\n![闭包是在声明的时候被创建的](http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png)<center><font color=gray size=2>闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center>\n\n然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。\n\n``` javacript\n\nvar theThing = null;\nvar replaceThing = function () {\n  var originalThing = theThing;\n  var c = 'a'\n  function unused() {\n    if (originalThing) {\n      console.log(\"hi\");\n    }\n  };\n\n  theThing = {\n    longStr: new Array(1000000).join('*'),\n    someMethod: function () {\n      console.log('1111');\n    }\n  };\n\n  originalThing = null;    //手动释放局部作用域中的变量\n};\n\nsetInterval(replaceThing,1000)\n\n```\n","slug":"javascript垃圾回收机制","published":1,"updated":"2019-08-06T06:18:54.576Z","comments":1,"photos":[],"link":"","_id":"cjyzfvx060001ykefd3we1guc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>\n<ol>\n<li>识别哪些对象需要被回收。</li>\n<li>回收/重复使用需要被回收对象的内存。</li>\n<li>压缩/整理内存(有些可能没有)</li>\n</ol>\n<p>而常见的识别对象是否需要回收的机制有下面几种:</p>\n<ul>\n<li>引用计数 (Python)</li>\n<li>逃逸分析 (Java)</li>\n<li>Tracing/Reachable 追踪分析 (javascript)</li>\n</ul>\n<p>今天就主要看一下V8中GC的具体实现方式</p>\n<h2 id=\"Tracing-Reachable-追踪分析\"><a href=\"#Tracing-Reachable-追踪分析\" class=\"headerlink\" title=\"Tracing/Reachable 追踪分析\"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>\n<h2 id=\"The-Generational-Hypothesis\"><a href=\"#The-Generational-Hypothesis\" class=\"headerlink\" title=\"The Generational Hypothesis\"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>\n<h3 id=\"Scavenger\"><a href=\"#Scavenger\" class=\"headerlink\" title=\"Scavenger\"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>\n<p><img src=\"http://img.pandihai.com/03.svg\" alt=\"第一次GC\"></p>\n<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>\n<p><img src=\"http://img.pandihai.com/04.svg\" alt=\"第二次GC\"><center><font color=\"gray\" size=\"2\">第二次GC</font></center></p>\n<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>\n<h4 id=\"Parallel\"><a href=\"#Parallel\" class=\"headerlink\" title=\"Parallel\"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>\n<p><img src=\"http://img.pandihai.com/05.svg\" alt=\"Scavenger平行调度\"><center><font color=\"gray\" size=\"2\">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>\n<h4 id=\"Concurrent\"><a href=\"#Concurrent\" class=\"headerlink\" title=\"Concurrent\"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>\n<p><img src=\"http://img.pandihai.com/09.svg\" alt=\"Major GC同步调度\"><center><font color=\"gray\" size=\"2\">Major GC同步调度</font></center></p>\n<h3 id=\"什么时候会执行GC\"><a href=\"#什么时候会执行GC\" class=\"headerlink\" title=\"什么时候会执行GC\"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>\n<p>我们可以通过手动设置来设置新生代和老代的space大小:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-old-space-size=<span class=\"number\">1700</span> index.js</span><br><span class=\"line\">node --max-<span class=\"keyword\">new</span>-space-size=<span class=\"number\">1024</span> index.js</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"空闲时GC\"><a href=\"#空闲时GC\" class=\"headerlink\" title=\"空闲时GC\"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"noopener\">React 16 fiber的实现</a>)。</p>\n<p><img src=\"http://img.pandihai.com/10.svg\" alt=\"空闲时GC\"><center><font color=\"gray\" size=\"2\">利用主线程空闲时间进行GC</font></center></p>\n<h4 id=\"Incremental\"><a href=\"#Incremental\" class=\"headerlink\" title=\"Incremental\"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>\n<p><img src=\"http://img.pandihai.com/06.svg\" alt=\"Incremental\"><center><font color=\"gray\" size=\"2\">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>\n<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>\n<ol>\n<li><p>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</p>\n</li>\n<li><p>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</p>\n</li>\n<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing</span><br><span class=\"line\">unused                                      originThing</span><br><span class=\"line\">originThing      (reachable)       =&gt;       longStr  </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>\n</li>\n<li><p>第二次GC开始</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space                           old-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class=\"line\">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class=\"line\">originThing      (reachable)       =&gt;       <span class=\"function\"><span class=\"params\">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     old-space</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>主要导致内存泄漏的原因是</p>\n<p><img src=\"http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png\" alt=\"闭包是在声明的时候被创建的\"><center><font color=\"gray\" size=\"2\">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>\n<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n<p>最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步:</p>\n<ol>\n<li>识别哪些对象需要被回收。</li>\n<li>回收/重复使用需要被回收对象的内存。</li>\n<li>压缩/整理内存(有些可能没有)</li>\n</ol>\n<p>而常见的识别对象是否需要回收的机制有下面几种:</p>\n<ul>\n<li>引用计数 (Python)</li>\n<li>逃逸分析 (Java)</li>\n<li>Tracing/Reachable 追踪分析 (javascript)</li>\n</ul>\n<p>今天就主要看一下V8中GC的具体实现方式</p>\n<h2 id=\"Tracing-Reachable-追踪分析\"><a href=\"#Tracing-Reachable-追踪分析\" class=\"headerlink\" title=\"Tracing/Reachable 追踪分析\"></a>Tracing/Reachable 追踪分析</h2><p>GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。<br>在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。</p>\n<h2 id=\"The-Generational-Hypothesis\"><a href=\"#The-Generational-Hypothesis\" class=\"headerlink\" title=\"The Generational Hypothesis\"></a>The Generational Hypothesis</h2><p>Generational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。<br>这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。</p>\n<h3 id=\"Scavenger\"><a href=\"#Scavenger\" class=\"headerlink\" title=\"Scavenger\"></a>Scavenger</h3><p>V8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。</p>\n<p><img src=\"http://img.pandihai.com/03.svg\" alt=\"第一次GC\"></p>\n<p>第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。</p>\n<p><img src=\"http://img.pandihai.com/04.svg\" alt=\"第二次GC\"><center><font color=\"gray\" size=\"2\">第二次GC</font></center></p>\n<p>在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。</p>\n<h4 id=\"Parallel\"><a href=\"#Parallel\" class=\"headerlink\" title=\"Parallel\"></a>Parallel</h4><p>Parallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。</p>\n<p><img src=\"http://img.pandihai.com/05.svg\" alt=\"Scavenger平行调度\"><center><font color=\"gray\" size=\"2\">Scavenger平行调度,同时有多个帮助线程和主线程参与</font></center></p>\n<h3 id=\"Major-GC\"><a href=\"#Major-GC\" class=\"headerlink\" title=\"Major GC\"></a>Major GC</h3><p>Major GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。</p>\n<h4 id=\"Concurrent\"><a href=\"#Concurrent\" class=\"headerlink\" title=\"Concurrent\"></a>Concurrent</h4><p>Concurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。</p>\n<p><img src=\"http://img.pandihai.com/09.svg\" alt=\"Major GC同步调度\"><center><font color=\"gray\" size=\"2\">Major GC同步调度</font></center></p>\n<h3 id=\"什么时候会执行GC\"><a href=\"#什么时候会执行GC\" class=\"headerlink\" title=\"什么时候会执行GC\"></a>什么时候会执行GC</h3><p>在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。</p>\n<p>我们可以通过手动设置来设置新生代和老代的space大小:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node --max-old-space-size=<span class=\"number\">1700</span> index.js</span><br><span class=\"line\">node --max-<span class=\"keyword\">new</span>-space-size=<span class=\"number\">1024</span> index.js</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"空闲时GC\"><a href=\"#空闲时GC\" class=\"headerlink\" title=\"空闲时GC\"></a>空闲时GC</h4><p>虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过<a href=\"https://developers.google.com/web/updates/2015/08/using-requestidlecallback\" target=\"_blank\" rel=\"noopener\">requestIdleCallback</a>事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解<a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"noopener\">React 16 fiber的实现</a>)。</p>\n<p><img src=\"http://img.pandihai.com/10.svg\" alt=\"空闲时GC\"><center><font color=\"gray\" size=\"2\">利用主线程空闲时间进行GC</font></center></p>\n<h4 id=\"Incremental\"><a href=\"#Incremental\" class=\"headerlink\" title=\"Incremental\"></a>Incremental</h4><p>那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。</p>\n<p><img src=\"http://img.pandihai.com/06.svg\" alt=\"Incremental\"><center><font color=\"gray\" size=\"2\">将一整个GC切分成一小块GC任务,插入到主线程中进行</font></center></p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。</p>\n<p>最后的最后将之前的内存泄漏代码一步步的推演:</p>\n<ol>\n<li><p>首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。</p>\n</li>\n<li><p>1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,<strong>闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的</strong>,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。<strong>另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量</strong>,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。</p>\n</li>\n<li><p>如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。<br>所有标记完成。此时:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing</span><br><span class=\"line\">unused                                      originThing</span><br><span class=\"line\">originThing      (reachable)       =&gt;       longStr  </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在过1000毫秒以后又执行replaceThing,又执行一遍步骤2</p>\n</li>\n<li><p>第二次GC开始</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">from</span>-space                                to-space                           old-space</span><br><span class=\"line\"></span><br><span class=\"line\">theThing         (reachable)                theThing                             originThing -&gt; theThing</span><br><span class=\"line\">replaceThing     (reachable)                replaceThing                         theThing -&gt; longStr</span><br><span class=\"line\">unused                                      originThing                          theThing -&gt; someMethod</span><br><span class=\"line\">originThing      (reachable)       =&gt;       <span class=\"function\"><span class=\"params\">longStr</span>                    =&gt;</span>        someMethod -&gt; originThing(closure)        </span><br><span class=\"line\">c                                           someMethod</span><br><span class=\"line\">longStr          (reachable)                </span><br><span class=\"line\">someMethod       (reachable)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     old-space</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br><span class=\"line\">originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>主要导致内存泄漏的原因是</p>\n<p><img src=\"http://img.pandihai.com/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20190708095349.png\" alt=\"闭包是在声明的时候被创建的\"><center><font color=\"gray\" size=\"2\">闭包是在声明的时候被创建的,而不是执行的时候被创建的。</font></center></p>\n<p>然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">var theThing = null;</span><br><span class=\"line\">var replaceThing = function () &#123;</span><br><span class=\"line\">  var originalThing = theThing;</span><br><span class=\"line\">  var c = &apos;a&apos;</span><br><span class=\"line\">  function unused() &#123;</span><br><span class=\"line\">    if (originalThing) &#123;</span><br><span class=\"line\">      console.log(&quot;hi&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  theThing = &#123;</span><br><span class=\"line\">    longStr: new Array(1000000).join(&apos;*&apos;),</span><br><span class=\"line\">    someMethod: function () &#123;</span><br><span class=\"line\">      console.log(&apos;1111&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  originalThing = null;    //手动释放局部作用域中的变量</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">setInterval(replaceThing,1000)</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}