{"meta":{"title":"阿母工业前端组","subtitle":null,"description":null,"author":"中力前端组","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-29T09:09:19.000Z","updated":"2019-09-03T07:09:14.694Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-29T09:09:57.000Z","updated":"2019-09-03T07:09:14.695Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"正则之replace","slug":"正则之replace","date":"2020-07-22T06:21:27.000Z","updated":"2020-07-23T01:28:05.523Z","comments":true,"path":"2020/07/22/正则之replace/","link":"","permalink":"http://yoursite.com/2020/07/22/正则之replace/","excerpt":"","text":"正则 —— replace前言在项目中，需要对富文本字符串进行处理，给所有的img标签的src属性加上统一域名 所以采用正则来实现 replace方法使用就是字符串.replace（）；如下： 12345var str = 'this is tom';var strReg = str.replace(/tom/g,'jack');console.log(strReg);//this is jack意思就是在字符串str中全局搜索tom这个字符，并将他换成jack`； 其中$符号的使用，$1，$2，$3……是表示正则匹配的组，对应正则规则里的一个（）的内容就是一个组。例子： 12345var str = '123-mm'var strReg = str.replace(/(\\d+)-([A-Za-z]+)/g,'$2')console.log(strReg) //123-mm就被mm替换的了，输出mm 在项目中体现data.content是接口中获取的富文本字符串this.baseUrl是自定义的域名 最早是这么写的 123456let content = unescape(data.content)const srcReg = /src=([\\'\\\"]?([^\\'\\\"]*)[\\'\\\"]?)/gi if (content) &#123; content = content.replace(srcReg, \"src='\" + this.baseUrl + '$2' + \"'\") this.html = unescape(content)&#125; 后来多了一个条件：需要判断原来img的src路径是否包换http等域名前缀，有则无需加修改了正则，$位置也发生改变 123456let content = unescape(data.content)const srcReg = /src=([\\'\\\"](?!(https|http))([^\\'\\\"]*)[\\'\\\"]?)/gi //eslint-disable-lineif (content) &#123; content = content.replace(srcReg, \"src='\" + this.baseUrl + '$3' + \"'\") this.html = unescape(content)&#125; 例子测试使用在线正则测试网站link 测试内容： 1&lt;div data-v-772280c7=\"\" class=\"solution\"&gt;&lt;p&gt;&lt;img src=\"http://epcare.oss-cn-hangzhou.aliyuncs.com/Answer-20200721-504240889240193.jpg\" style=\"width: 200px;\"&gt;&lt;img src=\"http://epcare.oss-cn-hangzhou.aliyuncs.com/Answer-20200721-491064112187750.jpg\" style=\"width: 200px;\"&gt;&lt;img src=\"http://epcare.oss-cn-hangzhou.aliyuncs.com/Answer-20200721-556411729561973.jpg\" style=\"width: 200px;\"&gt;&lt;br&gt;&lt;/p&gt;&lt;img src=\"/FileUpload/Answer/20200716/512331910820482.png\" style=\"width: 200px;\"&gt;&lt;/div&gt; 正则： 1src=([\\&apos;\\&quot;](?!(https|http))([^\\&apos;\\&quot;]*)[\\&apos;\\&quot;]?) 匹配结果： 12共找到 1 处匹配：src=&quot;/FileUpload/Answer/20200716/512331910820482.png&quot; 替换文本: 1http://198.168.1.2$3 替换结果: 1&lt;div data-v-772280c7=&quot;&quot; class=&quot;solution&quot;&gt;&lt;p&gt;&lt;img src=&quot;http://epcare.oss-cn-hangzhou.aliyuncs.com/Answer-20200721-504240889240193.jpg&quot; style=&quot;width: 200px;&quot;&gt;&lt;img src=&quot;http://epcare.oss-cn-hangzhou.aliyuncs.com/Answer-20200721-491064112187750.jpg&quot; style=&quot;width: 200px;&quot;&gt;&lt;img src=&quot;http://epcare.oss-cn-hangzhou.aliyuncs.com/Answer-20200721-556411729561973.jpg&quot; style=&quot;width: 200px;&quot;&gt;&lt;br&gt;&lt;/p&gt;&lt;img http://198.168.1.2/FileUpload/Answer/20200716/512331910820482.png style=&quot;width: 200px;&quot;&gt;&lt;/div&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}],"author":"胡豪"},{"title":"vue中ref与$refs","slug":"vue中ref与","date":"2020-07-20T08:33:01.000Z","updated":"2020-07-22T06:19:49.022Z","comments":true,"path":"2020/07/20/vue中ref与/","link":"","permalink":"http://yoursite.com/2020/07/20/vue中ref与/","excerpt":"","text":"前言有时候在vue中，也需要通过获取dom去实现一些操作，比如控制滚动条这个时候就需要ref与$refs来帮忙了 如何使用1.首先在html里写ref 12345678&lt;Table ref=\"getTable\" :custom-row=\"pointMark\" :columns=\"column\" :data-source=\"tableData\" :pagination=\"false\" :scroll=\"&#123; y: 200 &#125;\"&gt; 2.再js里通过$ref获取,$ref.后面跟着的就是，你在html里自定义的名字 1this.$refs.getTable 实际例子在项目中，通过点击事件，为了解决调整滚动条的，必须要获取带滚动条盒子的dom 在项目中，我要获取的是table子组件里dom 所以需要借助$el 123456789//先获取到子组件domconst tableDom = this.$refs.getTable //通过$el获取子组件内部的dom,一层层往下找，$el.children是数组，包含下一层所有节点const tbodyDom = tableDom.$el.children[0].children[0].children[0].children[0].children[0].children[1]//通过计算滚动条要滚动的高度实现滚动 const scrollHeight = 102 * this.trIndex tbodyDom.scrollTo(0, scrollHeight)","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":"胡豪"},{"title":"数组的查找方法：线性查找二分查找","slug":"数组的查找方法：线性查找二分查找","date":"2020-04-18T06:30:43.000Z","updated":"2020-04-20T00:51:42.541Z","comments":true,"path":"2020/04/18/数组的查找方法：线性查找二分查找/","link":"","permalink":"http://yoursite.com/2020/04/18/数组的查找方法：线性查找二分查找/","excerpt":"","text":"前言从数组中查找你需要的数据，是一个非常常见的需求，那么如何快速的查找你所需要的目标数据呢？ 这篇文章将为你详细的讲解线性查找与二分法查找，并用 javascript 将其实现希望对各位有所帮助 线性查找线性查找是一种在数组中查找数据的算法，从数据的头部开始按顺序往下查找即为线性查找 图解实例如图所示，我们查找的数字 6 在数组中的位置 从数组的最左边开始查找，将其与 6 进行比较，如果结果一致，查找便结束，不一致则向右检查下一个数字。 此处不一致，所以向右继续和下一个数字进行比较。 重复上述操作直到找到数字 6 为止 找到 6 了，查找结束 总结线性查找需要从头开始不断地按顺序检查数据，因此在数据量大且目标数据靠后，或者目标数据不存在时，比较的次数就会更多，也更为好使。若数据量为 n，线性查找的时间复杂便为 O(n)。 用 js 实现线性查找我们想要查找某个值在数组中的位置，需要遍历这个数组，判断当前遍历到的值是否与目标值相等。 声明一个函数，参数为：需要查找的数组，需要查找的数据 遍历数组 比较需要查找的数据是否与当前遍历到的数据相等 如果相等则返回当前元素的位置，结束循环 编写代码 123456789101112const linearSearch = function(arr, target) &#123; // 目标元素位置 let position = -1; for (let i = 0; i &lt; arr.length; i++) &#123; // 如果当前遍历到的值与目标值相等则返回目标元素的位置 if (arr[i] === target) &#123; position = i; return position; &#125; &#125; return position;&#125;; 测试代码 1234567const dataArr = [3, 9, 8, 2, 1, 4, 6, 5, 7];const position = linearSearch(dataArr, 6);if (position !== -1) &#123; console.log(`目标元素在数组中的位置:$&#123;position&#125;`);&#125; else &#123; console.log('目标元素不在数组中');&#125; 二分查找二分查找也叫折半查找、平半劈，二分查找的两个条件，有序和顺序，两者缺一不可，意思就是，一条链，不是一盘散沙，如果两点要求没有达到否则就不能使用二分查找法 二分查找通过比较数组中间的数据与目标数据的大小，可以得知目标数据是在数组的左边还是右边。所以，比较一次就可以把查找范围缩小一半。重复执行该操作接可以找到目标数据，或者得出目标数据不存在的结论 图解实例我们查找数字 6 在数组中的位置 首先，我们先找到数组中中间的数字，此处为 5 将 5 和要查找的数字 6 进行比较 所以把不需要的数字移除查找范围 在剩下的数组中找到中间的数字，此处为 7 然后我们再来比较 6 和 7 再一次把不需要的数字移除查找范围 在剩下的数组中找到中间的数字，此处为 6 最后我们成功找到目标数字啦 6=6 用 JS 实现二分查找二分查找只能查找已经排序好的数据，每一次查找都可以将查找范围减半，查找范围内只剩一个数据时查找结束。 声明一个函数，参数为：要查找的数组，要查找的数据，数组的起点，数组的末尾 找到数组的中间值，将其与目标值进行比较 如果中间值大于目标值，可知目标值在中间值的左侧，则对其左边的数据执行上述操作 如果中间值小于目标值，可知目标值在中间值的右侧，则对其右边的数据执行上述操作 直至中间值等于目标值，则结束上述操作，返回中间值的位置。 编写代码 12345678910111213141516171819202122const binarySearch = function(arr, target, start, end) &#123; let targetPosition = -1; // 计算中间值 const median = Math.floor((start + end) / 2); // 判断中间值与目标值是否相等 if (arr[median] === target) &#123; targetPosition = median; return targetPosition; &#125; // 未找到 if (start &gt;= end) &#123; return targetPosition; &#125; // 判断中间值是否大于目标值 if (arr[median] &gt; target) &#123; // 递归中间值左侧的数组 return binarySearch(arr, target, start, median - 1); &#125; else &#123; // 递归中间值右侧的数组 return binarySearch(arr, target, median + 1, end); &#125;&#125;; 测试代码 1234567const dataArr = [1, 2, 3, 4, 5, 6, 7, 8, 9];const position = binarySearch(dataArr, 6, 0, dataArr.length - 1);if (position !== -1) &#123; console.log(`目标元素在数组中的位置:$&#123;position&#125;`);&#125; else &#123; console.log('目标元素不在数组中');&#125; 区别本质区别线性查找可以从乱序数组中找数据，而线性查找只能从已排序好的数组中查找数据。 性能二分查找利用已排序好的数组，每一次查找都可以将查找范围减半。如果将数量为 n 的数组，将其长度减半 log2n 次后，其中便只剩一个数据了，因此它的时间复杂度为 O(logn) 线性查找需要从头开始不断地按顺序检查数据，因此在数量大且目标数据靠后，或者目标数据不存在时，比较的次数就会更多，也更为耗时。如果数组的数据量为 n，线性查找的时间复杂度便为 O(n) 使用场景线性查找，数组中的数据可以是无序的，添加数据时无需顾虑位置，直接将其插入到数组的末尾即可，不需要耗费时间。 二分查找，数组中的数据必须是有序的，添加数据时就需要考虑位置，需要消耗一定的时间。 总结综合上述，如果你查找数据比较频繁的话二分查找更适合你，否则线性查找更适合你。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"author":"刘涛"},{"title":"Vue中路由传参","slug":"Vue中路由传参","date":"2020-04-15T01:25:49.000Z","updated":"2020-04-15T02:58:08.792Z","comments":true,"path":"2020/04/15/Vue中路由传参/","link":"","permalink":"http://yoursite.com/2020/04/15/Vue中路由传参/","excerpt":"","text":"通常我们在路由中传递数据给另一个页面用如下方法：一、params (不会显示在地址栏)123this.$router.push(&#123; name : 'detail' , params : &#123; id: id &#125; &#125;)&lt;router-link :to=\"&#123;name:'detail',params:&#123;name:1&#125;&#125;\"&gt; xxx &lt;/router-link&gt; 接收参数 1this.$route.params.id 二、query (参数会显示在url的后面)注意：页面之间的跳转使用query 不然的话刷新页面后会找不到参数 12345this.$router.push(&#123; path: '/test', query: &#123; id: id &#125; &#125;)&lt;router-link :to=\"&#123;path:'/detail',query:&#123;id: id&#125;&#125;\"&gt;跳转&lt;router-link&gt;&lt;router-link :to=\"&#123;name:'detail',query:&#123;id:1&#125;&#125;\"&gt; xxx &lt;/router-link&gt; //name还是path 取决于路由配置的时候有没有命名路由 接收参数 1this.$route.query.id 注：这里大家可能会困惑 path 与 name,我要是写反了会怎么样，这里官网的例子里有解答 12345const userId = '123'router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user 三、通过path跳转#动态路由匹配#命名路由 123this.$router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) &lt;router-link :to=\"&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;\"&gt;User&lt;/router-link&gt; 路由： 1234567routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ] 接收参数 1this.$route.params.id 注意：route与router的区别 $route为当前router跳转对象里面可以获取name、path、query、params等 $router为VueRouter实例，想要导航到不同URL，则使用$router.push方法 返回上一个history也是使用$router.go方法 nuxt的路由传参 与vue基本一致123456//js写法:let name = \"ayasa\"this.$router.push(&#123; path : ' /404 ' , query : &#123; name &#125; &#125;)//html写法:&lt;nuxt-link :to=\" '/404?name=' + name \"&gt;&#123;&#123; name &#125;&#125;&lt;/nuxt-link&gt; 最后在做项目时遇到了路由传参在接收页面刷新数据消失的问题解决方法参考以下文章：#参考文章1#参考文章2 在我自己试验的时候，我用query的模式，也遇到了这个问题,在query里我直接的丢了个对象 1this.$router.push(&#123; path : ' /404 ' , query : &#123; obj &#125; &#125;) //obj是我data里定义的一个对象 但是在接收参数页面第一次是有数据的，刷新后，打印的this.$route.query.keyWord就变成[Object Object]取不出值后面我把传值改成了下面这样，就解决了 1this.$router.push(&#123; path : ' /404 ' , query : &#123; name , age , other &#125; &#125;)","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":"胡豪"},{"title":"slot","slug":"slot","date":"2020-04-09T07:55:23.000Z","updated":"2020-04-20T00:51:42.540Z","comments":true,"path":"2020/04/09/slot/","link":"","permalink":"http://yoursite.com/2020/04/09/slot/","excerpt":"","text":"什么是 slot插槽也就是 slot， 是组件的一块 HTML 模板，用于决定将所携带的内容，插入到指定的某个位置，从而使模块分块，具有模块化的特质和更大的重要性，这块模板显示不显示、以及怎样显示是有父组件来决定的，但是插槽显示的位置却由子组件自身决定，slot 写在组件 template 的什么位置，父组件传过来的模板将来就显示在什么位置。 slot 的分类默认插槽123456789// 父组件&lt;template&gt; &lt;div&gt; 我是父组件 &lt;slotOne1&gt; &lt;p style=\"color:red\"&gt;我是父组件插槽内容&lt;/p&gt; &lt;/slotOne1&gt; &lt;/div&gt;&lt;/template&gt; 1234567// 子组件&lt;template&gt; &lt;div class=\"slotOne1\"&gt; &lt;div&gt;我是slotOne1组件&lt;/div&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 在子组件中写入 slot，slot 所在的位置就是父组件要显示的内容 具名插槽将放在子组件里的不同 html 标签放在不同的位置子组件在对应分发的位置的 slot 标签里，添加&lt;slot name=&#39;name名&#39; &gt;内容&lt;/slot&gt;属性，父组件在要显示的标签里添加 slot=&#39;name名&#39;属性，比如要在 p 标签中显示子组件对应的 dom，&lt;p slot=&#39;name名&#39;&gt;&lt;/p&gt;然后就会将对应的标签放在对应的位置了。该 slot 标签没有内容，会显示子组件中该 slot 标签内的内容。 12345678910111213//父组件&lt;template&gt; &lt;div&gt; &lt;child&gt; &lt;div slot=\"title\"&gt;vue.js&lt;/div&gt; &lt;div slot=\"center\"&gt; 是一套用于构建用户界面的渐进式JavaScript框架。 与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。 Vue 的核心库只关注视图层，方便与第三方库或既有项目整合。 &lt;/div&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314//子组件&lt;template&gt; &lt;div class=\"box\"&gt; &lt;div class=\"title\"&gt; &lt;slot name=\"title\"&gt;这是拥有命名的slot的默认title&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"centen\"&gt; &lt;slot name=\"center\"&gt;这是拥有命名的slot的默认内容&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;slot name=\"footer\"&gt;父组件中没footer的时候会显示&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽子组件编写：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 &lt;slot&gt;元素上的特性称为插槽 Prop ，当然也可以传递一些 Function。 12345678910111213141516&lt;template&gt; &lt;div class=\"box\"&gt; &lt;slot name=\"name\" :data=\"data\" &gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; data: [\"zhangsan\", \"lisi\", \"wanwu\", \"zhaoliu\", \"tianqi\", \"xiaoba\"] &#125;; &#125;&#125;;&lt;/script&gt; 父组件编写：被绑定的属性的集合对象，在父元素中会被 v-slot:xxx=”slotProps” 或者 #xxx=”slotProps” 接收，xxx 代表具名插槽的 name ，slotProps 为子组件传递的数据对象，可以重命名。(#是 v-slot 缩写) 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;staff&gt; &lt;template v-slot:name=\"slotProps\"&gt; &#123;&#123;slotProps.data&#125;&#125; &lt;/template&gt; &lt;/staff&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import staff from './Staff'export default &#123; components:&#123;staff&#125;, data () &#123; return &#123;&#125; &#125;&#125;&lt;/script&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":null},{"title":"javascript中的面向对象开发","slug":"javascript中的面向对象开发","date":"2020-02-17T06:06:43.000Z","updated":"2020-02-25T09:33:33.078Z","comments":true,"path":"2020/02/17/javascript中的面向对象开发/","link":"","permalink":"http://yoursite.com/2020/02/17/javascript中的面向对象开发/","excerpt":"","text":"js面向对象开发什么是对象“无序属性的集合，其属性可以包括基本值、对象或者函数”，对象是一组没有特定顺序的的值。对象的没个属性或方法都有一个俄名字，每个名字都映射到一个值。 什么是面向对象编程？面向对象编程的基本思路完全不同。其背后的思想是：你将所需要做的功能抽象成一个“对象”，然后一遍遍地调用这个对象来完成你想要的功能。 每次调用对象时，你必须创建对象，确保对象的存在，然后为了使用对象所带的功能你需要设置它的属性，这些功能称为“方法（methods）”。 面向对象的特点 封装 对于一些功能相同或者相似的代码，我们可以放到一个函数中去，多次用到此功能时，我们只需要调用即可，无需多次重写。 创造对象的几种模式：单例模式，工厂模式，构造函数模式,原型模式等。 继承 子类可以继承父类的属性和方法 多态(重载和重写) 重载：重载就是函数方法名相同，参数不同 重写：子类可以改写父类的属性和方法。 Js中存在多态，但是Js中不存在函数的重载，因为函数名相同的话，后面的一定会把前面的覆盖，但Js中存在重写，所以Js中的多态主要是指重写。但是也存在一种既不是重写却类似重载的Js多态方式,我们可以通过判断函数的参数的不同来实现不同的功能来模拟重载，就是我们调用函数时根据传入不同的参数实现不同的功能，如下： 12345678910function sum(num)&#123; if(typeof num === \"undefined\")&#123; return 0; &#125;return num;&#125;var n1 = sum(10);console.log(n1);var n2 = sum();console.log(n2); 当传入空参数的时候，num为undefined所以会返回0，如果不是空参数的时候，就返回num。 创建对象的几种模式一般创建对象是用以下两种方式 new object创建对象： 1234var Person = new Object();Person.name = \"张三\";Person.age = \"18\";Person.job = \"123\"; 或者，对象字面量的方式： 12345var Person = &#123; name:\"lisi\", age:\"18\", job:\"123\"&#125; 单例模式一个人写代码 1234var a = 1;function getNum()&#123; return 1;&#125; 两个人，一起写同一个js。假设，一天小明发现自己写的getNum方法出问题了，原来是小华写的js中也有个getNum的函数，代码合并后把他的覆盖掉了，于是便找小华理论去，经过一番妥协后，两人都把自己的代码改了改。 123456789101112131415161718var xiaoming = &#123; num:1, getNum:function()&#123; return 1; &#125;&#125;var xiaohua = &#123; num:2, getNum: function()&#123; return 2; &#125;&#125;console.log(xiaoming.num);console.log(xiaoming.getNum());console.log(xiaohua.num);console.log(xiaohua.getNum()); 这就是我们所谓的单例模式(命名空间) 我们把描述同一个事物的方法或者属性放到同一个对象里，不同事物之间的方法或者属性名相同相互也不会发生冲突。 单例模式注意点：当在一个命名空间A中调用别的命名空间B中的函数的时候，调用方法为 B.functionName(); 当在一个命名空间A中调用自己空间中的函数的时候，调用方法为 this.functionName(); 单例模式的优劣优点： 使用单例模式，我们可以实现简单的模块化开发 12345678var obj = &#123; getCss:function()&#123; //code &#125;, setCss:function()&#123; //code &#125;&#125; 我们可以把自己写好的工具方法放到一个单独的js文件中，然后直接引入即可。 避免了全局变量名的冲突 需要注意的是，我们在引入各个模块的时候，需要注意引入的顺序，引入顺序是按照各模块之间的相互依赖进行前后排列的； 缺点： 单例模式只是一定程度上避免了变量名的冲突，但并不能彻底解决此问题，而且在不同的对象下，我们可能会有很多功能相同的代码，最终造成大量的冗余代码。单例模式让每个对象有了自己独立的命名空间，但是并不能批量生产的问题，每一个新的对象都要重新写一份一模一样的代码（如下面代码所示）。 1234567891011121314var person = &#123; name:'小明', age:24, showName:function()&#123; console.log('我的名字是：'+this.name) &#125;&#125;;var person = &#123; name:'小华', age:25, showName:function()&#123; console.log('我的名字是：'+this.name) &#125;&#125;; 工厂模式1、什么是工厂模式？ 把实现同一件事情的相同代码放到同一个函数中，想实现这个功能只要执行这个函数即可，这就是工厂模式，也叫做“函数的封装”，这也是”低耦合，高内聚“，从而达到减少页面冗余代码，提高代码重复利用率的作用。 工厂模式其实就是把需要一个个的编写的对象,放在一个函数中统一的进行创建，说白了就是普通函数的封装。 工厂模式总共3步骤：1）进厂 — 创建一个空对象2）加工 — 加工对象：给对象添加属性和方法；3）输出 — 返回对象：return 对象； 1234567891011121314function CreatePerson(name,age)&#123; var obj=&#123;&#125;;//1.创建一个空对象 //2.加工对象 obj.name=name; obj.age=age; obj.showName=function()&#123; console.log('我的名字是：'+this.name) &#125;; return obj;//3.输出对象；&#125;var person1 = CreatePerson('小明',23)var person2 = CreatePerson('小华',23)person1.showName(); //我的名字是：小明person2.showName(); //我的名字是：小华 工厂模式的优缺点既然叫工厂模式，它就和我们周围的工厂一样，我们只需要把原材料放进去，就能得到我们需要的产品了。 工厂模式也解决了单例模式的批量生产的问题，避免了单例模式中的大量冗余代码，进行系统的封装，提高代码的重复利用率 不过工厂模式跟我们js内置类的调用方法不同 构造函数模式可以创建一个自定义的类，并且可以new出实例构造函数做的就是类和实例打交道。 123456789101112131415//构造函数：首字母大写(约定俗成)；function CreatePerson(name,age)&#123; //创建一个自定义的类 //构造函数中的this，都是new出来的实例 //构造函数中存放的都是私有的属性和方法； this.name=name; this.age=age; this.showName=function()&#123; console.log('我的名字是：'+this.name) &#125;&#125;//实例1var person1 = new CreatePerson('小明',25);person1.showName(); // 我的名字是：,小明//实例2var person2 = new CreatePerson('小华',24); 注意，如果不写new，这就是一个普通函数，它返回undefined。但是，如果写了new，它就变成了一个构造函数，它绑定的this指向新创建的对象，并默认返回this，也就是说，不需要在最后写return this;。 new操作符的作用如下： 1.创建一个空对象2.由this变量引用该对象3.该对象继承该函数的原型4.把属性和方法加入到this引用的对象中5.新创建的对象由this引用，最后隐式地返回this。过程如下： 123let obj = &#123;&#125;;//创建一个空对象obj.__proto__ = Person.prototype;//该对象继承该函数的原型Person.call(obj);//隐式地返回this 工厂模式和构造函数模式的区别： 在调用的时候不同：工厂模式：调用的时候，只是普通函数的调用createPerson();构造函数模式：new CreatePerson(); 在函数体内不同：工厂模式有三步：1）创建对象 2）加工对象 3）返回对象；构造函数模式只有1步： 只有加工对象； 因为系统默认会为其创建对象和返回对象； 构造函数默认给我们返回了一个对象，如果我们非要自己手动返回的话：(1)手动返回的是字符串类型：对以前实例上的属性和方法没有影响；(2)手动返回的是引用数据类型:以前实例身上的属性和方法就被覆盖了；实例无法调用属性和方法； 构造函数的方法都是私有方法，每个实例调用的都是自己私有的方法，同样也会有许多重复的代码。 我们可以使用原型模式来解决每个实例中都有相同方法的函数的问题 原型模式 1234567891011function CreatePerson(name,age)&#123; this.name=name; this.age=age;&#125;// 我们把公有的方法放到函数的原型链上CreatePerson.prototype.showName = function()&#123; console.log('我的名字是：'+this.name)&#125; var person1 = new CreatePerson('小明',25) var person2 = new CreatePerson('小华',24)person1.showName() //小明 原型模式的关键： 1）每个函数数据类型（普通函数，类）上，都有一个属性，叫prototype。2）prototype这个对象上，天生自带一个属性，叫constructor:指向当前这个类；3）每个对象数据类型（普通对象，prototype，实例）上都有一个属性，叫做proto:指向当前实例所属类的原型；通过例子我们来看这几句话是什么意思 123456789function CreatePerson(name,age)&#123; this.name=name; this.age=age&#125;CreatePerson.prototype.showName=function()&#123; console.log('我的名字是：'+this.name)&#125;var person1 = new CreatePerson('小明',25);console.dir(person1) 在chrome浏览器控制台中显示—-&gt; 它们中有一条链关联着 person1.proto === CreatePerson.prototype 接着来看 12345678910111213141516171819202122function Foo()&#123; this.a=1;&#125;Foo.prototype.a=2;Foo.prototype.b=3;var f1 = new Foo; //没有参数的话括号可以省略console.log(f1.a) //1console.log(f1.b) // 3``` ![js面向对象1](https://tvax3.sinaimg.cn/large/b535b7d3ly1gbzgi54h3ej20d903v74w.jpg)接着来说，Foo.prototype是个对象,那么它的__proto__指向哪里呢？每个对象数据类型（普通对象，prototype，实例）上都有一个属性，叫做__proto__:指向当前实例所属类的原型 此外，我们应该知道每一个对象都是function Object这个构造函数的实例```jsvar obj = Object();obj.__proto__==Object.prototype //true 所以我们可以接着还原这个原型图 还没完,我们发现对象都是函数(构造器)创造出来的，那么函数是谁创造的呢？在js中,function都是由function Function这个构造器创造的，每一个函数都是Function的实例 12function fun()&#123;&#125;;fun.__proto__==Function.prototype //true 现在基本上我们就能得出了完整的原型图了 补充： 多说一点,判断数据类型的方法时，我们知道有个instanceof的方法比如 A instanceof Binstanceof判断的规则就是: 沿着A的proto这条线查找的同时沿着B的prototype这条线来找，如果两条线能找到同一个引用(对象)，那么就返回true。如果找到终点还未重合，则返回false。 再来看我们之前的那个例子 function Foo(){ this.a=1; } Foo.prototype.a=2; Foo.prototype.b=3; var f1 = new Foo; //没有参数的话括号可以省略 console.log(f1.a) //1 console.log(f1.b) //3 当我们查找f1.a时，因为f1中有这个属性,所以我们得出 f1.a=1;当我们查找f1.b时，f1中没有这个属性,我们便顺着f1.proto这条链去它的构造器的prototype上找,所以我们得出了 f1.b = 3;当我们查找一个对象的属性时,先在这个对象的私有空间内查找，如果没找到,就顺着对象的proto这条链去它的构造器的ptototype上查找,如果还没找到,接着沿proto向上查找,直到找到Object.prototype还没有的话,这个值就为undefined,这就是所谓的原型链 总结面向对象开发对我们平时开发有什么好处？ 随着代码库的增长，你需要改变你组织思路的方法，并开始用面向对象的方式思考。与一系列相互纠缠需要通过一系列的参数传递才能运行的函数相比，对象的范围很容易控制和追踪。 基于函数编程的问题在于，一旦有一个函数出现问题，就会导致整个链上的流程失败。而对于对象而言，一个方法出问题不会（也不应该）影响到其他类。 补充：JS CLASS类","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"author":"胡豪"},{"title":"关于元素在网页中的位置总结","slug":"关于元素在网页中的位置总结","date":"2020-02-04T13:05:10.000Z","updated":"2020-02-25T09:33:33.080Z","comments":true,"path":"2020/02/04/关于元素在网页中的位置总结/","link":"","permalink":"http://yoursite.com/2020/02/04/关于元素在网页中的位置总结/","excerpt":"","text":"offsetLeft与style.left的区别offsetLeft 获取的是相对于父对象的左边距 left 获取或设置相对于 具有定位属性(position定义为relative)的父对象 的左边距 如果父div的position定义为relative,子div的position定义为absolute，那么子div的style.left的值是相对于父div的值，这同offsetLeft是相同的，区别在于： style.left 返回的是字符串，如28px，offsetLeft返回的是数值28，如果需要对取得的值进行计算，还用offsetLeft比较方便。 style.left是读写的，offsetLeft是只读的，所以要改变div的位置，只能修改style.left。 style.left的值需要事先定义，否则取到的值为空。而且必须要定义在html里，我做过试验，如果定义在css里，style.left的值仍然 为空，这就是我刚开始碰到的问题，总是取不到style.left的值。offsetLeft则仍然能够取到，无需事先定义div的位置。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"author":"胡豪"},{"title":"css3手写菜单图标变成X号","slug":"css3手写菜单图标变成X号","date":"2020-01-19T07:42:59.000Z","updated":"2020-02-25T09:33:33.148Z","comments":true,"path":"2020/01/19/css3手写菜单图标变成X号/","link":"","permalink":"http://yoursite.com/2020/01/19/css3手写菜单图标变成X号/","excerpt":"","text":"前言做项目中经常会遇到三条横线的菜单按钮，一般都是点击按钮出现菜单栏，再次点击关闭菜单栏，直接显示X号就显得很生硬，这里使用CSS3动画将这个过渡过程变得非线性感，更讨好眼球。例子里用的是hover更直接明显，在项目里可以用class来控制 如何写代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;CSS3 写菜单按钮变形小动画&lt;/title&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css\"&gt;&lt;/script&gt; &lt;style&gt; .menu-button &#123; position: absolute; top: 18px; left: 24px; width: 30px; height: 24px; padding: 0; cursor: pointer; border: none; outline: none; background: transparent; &#125; button &#123; -webkit-appearance: button; &#125; button,select &#123; text-transform: none; &#125; button,input,optgroup,select,textarea &#123; font-family: inherit; font-size: 100%; line-height: 1.15; margin: 0; &#125; .menu-button:after,.menu-button:before &#123; content: \"\"; position: absolute; top: 50%; left: 0; width: 100%; height: 2px; border-radius: 2px; pointer-events: none; -webkit-transition: -webkit-transform 0.25s; transition: -webkit-transform 0.25s; transition: transform 0.25s; transition: transform 0.25s, -webkit-transform 0.25s; -webkit-transform-origin: 50% 50%; transform-origin: 50% 50%; &#125; .menu-button:after,.menu-button:before,.menu-button span &#123; background: #5f656f; &#125; .menu-button:before &#123; -webkit-transform: translate3d(0, -10px, 0) scaleX(0.8); transform: translate3d(0, -10px, 0) scaleX(0.8); &#125; .menu-button:after &#123; -webkit-transform: translate3d(0, 10px, 0) scaleX(0.8); transform: translate3d(0, 10px, 0) scaleX(0.8); &#125; .menu-button span &#123; position: absolute; left: 0; overflow: hidden; width: 100%; height: 2px; text-indent: 200%; -webkit-transition: opacity 0.25s; transition: opacity 0.25s; &#125; .header:hover .menu-button--open:before &#123; -webkit-transform: rotate(45deg); transform: rotate(45deg); &#125; .header:hover .menu-button--open:after &#123; -webkit-transform: rotate(-45deg); transform: rotate(-45deg); &#125; .header:hover .menu-button--open span &#123; opacity: 0; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--header--&gt; &lt;div class=\"header\"&gt; &lt;button class=\"menu-button menu-button--open\"&gt;&lt;span&gt;Menu&lt;/span&gt;&lt;/button&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 知识要点总结1.transform 属性 rotate(deg) //顺时针旋转 translate3d(x,y,z) //3D转换 scaleX(0.8); //按0.8比例X轴缩放 scale(1.1) //按1.1比例中心缩放scale(X,Y)，X表示元素沿着水平方向（X轴）缩放的倍数，y表示元素沿着垂直方向（Y轴）缩放的倍数。只设置一个值（没有设置Y）,则表示X、Y两个方向的缩放倍数是一样的（同时放大相同倍数）。 2.transition 属性实现过渡动画效果，和控制动画持续时间transition: property duration timing-function delay; property : 指定CSS属性的name，transition效果 duration : transition效果需要指定多少秒或毫秒才能完成,默认值为0,&gt;0才有动画效果 timing-function: 指定transition效果的转速曲线默认值为 ease 值 效果描述 ease 慢速开始，然后变快，然后慢速结束的过渡效果 linear 匀速 ease-in 慢速开始的过渡效果 ease-out 慢速结束的过渡效果 ease-in-out 慢速开始和结束的过渡效果 delay: 延迟多久秒开始过渡效果，默认值0","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"author":"胡豪"},{"title":"Fetch与Promise","slug":"Fetch与Promise","date":"2020-01-07T06:21:55.000Z","updated":"2020-01-16T06:53:33.014Z","comments":true,"path":"2020/01/07/Fetch与Promise/","link":"","permalink":"http://yoursite.com/2020/01/07/Fetch与Promise/","excerpt":"","text":"什么是FecthFetch是一种HTTP数据请求的方式，是XMLHttpRequest的一种替代方案。Fetch不是ajax的进一步封装，它们是两个东西。Fetch函数就是原生js，没有使用XMLHttpRequest对象。 XMLHttpRequest 是一个设计粗糙的API，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 Fetch 的出现就是为了解决 XHR 的问题，它实现了 Promise 规范，返回 Promise 实例；而 Promise 是为解决异步回调问题而摸索出的一套方案。 简述Promise说Fetch，免不了谈及Promise，这里就再来回顾下/Promise/： Promise是一个对象，用作占位符，用于延迟（可能是异步）计算的最终结果。 一个 Promise 就是一个对象，它代表了一个异步操作的最终完成或者失败。 本质上，Promise 是一个绑定了回调的对象，而不是将回调传进函数内部。 Promise的三种状态： 初始化，状态：pending 当调用resolve(成功)，状态：pengding=&gt;fulfilled 当调用reject(失败)，状态：pending=&gt;rejected 使用 Fetch基本操作： 12345678910111213141516171819202122232425262728fetch(url).then(function(response) &#123; return response.json();&#125;).then(function(data) &#123; console.log(data);&#125;).catch(function(err) &#123; console.log(err);&#125;);//使用 ES6 的 箭头函数后： fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(err =&gt; console.log(\"error\", err)) //发送jsonfetch('/xxx', &#123; method: 'post', body: JSON.stringify(&#123; username: '', password: '' &#125;)&#125;);//发送formvar form = document.querySelector('form');fetch('/xxx', &#123; method: 'post', body: new FormData(form)&#125;); Response(res)对象成员 ok:是否成功 headers:响应头对象 status/statusText:状态码/状态文本 redirected:是否重定向过 要获取响应头里面的Content-Type,调用方法： 1res.headers.get('Content-Type') 举个例子(登录接口)12345678910111213141516171819202122232425262728293031323334353637383940414243LogIn() &#123; let params = &#123; username: 'test', password: '123456' &#125; fetch('http://192.168.3.103:9999/api/users/login', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(params) &#125;) .then((res) =&gt; &#123; return res.json(); &#125;) .then((json) =&gt; &#123; console.log(json) &#125;) .catch(e =&gt; &#123; console.log('errr', e); &#125;);&#125;//async,await使用async LogIn() &#123; let params = &#123; username: 'test', password: '123456' &#125; try &#123; let response = await fetch('http://192.168.3.103:9999/api/users/login', &#123; method: 'POST', headers: &#123; 'Content-Type': 'application/json' &#125;, body: JSON.stringify(params) &#125;) let dataPromise = await response.json(); console.log(dataPromise) &#125; catch(err) &#123; console.log(err) &#125;&#125; 小结Fetch 就是ES6提供的一个异步接口，这样省的自己封装了。一个基本的fetch操作很简单，就是通过fetch请求，返回一个promise对象，然后在promise对象的then方法里面用fetch的response.json()等方法进行解析数据，由于这个解析返回的也是一个promise对象，所以需要两个then才能得到我们需要的json数据。 fetch优势： 语法简洁，更加语义化 基于标准 Promise 实现，支持 async/await 同构方便，使用 isomorphic-fetch 优雅的使用fetchfetch的确很好用，但是有的浏览器确是不支持的(比如IE)，这时就需要我们手动实现ajax作为替代，或者引入polyfill。 由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim, es5-sham 引入 Promise 的 polyfill: es6-promise 引入 fetch 探测库：fetch-detector 引入 fetch 的 polyfill: fetch-ie8 使用 async/await 如需跨域，可使用fetch-jsonp 为何不能直接使用Fetch基本操作fetch是一个低层次的API，你可以把它考虑成原生的XHR，所以使用起来并不是那么舒服，需要进行封装。 当接收到一个代表错误的 HTTP 状态码时,比如400, 500，fetch不会把promise标记为reject, 而是标记为resolve，仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下，fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）。 1fetch(url, &#123;credentials: 'include'&#125;) fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费。原生不行，但可以用到 bluebird 查阅方法，通过可以取消 promise，去达到取消fetch的目的。 fetch没有办法原生监测请求的进度，而XHR可以。 从这里可以看出来，如果我们要在fetch请求出错的时候及时地捕获错误，是需要对response的状态码进行解析的。又由于fetch返回的数据不一定是json格式，我们可以从header里面Content-Type获取返回的数据类型，进而使用正确的解析方法。 接收到一个代表错误的 HTTP 状态码时通过抛出错误改进： 1234567891011checkStatus(response) &#123;//检查响应状态 if(response.status &gt;= 200 &amp;&amp; response.status &lt; 300) &#123;//响应成功 return response; &#125; if(response.status === 301 || response.status === 302) &#123;//重定向 window.location = response.headers.get('Location'); &#125; const error = new Error(response.statusText); error.data = response; throw error;&#125; 判断数据类型，进而使用正确的解析： 123456789101112131415161718async parseResult(response) &#123;//解析返回的结果 const contentType = response.headers.get('Content-Type'); if(contentType != null) &#123; if(contentType.indexOf('text') &gt; -1) &#123; return await response.text() &#125; if(contentType.indexOf('form') &gt; -1) &#123; return await response.formData(); &#125; if(contentType.indexOf('video') &gt; -1) &#123; return await response.blob(); &#125; if(contentType.indexOf('json') &gt; -1) &#123; return await response.json(); &#125; &#125; return await response.text();&#125; 使用async/awiait的原因123456789(async () =&gt; &#123; try &#123; let response = await fetch(url); let data = await response.json(); console.log(data); &#125; catch(error) &#123; console.log(\"error:\", error); &#125;&#125;)() Promise 将异步操作规范化。使用then连接, 使用catch捕获错误, 堪称完美, 美中不足的是, then和catch中传递的依然是回调函数。为此, ES7 提供了更标准的解决方案 — async/await.使用 await 后，告别面条式调用。从代码可以看到 await 后面可以跟 Promise 对象，表示等待 Promise resolve() 才会继续向下执行，如果 Promise 被 reject() 或抛出异常则会被外面的 try…catch 捕获。 Await b()与Promise.then(b)有的小伙伴可能很困惑.then()与await;可以参考一篇文章从JS引擎理解Await b()与Promise.then(b)的堆栈处理 总结由此看出Fetch存在各种问题，实际使用中需要二次封装，相比于ajax、axios，现阶段更推荐使用axios","categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"author":"胡豪"},{"title":"Vue之mixin","slug":"Vue中使用mixin","date":"2020-01-03T01:36:11.000Z","updated":"2020-01-06T00:44:54.905Z","comments":true,"path":"2020/01/03/Vue中使用mixin/","link":"","permalink":"http://yoursite.com/2020/01/03/Vue中使用mixin/","excerpt":"","text":"常见场景 何时需要使用到mixin呢? 通常遇到有两个非常相似的组件，他们的基本功能是一样的，但他们之间又存在着足够的差异性，此时的你就像是来到了一个分岔路口：我是把它拆分成两个不同的组件呢？还是使用一个组件，然后通过props传值？对于实现功能来说，这两者都可以做到，但是不够完美。拆成两个组件的写法，遇到功能变动就要在两个文件中去修改，无疑是增加了更新的风险，违反DRY原则。而一个组件，太多的props传值会使得简单的逻辑变得复杂，后期维护时使用组件必须理解一大段上下文，降低了工作效率;这时候使用Mixin就显得很合适； Vue 中的Mixin对编写函数式风格的代码很有用，因为函数式编程就是通过减少移动的部分让代码更好理解（引自 Michael Feathers ）。Mixin允许你封装一块在应用的其他组件中都可以使用的函数。如果使用姿势得当，他们不会改变函数作用域外部的任何东西，因此哪怕执行多次，只要是同样的输入你总是能得到一样的值，真的很强大！ 要注意的是 组件 /= mixin，新手可能会混为一谈 单纯组件引用： 父组件 + 子组件 &gt;&gt;&gt; 父组件 + 子组件（父子组件相对而言是独立的） mixins： 父组件 + 原本子组件的逻辑提取出来（mixin.js） &gt;&gt;&gt; new父组件（mixin中的方法和属性也就并入到该组件中，可以直接使用。）钩子函数会两个都被调用，mixin中的钩子首先执行。 简单用法定义一个 js 文件(mixin.js)我们可以在这里提取逻辑并创建可以被重用的项： 123456789101112export default &#123; data() &#123; return &#123; name: &apos;我是mixin&apos; &#125; &#125;, created() &#123; console.log(this.name); &#125;, mounted() &#123;&#125;, methods: &#123;&#125; &#125; 一般为了清晰，我会在components文件夹内新建一个mixins文件夹，在这里面放mixin的js 在组件中使用 1234import mixin from &apos;@/components/mixins/mixin&apos;; // 引入mixin文件export default &#123; mixins: [mixin]&#125; 选项合并当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。 一、数据冲突数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。 12345678910111213141516171819202122var mixin = &#123; data: function () &#123; return &#123; message: &apos;hello&apos;, foo: &apos;abc&apos; &#125; &#125;&#125;new Vue(&#123; mixins: [mixin], data: function () &#123; return &#123; message: &apos;goodbye&apos;, bar: &apos;def&apos; &#125; &#125;, created: function () &#123; console.log(this.$data) // =&gt; &#123; message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; &#125; &#125;&#125;) 组件中的值会覆盖混入的数据值 二、同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 123456789101112131415var mixin = &#123; created: function () &#123; console.log(&apos;混入对象的钩子被调用&apos;) &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log(&apos;组件钩子被调用&apos;) &#125;&#125;)// =&gt; &quot;混入对象的钩子被调用&quot;// =&gt; &quot;组件钩子被调用&quot; 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。 1234567891011121314151617181920212223242526var mixin = &#123; methods: &#123; foo: function () &#123; console.log(&apos;foo&apos;) &#125;, conflicting: function () &#123; console.log(&apos;from mixin&apos;) &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log(&apos;bar&apos;) &#125;, conflicting: function () &#123; console.log(&apos;from self&apos;) &#125; &#125;&#125;)vm.foo() // =&gt; &quot;foo&quot;vm.bar() // =&gt; &quot;bar&quot;vm.conflicting() // =&gt; &quot;from self&quot; 通俗地讲，混入先运行，组件权重大，冲突看组件 总结混入提供给我们了一种实现方式，用组件还是混入，开头也已经提过，项目中还需具体问题具体分析，不可盲目","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":"胡豪"},{"title":"修改img的src属性刷新图片时，图片地址相同图片无变化的问题","slug":"修改img的src属性刷新图片时，图片地址相同图片无变化的问题","date":"2019-12-18T07:59:04.000Z","updated":"2019-12-18T08:05:11.867Z","comments":true,"path":"2019/12/18/修改img的src属性刷新图片时，图片地址相同图片无变化的问题/","link":"","permalink":"http://yoursite.com/2019/12/18/修改img的src属性刷新图片时，图片地址相同图片无变化的问题/","excerpt":"","text":"前言修改img的src属性刷新图片时，如果图片地址相同，图片无变化的问题 最主要的原因浏览器会有缓存，它会认为图片没有变化，是相同的 项目中需要上传图片预览.但是第二次上传图片显示的时候发现之前的图片没有改变.后经过分析发现是地址相同第二次改变img src属性的时候图片未发生改变,浏览器第二次不会去请求服务器 解决方案很easy:在修改img的src属性的时候加上一个随机数即可,让浏览器以为每次请求的服务器都不同. 123image.attr('src', data.message+'?'+Math.random());//当然不用随机数，也可以用个当前时间的时间戳","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}],"author":"胡豪"},{"title":"Vue写tab选项卡","slug":"Vue写tab选项卡","date":"2019-12-17T01:22:18.000Z","updated":"2019-12-17T07:02:32.265Z","comments":true,"path":"2019/12/17/Vue写tab选项卡/","link":"","permalink":"http://yoursite.com/2019/12/17/Vue写tab选项卡/","excerpt":"","text":"Vue写tab选项卡固定选项的写法遇到UI上只有2个或者3个固定选项的写法 12345678910111213141516171819202122232425262728293031323334353637//2个的情况只要用一个开关字段来控制显示隐藏即可//3个及以上的写法，可以价格tabId来控制&lt;div id=\"app\"&gt; &lt;!-- tab 选项 --&gt; &lt;div class=\"tab\"&gt; &lt;div class=\"tag\" :class=\"&#123; active: tabId==0 &#125;\" @click=\"tabId=0\"&gt; 已出账单 &lt;/div&gt; &lt;div class=\"tag\" :class=\"&#123; active: tabId==1 &#125;\" @click=\"tabId=1\"&gt; 未出账单 &lt;/div&gt; &lt;div class=\"tag\" :class=\"&#123; active: tabId==2 &#125;\" @click=\"tabId=2\"&gt; 定金 &lt;/div&gt; &lt;/div&gt; &lt;!-- box 内容 --&gt; &lt;div class=\"box\" &gt; &lt;!-- 制作选项卡内容 === 是判断 --&gt; &lt;div v-show=\"tabId===0\"&gt; 内容块 &lt;/div&gt; &lt;div v-show=\"tabId===1\"&gt; 内容块 &lt;/div&gt; &lt;div v-show=\"tabId===2\"&gt; 内容块 &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;data()&#123; return &#123; //表格切换 toggleTable:true, //2个tab切换使用 tabId:0, //3个及以上tab切换使用 &#125;&#125;, 非固定选项的写法常常我们也会遇到tab选项没有具体固定有几个项，需要我们根据接口数据生成对应的tab项 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id=\"app\"&gt; &lt;ul&gt; &lt;li @click=\"toggle(index ,tab.view)\" v-for=\"(tab,index) in tabs\" :class=\"&#123;active:active===index&#125;\"&gt; &#123;&#123;tab.type&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;component :is=\"currentView\"&gt;&lt;/component&gt;&lt;/div&gt;&lt;script&gt;Vue.component('child1', &#123; template: \"&lt;p&gt;this is child1&lt;/p&gt;\"&#125;)Vue.component('child2', &#123; template: \"&lt;p&gt;this is child2&lt;/p&gt;\"&#125;)new Vue(&#123; el: \"#app\", data: &#123; active: 0, currentView: 'child1', tabs: [ &#123; type: 'tab1', view: 'child1' &#125;, &#123; type: 'tab2', view: 'child2' &#125; ] &#125;, methods: &#123; toggle(i, v)&#123; this.active = i this.currentView = v &#125; &#125;&#125;)&lt;/script&gt;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":"胡豪"},{"title":"for循环创建多个elementUI表单遇到的问题","slug":"for循环创建多个elementUI表单遇到的问题","date":"2019-12-11T07:02:30.000Z","updated":"2019-12-13T07:26:17.381Z","comments":true,"path":"2019/12/11/for循环创建多个elementUI表单遇到的问题/","link":"","permalink":"http://yoursite.com/2019/12/11/for循环创建多个elementUI表单遇到的问题/","excerpt":"","text":"前言目前有一个需求就是：点击添加按钮创建一个表单，可以保存删除修改等一系列操作。因为是表单所以涉及到需要表单验证。差了很多资料发现都是点击之后添加一条可输入的input框之类，并没整体循环一整个表单的。 上图是一个商品列表，商品列表的每一项的授权按钮，都会弹出一个授权的表单，遇到的问题是，elementUI的表单放在for循环里渲染出来,那么常规的提交表单和清空表单会报错，显示this.$refs[formName].validate()方法不存在，组件引入都没有问题;但表单放在for循环外面就没有问题，经过试验发现是form表单放在for循环里出现的问题; 改动如下,就不会出现问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;template&gt; &lt;div v-for=\"(item,index) in ProductList\" :key=\"index\" class=\"customCenList\"&gt; &lt;div class=\"list\"&gt; &lt;img src=\"~assets/images/rankCar.png\"&gt; &lt;span style=\"width:200px;\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;span&gt;&lt;nuxt-link to=\"/\"&gt; &lt;span class=\"downFont\"&gt;下载样品&lt;/span&gt; &lt;/nuxt-link&gt;&lt;/span&gt; &lt;span style=\"width: 100px;\"&gt;&#123;&#123; item.number &#125;&#125;台&lt;/span&gt; &lt;span style=\"width: 140px;\"&gt;￥&#123;&#123; item.customizedDeposit &#125;&#125;&lt;/span&gt; &lt;span style=\"width: 140px;\"&gt;￥&#123;&#123; item.stockDeposit &#125;&#125;&lt;/span&gt; &lt;div v-if=\"item.isHead\" class=\"listButton\"&gt; &lt;span @click=\"showLicense1(item.id)\"&gt;查看授权客户&lt;/span&gt;&lt;br&gt; &lt;span @click=\"showLicense2(item.id)\"&gt;授权&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 授权 --&gt; &lt;div v-show=\"item.id==currentId&amp;&amp;showItem1\" class=\"license1\"&gt; &lt;div class=\"boxName\"&gt; &lt;span&gt;授权&lt;/span&gt;&lt;span @click=\"retract1\"&gt;收起&lt;/span&gt; &lt;/div&gt; &lt;ElForm ref=\"myform\" :model=\"myform\" :rules=\"rules\" :inline=\"true\"&gt; &lt;FormItem prop=\"price\" label=\"购买价格:\" style=\"margin-right:30px;\"&gt; &lt;ElInput v-model=\"myform.price\" size=\"small\" style=\"width:100px\" oninput=\"value=value.replace(/[^\\d.]/g,'')\" /&gt; &lt;/FormItem&gt; &lt;FormItem prop=\"phone\" label=\"手机号:\" style=\"margin-right:30px;\"&gt; &lt;ElInput v-model=\"myform.phone\" size=\"small\" style=\"width:200px\" /&gt; &lt;/FormItem&gt; &lt;FormItem prop=\"company\" label=\"公司名称:\"&gt; &lt;ElInput v-model=\"myform.company\" size=\"small\" style=\"width:250px\" /&gt; &lt;/FormItem&gt; &lt;div class=\"bottom\"&gt; &lt;span&gt;注：授权客户直接向中力购买产品，客户手机号应为注册账户使用手机号&lt;/span&gt; &lt;div class=\"bottomBtns clear\"&gt; &lt;div class=\"sure\" @click=\"submitForm('myform',index)\"&gt;确定&lt;/div&gt; &lt;div class=\"cancel\" @click=\"resetForm('myform',index)\"&gt;取消&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/ElForm&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;data() &#123; return &#123; formDate: [ &#123; id: 0, price: \"\", phone: \"\", company: \"\" &#125;, &#123; id: 0, price: \"\", phone: \"\", company: \"\" &#125; ], rules: &#123; price: [ &#123; required: true, message: \"请输入价格\", trigger: \"blur\" &#125; ], company: [ &#123; required: true, message: \"请输入公司名称\", trigger: \"blur\" &#125; ], phone: [ &#123; required: true, message: \"请输入手机号码\", trigger: \"blur\" &#125;, &#123; len: 11, pattern: /^1[3-9][0-9]&#123;9&#125;/, message: \"请输入正确的手机号\", trigger: \"blur\" &#125; ] &#125;, &#125;;&#125;,//重置表单resetForm(formName,index) &#123; this.$refs[formName][index].resetFields(); this.myform.id = 0;&#125;,//表单保存saveForm(formName, index) &#123; this.$refs[formName][index].validate((valid) =&gt; &#123; if (valid) &#123; console.log('验证成功！'); &#125; else &#123; console.log('error submit!!'); return false; &#125; &#125;);&#125; 首先当验证时报错时先看你表单上的ref和保存时refs是否一致。 123&lt;el-form ref=\"myform\" :model=\"formDate\" :rules=\"rules\"&gt;this.$refs[formName][index].validate((valid) =&gt; &#123;&#125; 如果要是循环出多个表单。那么refs输出就是一个数组。所以在验证的时候需要获取到当前表单的下标。 123&lt;div class=\"sure\" @click=\"submitForm('myform',index)\"&gt;确定&lt;/div&gt;this.$refs[formName][index].validate((valid) =&gt; &#123;&#125; 参考文章","categories":[{"name":"elementUI","slug":"elementUI","permalink":"http://yoursite.com/categories/elementUI/"}],"tags":[{"name":"elementUI","slug":"elementUI","permalink":"http://yoursite.com/tags/elementUI/"}],"author":"胡豪"},{"title":"常用CSS","slug":"常用CSS","date":"2019-12-06T05:59:49.000Z","updated":"2019-12-06T06:06:02.559Z","comments":true,"path":"2019/12/06/常用CSS/","link":"","permalink":"http://yoursite.com/2019/12/06/常用CSS/","excerpt":"","text":"###常用CSS汇总 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//div里放入input的css.inputBox input&#123; outline: none; -webkit-appearance: none; border-radius: 0; border:0; text-indent:10px;&#125;//css三角形.progress .progress-value:after &#123; content: \"\"; border-top: 7px solid #393a3d; border-left: 7px solid transparent; border-right: 7px solid transparent; position: absolute; bottom: -7px; left: 35%;&#125;Overflow参数： visible : 不剪切内容也不添加滚动条。假如显式声明此默认值，对象将被剪切为包含对象的window或frame的大小。并且clip属性设置将失效auto : 此为body对象和textarea的默认值。在需要时剪切内容并添加滚动条hidden : 不显示超过对象尺寸的内容scroll : 总是显示滚动条适配手机屏幕代码&lt;metaname=\"viewport\"content=\"width=device-width,initial-scale=1\"&gt;//手机/微信 开发必备 插件 网站http://www.swiper.com.cn/table 中td占位多行多列的方法colspan 单元格占多少列rowspan 单元格占多少行input number 去掉后面的那个 上下箭头input::-webkit-outer-spin-button,input::-webkit-inner-spin-button &#123; -webkit-appearance: none; margin: 0;&#125;input[type=\"number\"] &#123; -moz-appearance: textfield;&#125;//文本超出省略...&#123; text-overflow:ellipsis; overflow:hidden; white-space: nowrap;&#125;/*这个是多行超出隐藏的*/&#123; text-overflow: ellipsis; -webkit-line-clamp:3; display: -webkit-box; &#125;/* png、jpg制作 font-class 步骤（效果不是很好）*/ 网站：http://www.pngtosvg.com/ 将 jpg、png转换为 svg 网站：http://iconfont.cn/ 批量上传到阿里的svg库，然后转换为字体文件下载 css 直接 应用/* 使用png转font-class方法 */ 1、使用软件inkscape软件，首先 “文件”“打开”“png文件”----》“另存为”“inkscape SVG”类型文件 2、“文件”“导入”“刚才保存的svg图片”--&gt; “路径”“提取位图轮廓”“更新确定”“保存” 3、依然使用网站 http://iconfont.cn/ 批量上传到阿里的svg库，然后转换为文字文件下载 4、打开font里面的demo，根据demo直接使用","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}],"author":"胡豪"},{"title":"ES6中的箭头函数","slug":"ES6中的箭头函数","date":"2019-11-28T07:35:25.000Z","updated":"2019-12-02T08:38:35.876Z","comments":true,"path":"2019/11/28/ES6中的箭头函数/","link":"","permalink":"http://yoursite.com/2019/11/28/ES6中的箭头函数/","excerpt":"","text":"前言什么是箭头函数ES6标准新增了一种新的函数：Arrow Function（箭头函数）。箭头函数相当于匿名函数，并且简化了函数定义。箭头函数的语法： 1(parameters) =&gt; &#123; statements &#125; 我们来举一个常规的例子 1234567891011// 使用常规语法定义函数function funcName(params) &#123; return params * 3; &#125;funcName(1);// 3// 使用箭头函数定义函数var funcName = (params) =&gt; params * 3funcName(1);// 3 我们可以清晰得看到，只须一行代码就可以搞定一个函数，简化了函数定义，书写匿名函数的时候更加方便，在代码书写过程中多处可以使用到箭头函数。 语法解析123456789101112// 通用语法(parameters) =&gt; &#123; statements &#125;// 只有一个参数时，可以省略小括号parameters =&gt; &#123; statements &#125;// 没有参数时，简化为() =&gt; &#123;statements &#125;// 返回值只有一个表达式时，可以省略大括号parameters =&gt; expression//特殊例子，返回带有大括号的单表达式x =&gt; &#123; foo: x &#125; // errorx =&gt; (&#123; foo: x &#125;) // 加上小括号，ok 箭头函数与普通函数的区别箭头函数123 let fun = () =&gt; &#123; console.log('lalalala');&#125; 普通函数1234 function fun() &#123; console.log('lalla');&#125;&#125; 箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种只包含一个表达式，连{ … }和return都省略掉了。还有一种可以包含多条语句，这时候就不能省略{ … }和return。 1. 箭头函数没有 prototype(原型),所以箭头函数本身没有 this12let a = () =&gt;&#123;&#125;;console.log(a.prototype); // undefined 2. 箭头函数的this指向在定义的时候继承自外层第一个普通函数的this。下面例子中在一个函数中定义箭头函数，然后在另一个函数中执行箭头函数。 12345678910111213 let a, barObj = &#123; msg: 'bar的this指向' &#125;; fooObj = &#123; msg: 'foo的this指向' &#125;; bar.call(barObj); // 将bar的this指向barObj foo.call(fooObj); // 将foo的this指向fooObj function foo() &#123; a(); // 结果：&#123; msg: 'bar的this指向' &#125; &#125; function bar() &#123; a = () =&gt; &#123; console.log(this, 'this指向定义的时候外层第一个普通函数'); // &#125;; // 在bar中定义 this继承于bar函数的this指向&#125; 从上面的例子中可以得到两点1. 箭头函数的this指向定义时所在的外层第一个普通函数，跟使用位置没有关系。2. 被继承的普通函数的this指向改变，箭头函数的this指向会跟着改变 3. 不能直接修改箭头函数的this指向上个例子中的foo函数修改一下，尝试直接修改箭头函数的this指向。 1234 let fnObj = &#123; msg: '尝试直接修改箭头函数的this指向' &#125;; function foo() &#123; a.call(fnObj); // 结果：&#123; msg: 'bar的this指向' &#125;&#125; 很明显，call显示绑定this指向失败了，包括aaply、bind都一样。所以箭头函数不能直接修改它的this指向幸运的是，我们可以通过间接的形式来修改箭头函数的指向：去修改被继承的普通函数的this指向，然后箭头函数的this指向也会跟着改变，这在上一个例子中有演示。 1bar.call(barObj); // 将bar普通函数的this指向barObj 然后内部的箭头函数也会指向barObj 4. 箭头函数是匿名函数，不能作为构造函数，不能使用new1234var B = ()=&gt;&#123; value:1;&#125;var b = new B(); //TypeError: B is not a constructor 无论箭头函数的thsi指向哪里，使用new调用箭头函数都会报错，因为箭头函数没有constructor 5.箭头函数的this指向全局，使用arguments会报未声明的错误如果箭头函数的this指向window(全局对象)使用arguments会报错，未声明arguments。 1234let b = () =&gt; &#123;console.log(arguments);&#125;;b(1, 2, 3, 4); // Uncaught ReferenceError: arguments is not defined 箭头函数的this指向普通函数时,它的argumens继承于该普通函数上面是第一种情况：箭头函数的this指向全局对象，会报arguments未声明的错误。 第二种情况是：箭头函数的this如果是指向普通函数，它的arguments继承于该普通函数。 12345678910111213function bar() &#123; console.log(arguments); // ['外层第二个普通函数的参数'] bb('外层第一个普通函数的参数'); function bb() &#123; console.log(arguments); // [\"外层第一个普通函数的参数\"] let a = () =&gt; &#123; console.log(arguments, 'arguments继承this指向的那个普通函数'); // [\"外层第一个普通函数的参数\"] &#125;; a('箭头函数的参数'); // this指向bb &#125;&#125;bar('外层第二个普通函数的参数'); rest参数获取函数的多余参数这是ES6的API，用于获取函数不定数量的参数数组，这个API是用来替代arguments的，API用法如下： 1234 let a = (first, ...abc) =&gt; &#123; console.log(first, abc); // 1 [2, 3, 4]&#125;;a(1, 2, 3, 4); 上面的例子展示了，获取函数除了第一个确定的参数，以及用一个变量接收其他剩余参数的示例。也可以直接接收函数的所有参数，rest参数的用法相对于arguments的优点： 箭头函数和普通函数都可以使用。 更加灵活，接收参数的数量完全自定义。 可读性更好 rest是一个真正的数组，可以使用数组的API。因为arguments是一个类数组的对象，有些人以为它是真正的数组，所以会出现以下场景：1arguments.push(0); // arguments.push is not a function 如上，如果我们需要使用数组的API，需要使用扩展符/Array.from来将它转换成真正的数组: 1arguments = [...arguments]; 或者 ：arguments = Array.from(arguments); rest参数有两点需要注意： rest必须是函数的最后一位参数： 1234 let a = (first, ...rest, three) =&gt; &#123; console.log(first, rest,three); // 报错：Rest parameter must be last formal parameter&#125;;a(1, 2, 3, 4); 函数的length属性，不包括 rest 参数 12(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 6.箭头函数不支持new.targetnew.target是ES6新引入的属性，普通函数如果通过new调用，``new.target`会返回该函数的引用。此属性主要：用于确定构造函数是否为new调用的。 箭头函数的this指向全局对象，在箭头函数中使用箭头函数会报错 1234let a = () =&gt; &#123;console.log(new.target); // 报错：new.target 不允许在这里使用&#125;;a(); 箭头函数的this指向普通函数，它的new.target就是指向该普通函数的引用。 1234567 new bb(); function bb() &#123; let a = () =&gt; &#123; console.log(new.target); // 指向函数bb：function bb()&#123;...&#125; &#125;; a();&#125; 使用箭头函数需要注意什么1. 在对象上定义函数 123456789 const test = &#123; array: [1, 2, 3], sum: () =&gt; &#123; console.log(this === window); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;test.sum();// TypeError: Cannot read property 'reduce' of undefined 原因就是，箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。 对象方法内的this指向调用这个方法的对象，如果使用箭头函数，this和对象方法在调用的时候所处环境的this值一致。因为 test.sum()是在全局环境下进行调用，此时this指向全局。解决方法也很简单，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的。 123456789 const test = &#123; array: [1, 2, 3], sum() &#123; console.log(this === test); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); &#125;&#125;;test.sum();// 6 2. 定义原型方法在对象原型上定义函数也是遵循着一样的规则 1234567891011 function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = () =&gt; &#123; console.log(this === window); // =&gt; true return this.name;&#125;;const cat = new Person('Mew');cat.sayName(); // =&gt; undefined 使用传统的函数表达式就能解决问题 1234567891011 function Person(name) &#123; this.name = name;&#125;Person.prototype.sayName = function() &#123; console.log(this === Person); // =&gt; true return this.name;&#125;;const cat = new Person('Mew');cat.sayName(); // =&gt; Mew 3. 定义事件回调函数this是JS中非常强大的特点，他让函数可以根据其调用方式动态的改变上下文，然后箭头函数直接在声明时就绑定了this对象，所以不再是动态的。 在客户端，在DOM元素上绑定事件监听函数是非常普遍的行为，在DOM事件被触发时，回调函数中的this指向该DOM，但是，箭头函数在声明的时候就绑定了执行上下文，要动态改变上下文是不可能的，在需要动态上下文的时候它的弊端就凸显出来: 12345const button = document.getElementById('myButton');button.addEventListener('click', () =&gt; &#123; console.log(this === window); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 因为这个回调的箭头函数是在全局上下文中被定义的，所以他的this是window。换句话说就是，箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。 使用函数表达式就可以在运行时动态的改变 this： 12345const button = document.getElementById('myButton');button.addEventListener('click', function() &#123; console.log(this === button); // =&gt; true this.innerHTML = 'Clicked button';&#125;); 4. 定义构造函数如果使用箭头函数会报错。显然，箭头函数是不能用来做构造函数。 12345const Message = (text) =&gt; &#123; this.text = text;&#125;;const helloMessage = new Message('Hello World!');// Throws \"TypeError: Message is not a constructor\" 理论上来说也是不能这么做的，因为箭头函数在创建时this对象就绑定了，更不会指向对象实例。 5.太简短的（难以理解）函数箭头函数可以让语句写的非常的简洁，但是一个真实的项目，一般由多个开发者共同协作完成，箭头函数有时候并不会让人很好的理解： 1234const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b;const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6 代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么。 这个函数的作用就是当只有一个参数a时，返回接受一个参数b返回a*b的函数，接收两个参数时直接返回乘积。 为了让这个函数更好的让人理解，我们可以为这个箭头函数加一对花括号，并加上return语句，或者直接使用函数表达式： 123456789101112function multiply(a, b) &#123; if (b === undefined) &#123; return function(b) &#123; return a * b; &#125; &#125; return a * b;&#125;const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6 总结毫无疑问，箭头函数带来了很多便利。恰当的使用箭头函数可以让我们避免使用早期的.bind()函数或者需要固定上下文的地方并且让代码更加简洁。 箭头函数也有一些不便利的地方。我们在需要动态上下文的地方不能使用箭头函数：定义对象方法、定义原型方法、定义构造函数、定义事件回调函数。在其他情况下，请尽情的使用箭头函数。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}],"author":"刘涛"},{"title":"win10安装mysql数据库","slug":"win10安装mysql数据库","date":"2019-11-28T06:51:58.000Z","updated":"2019-12-02T08:29:53.092Z","comments":true,"path":"2019/11/28/win10安装mysql数据库/","link":"","permalink":"http://yoursite.com/2019/11/28/win10安装mysql数据库/","excerpt":"","text":"Windows安装mysql数据库服务一官网上下载压缩包，并解压至本地磁盘 打开我们刚刚解压的文件夹，在bin目录下，创建一个my.ini文件，内容如下： 1234567891011121314151617[client]# 设置mysql客户端默认字符集default-character-set=utf8 [mysqld]# 设置3306端口port = 3306# 设置mysql的安装目录basedir=C:\\\\mysql\\\\mysql-8.0.11# 设置 mysql数据库的数据的存放目录，MySQL 8+ 不需要以下配置，系统自己生成即可，否则有可能报错# datadir=C:\\\\mysql\\\\mysql-8.0.11\\\\sqldata# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB 二先补充常用Dos命令 dir1234567891011121314151617181920212223242526无参数：查看当前所在目录的文件和文件夹。/s：查看当前目录已经其所有子目录的文件和文件夹。/a：查看包括隐含文件的所有文件。/ah：只显示出隐含文件。/w：以紧凑方式（一行显示5个文件）显示文件和文件夹。/p：以分页方式（显示一页之后会自动暂停）显示。|more：前面那个符号是“\\”上面的那个，叫做重定向符号，就是把一个命令的结果输出为另外一个命令的参数。more也是一个命令，dir /w |more得到的结果和dir /w /p的结果是一样的。其他的参数大家可以用：dir/?查看。2 cdcd 目录名：进入特定的目录。如果看到有个目录显示为：abcdef ghi 就输入：cdabcdef.ghi进入该目录。cd\\ 退回到根目录。cd..退回到上一级目录。3 md rdmd 目录名：建立特定的文件夹。 （dos下面习惯叫目录，win下面习惯叫文件夹。呵呵！）rd 目录名：删除特定的文件夹。4 cls清除屏幕。5 copycopy 路径\\文件名 路径\\文件名 ：把一个文件拷贝到另一个地方。6 movemove 路径\\文件名 路径\\文件名 ：把一个文件移动（就是剪切+复制）到另一个地方。 先以管理员身份运行cmd，进入mysql安装路径下bin文件夹目录 进入目录后执行以下命令初始化数据库： 1mysqld --initialize --console # 初始化数据库 运行之后会生成第一次初始化mysql数据库root用户随机生成的密码，红色框中的字符串为登录root用户使用的密码，请注意该密码登录时一定要加上双引号，不然无法登录成功。 目录下运行 : 1234567891011121314mysqld --install # mysql安装命令``` 若报错，信息如下：Install/Remove of the Service Denied 请正确选择“用管理员身份打开”打开cmd.exe程序出现信息如下```mysqld : 无法将“mysqld”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ mysqld install+ ~~~~~~ + CategoryInfo : ObjectNotFound: (mysqld:String) [], CommandNotFoundException + FullyQualifiedErrorId : CommandNotFoundException 请使用.\\mysqld --install命令解决 出现信息如： Service successfully installed. 则说明安装成功 启动mysql服务 1net start mysql # 启动mysql服务 登录mysql 1234mysql -uroot -p //回车输入密码：&quot;w3sYN%WxSfsH&quot;# 登录mysql # 其格式为：mysql -u 用户名 -p 密码","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}],"author":"胡豪"},{"title":"浅谈v-slot","slug":"浅谈v-slot","date":"2019-11-14T05:27:30.000Z","updated":"2019-12-02T08:38:35.878Z","comments":true,"path":"2019/11/14/浅谈v-slot/","link":"","permalink":"http://yoursite.com/2019/11/14/浅谈v-slot/","excerpt":"","text":"前言Vue 代码中的 slot 是什么，简单来说就是插槽。&lt;slot&gt;元素作为组件模板之中的内容分发插槽，传入内容后 &lt;slot&gt; 元素自身将被替换。 看了上面这句官方解释，可能一样不知道 slot 指的是什么，那么就来看看在 Vue 中，什么时候你需要用到 slot 。 举例：一个组件的展示层你需要做到大体结构固定，但其内的部分结构可变，样式表现不固定。例如 Button 中是否显示 icon ，或者 Modal 框的中间内容展示区域的变化等，要通过子组件自己实现是不可能的。组件并不直接支持 HTML DOM 结构的传递，此时就可以通过使用 slot 作为 HTML 结构的传递入口来解决问题。 什么是插槽 插槽（Slot）是Vue提出来的一个概念，正如名字一样，插槽用于决定将所携带的内容，插入到指定的某个位置，从而使模板分块，具有模块化的特质和更大的重用性。 插槽显不显示、怎样显示是由父组件来控制的，而插槽在哪里显示就由子组件来进行控制 插槽的作用让用户可以拓展组件，去更好地复用组件和对其做定制化处理。举一些例子，比如布局组件、表格列、下拉选项 怎么使用插槽默认插槽子组件编写：在组件中添加 &lt;slot&gt; 元素，来确定渲染的位置。 1234567891011// 子组件 &lt;template&gt; &lt;div class=\"content\"&gt; &lt;!-- 默认插槽 --&gt; &lt;header class=\"text\"&gt; &lt;!-- slot 的后备内容：为一个插槽设置具体后备（默认）内容是很有用的， 当父组件不添加任何插槽内容时，默认渲染该后备内容的值。 --&gt; &lt;slot&gt;默认值&lt;/slot&gt; &lt;/header&gt; &lt;/div&gt; &lt;/template&gt; 父组件编写：任何没有被包裹在带有 v-slot 的 &lt;template&gt;中的内容都会被视为默认插槽的内容。当子组件只有默认插槽时， &lt;v-slot&gt; 标签可以直接用在组件上，也就是独占默认插槽的写法 1234567891011121314151617181920// 父组件&lt;template&gt; &lt;div class=\"container\"&gt; &lt;!-- 默认插槽--&gt; &lt;child&gt; 任意内容 &lt;template&gt;内容&lt;/template&gt; 中间内容 &lt;!-- &lt;template v-slot:default&gt;但如果你定义了 default 之后，其他内容就不会出现了， 原理同上，不能重复定义&lt;/template&gt; --&gt; &lt;/child&gt; &lt;!-- 独占默认插槽的缩写 --&gt; &lt;child v-slot=\"slotProps\"&gt; 当只有默认插槽时，此为独占默认插槽的缩写&lt;br&gt; 如果组件中有其他具名插槽，这么写会报错&lt;br&gt; slotProps 取的是，子组件标签 slot 上属性数据的集合 &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 渲染结果： 具名插槽子组件编写：当需要使用多个插槽时，为 &lt;slot&gt; 元素添加 name 属性，来区分不同的插槽，当不填写 name 时，默认为 default 默认插槽。 123456789101112// 子组件 &lt;template&gt; &lt;div class=\"content\"&gt; &lt;!-- 具名插槽 --&gt; &lt;main class=\"text\"&gt; &lt;slot name=\"main\"&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer class=\"text\"&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; 父组件编写：&lt;template&gt; 标签中添加 v-slot:xxx 或者 #xxx 属性的内容， # 代表插槽的缩写。 12345678910111213141516// 父组件&lt;template&gt; &lt;div class=\"container\"&gt; &lt;!-- 具名插槽使用 --&gt; &lt;child&gt; &lt;template v-slot:main&gt; &lt;a href=\"https://www.zcygov.cn\" target=\"_blank\"&gt;导航&lt;/a&gt; &lt;/template&gt; &lt;template #footer&gt;页脚（具名插槽的缩写#）&lt;/template&gt; &lt;template #footer&gt; &lt;!-- v-slot 重复定义同样的 name 后只会加载最后一个定义的插槽内容 --&gt; v-slot只会添加在一个 template 上面 &lt;/template&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt; 渲染结果： 作用域插槽子组件编写：有时让父组件能访问到子组件中的数据是很有用的，我们可以将绑定在 &lt;slot&gt;元素上的特性称为插槽 Prop ，当然也可以传递一些 Function。 12345678910111213141516171819202122232425262728293031// 子组件 &lt;template&gt; &lt;div class=\"content\"&gt; &lt;!-- 作用域插槽 --&gt; &lt;footer class=\"text\"&gt; &lt;slot name=\"footer\" :user=\"user\" :testClick=\"testClick\"&gt; &#123;&#123;user.name&#125;&#125; &lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; name: 'child', data () &#123; return &#123; user: &#123; title: '测试title', name: '测试name' &#125; &#125;; &#125;, methods:&#123; testClick()&#123; // 子组件通用方法，可传递给父组件复用 alert('123'); &#125; &#125; &#125;; &lt;/script&gt; 父组件编写：被绑定的属性的集合对象，在父元素中会被 v-slot:xxx=”slotProps” 或者 #xxx=”slotProps” 接收，xxx 代表具名插槽的 name ，slotProps 为子组件传递的数据对象，可以重命名。 12345678910111213141516171819202122232425262728// 父组件&lt;template&gt; &lt;div class=\"container\"&gt; &lt;!-- 作用域插槽，以及解构插槽 Prop 的写法 --&gt; &lt;child&gt; &lt;template #footer=\"slotProps\"&gt; &#123;&#123;slotProps.user.title&#125;&#125; &lt;button @click=\"slotProps.testClick\"&gt;点我&lt;/button&gt; &lt;/template&gt; &lt;template #footer=\"&#123;user,testClick&#125;\"&gt; &#123;&#123;user.title&#125;&#125;&lt;br&gt; 此为解构插槽prop&lt;br&gt; &lt;!-- 子组件中的通用方法，可传递给父组件复用 --&gt; &lt;button @click=\"testClick\"&gt;点我&lt;/button&gt; &lt;/template&gt; &lt;/child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Child from './component/child.vue';export default &#123; name: 'demo', components: &#123; Child &#125;,&#125;;&lt;/script&gt; 渲染结果： 其它拓展 解构插槽 prop 可以重命名，例如：v-slot=&quot;{ user: person }&quot; 将 user 对象重命名为 person 使用。 解构插槽 prop 可以赋值默认值，例如：v-slot=&quot;{ user = { name: &#39;Guest&#39; } }&quot; 给属性添加自定义后备内容。 动态插槽命名，例如：v-slot:[dynamicSlotName] ，支持命名变量定义。 注意事项 v-slot 只能用在 template 上面，或者是独占默认插槽的写法。 父组件引用时 ，重复定义了 v-slot 的 name 后只会加载最后一个定义的插槽内容。 当子组件只有默认插槽时，才可以使用独占默认插槽的缩写语法，只要出现多个插槽，必须使用完整的基于 template 的语法。 slot 以及 slot-scope 的用法子组件编写1234567891011121314151617181920212223242526272829303132333435// 子组件&lt;template&gt; &lt;div class=\"content\"&gt; &lt;!-- 默认插槽 --&gt; &lt;header class=\"text\"&gt; &lt;slot&gt;默认值&lt;/slot&gt; &lt;/header&gt; &lt;!-- 具名插槽 --&gt; &lt;main class=\"text\"&gt; &lt;slot name=\"main\"&gt;&lt;/slot&gt; &lt;/main&gt; &lt;!-- 作用域插槽 --&gt; &lt;footer class=\"text\"&gt; &lt;slot name=\"footer\" :user=\"user\" :testClick=\"testClick\"&gt; &#123;&#123;user.name&#125;&#125; &lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'child', data () &#123; return &#123; user: &#123; title: '测试title', name: '测试name' &#125; &#125;; &#125;&#125;;&lt;/script&gt; 父组件编写 具名插槽：直接使用 slot 属性，传值为子组件插槽的 name 属性。 作用域插槽：通过 slot-scope 属性来接受子组件传入的属性集合，其他用法一致。 12345678910111213141516171819202122232425262728// 父组件 &lt;template&gt; &lt;div class=\"container\"&gt; &lt;child&gt; &lt;!-- 默认插槽 --&gt; &lt;div&gt;默认插槽&lt;/div&gt; &lt;!-- 具名插槽 --&gt; &lt;div slot=\"main\"&gt;具名插槽&lt;/div&gt; &lt;div slot=\"main\"&gt;具名插槽2&lt;/div&gt; &lt;!-- 作用域插槽 --&gt; &lt;div slot=\"footer\" slot-scope=\"slotProps\"&gt; &#123;&#123;slotProps.user.title&#125;&#125; &lt;/div&gt; &lt;/child&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Child from './component/child.vue'; export default &#123; name: 'demo', components: &#123; Child &#125;, &#125;; &lt;/script&gt; 渲染结果： 注意事项 不同于 v-slot 的是，slot 中同名可以重复定义多次。 slot 可以直接定义在子组件上。 v3.0 版本后不可使用 slot ，建议直接使用 v-slot 。 总结 插槽的 &lt;slot&gt; 的可复用特性，可以用来写一些组件结构固定，内容可替换的组件，例如表格，列表，按钮，弹窗等内容。 插槽可以传递属性值或者 function 的特性，可以在子组件中写一些通用的函数，例如通用的报错提示等，传递给父组件复用。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":"刘涛"},{"title":"gulp入门(三)","slug":"gulp入门（三）","date":"2019-11-13T05:52:14.000Z","updated":"2019-11-25T01:51:42.432Z","comments":true,"path":"2019/11/13/gulp入门（三）/","link":"","permalink":"http://yoursite.com/2019/11/13/gulp入门（三）/","excerpt":"","text":"gulp3改造gulp4gulp3与gulp4的写法存在区别，此篇用来对比整个项目gulpfile.js文件的异同。如果你安装的是gulp3，想升级使用gulp4，可以使用命令npm install gulp@4.0 如果你安装的是gulp4，想h回退使用gulp3，可以使用命令npm install gulp@3.9.1 一下是简单的项目gulpfile.js文件实例gulp@3.9.1版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const gulp = require(\"gulp\");//全局gulpconst uglify = require(\"gulp-uglify\"); //压缩jsconst gulpif = require(\"gulp-if\");//if条件const cssUglify = require('gulp-minify-css');//压缩cssconst gulpclean = require(\"gulp-clean\");//清除文件//过滤条件var conditionJs = function(f) &#123; if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) &#123; return false; &#125; return true;&#125;;var conditionCss = function(f) &#123; if (f.path.indexOf(\".min.css\", f.path.length - \".min.css\".length) !== -1) &#123; return false; &#125; return true;&#125;;gulp.task('clean' , function()&#123; gulp.src([ //'dist', //删除dist整个文件夹 'dist/*', //删除dist下的test写任意子文件夹里的文件 '!package.json' //不删除package.json文件 ] ).pipe(gulpclean());&#125;);gulp.task('html', function () &#123; gulp.src([\"src/*.html\",\"src/favicon.ico\"]) .pipe(gulp.dest(\"dist/\"))&#125;)gulp.task('css',function()&#123; gulp.src('src/css/*.css') .pipe(gulpif(conditionCss, cssUglify())) .pipe(gulp.dest('dist/css'))&#125;)gulp.task('cssmin',['css'], function () &#123; gulp.src('src/css/font/*') .pipe(gulp.dest(\"dist/css/font\"));&#125;)//压缩js文件gulp.task(\"js\", function() &#123; gulp.src(\"src/js/*.js\") .pipe(gulpif(conditionJs, uglify())) .pipe(gulp.dest(\"dist/js\"));&#125;);//拷贝不需要处理js的文件gulp.task('jsmin',['js'], function () &#123; gulp.src('src/js/layer/**') .pipe(gulp.dest(\"dist/js/layer\"));&#125;)gulp.task('copyImage',['js'], function () &#123; gulp.src('src/img/**/* ') .pipe(gulp.dest(\"dist/img\"));&#125;)gulp.task(\"build\", [\"html\",\"cssmin\",\"jsmin\",\"copyImage\"]); gulp@4版本123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const gulp = require(\"gulp\");//全局gulpconst uglify = require(\"gulp-uglify\"); //压缩jsconst gulpif = require(\"gulp-if\");//if条件const cssUglify = require('gulp-minify-css');//压缩cssconst gulpclean = require(\"gulp-clean\");//清除文件//过滤条件var conditionJs = function(f) &#123; if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) &#123; return false; &#125; return true;&#125;;var conditionCss = function(f) &#123; if (f.path.indexOf(\".min.css\", f.path.length - \".min.css\".length) !== -1) &#123; return false; &#125; return true;&#125;;//执行任务gulp.task('clean' , function()&#123; return gulp.src([ //'dist', //删除dist整个文件夹 'dist/*', //删除dist下的test写任意子文件夹里的文件 '!package.json' //不删除package.json文件 ] ).pipe(gulpclean());&#125;);gulp.task('html', function () &#123; return gulp.src([\"src/*.html\",\"src/favicon.ico\"]) .pipe(gulp.dest(\"dist/\"))&#125;)gulp.task('css',function()&#123; return gulp.src('src/css/*.css') .pipe(gulpif(conditionCss, cssUglify())) .pipe(gulp.dest('dist/css'))&#125;)gulp.task('cssmin',gulp.series('css', function () &#123; return gulp.src('src/css/font/*') .pipe(gulp.dest(\"dist/css/font\"));&#125;))//压缩js文件gulp.task(\"js\", function() &#123; return gulp.src(\"src/js/*.js\") .pipe(gulpif(conditionJs, uglify())) .pipe(gulp.dest(\"dist/js\"));&#125;);//拷贝不需要处理js的文件gulp.task('jsmin',gulp.series('js', function () &#123; return gulp.src('src/js/layer/**') .pipe(gulp.dest(\"dist/js/layer\"));&#125;))gulp.task('copyImage', function () &#123; return gulp.src('src/img/**/* ') .pipe(gulp.dest(\"dist/img\"));&#125;)gulp.task('build',gulp.series('clean',gulp.parallel('html','cssmin','jsmin','copyImage'))); 总结gulp系列到此为止，介绍的也是一些常规的基础用法，万丈高楼平地起，高楼怎么造就看砖头怎么码了。有兴趣的去看看前辈grunt click to link","categories":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}],"author":"胡豪"},{"title":"web前端常见的安全问题","slug":"web前端常见的安全问题","date":"2019-11-12T05:59:13.000Z","updated":"2019-11-13T05:56:05.859Z","comments":true,"path":"2019/11/12/web前端常见的安全问题/","link":"","permalink":"http://yoursite.com/2019/11/12/web前端常见的安全问题/","excerpt":"","text":"前言在互联网时代，数据安全与个人隐私受到了前所未有的挑战，各种新奇的攻击技术层出不穷。如何才能更好地保护我们的数据？本文主要侧重于分析几种常见的攻击的类型以及防御的方法。 SQL注入SQL注入是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，或者利用潜在的数据库漏洞进行攻击。 1.SQL注入的原理我们先看看下面这个例子来说明其原理： 12345&lt;form action=\"/login\" method=\"POST\"&gt; &lt;p&gt;Username: &lt;input type=\"text\" name=\"username\" /&gt;&lt;/p&gt; &lt;p&gt;Password: &lt;input type=\"password\" name=\"password\" /&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/p&gt;&lt;/form&gt; 后端的 SQL 语句可能是如下这样的： 1234567let querySQL = ` SELECT * FROM user WHERE username='$&#123;username&#125;' AND psw='$&#123;password&#125;'`;// 接下来就是执行 sql 语句... 这是我们经常见到的登录页面，但是如果有一个恶意的攻击者输入的用户名是admin’ –，密码随意输入，就可以直接登入系统了。why! —-这就是SQL注入我们之前预想的SQL 语句是: SELECT * FROM user WHERE username=’admin’ AND psw=’password’但是恶意攻击者用奇怪用户名将你的 SQL 语句变成了如下形式： SELECT * FROM user WHERE username=’admin’ –’ AND psw=’xxxx’在 SQL 中,’ –是闭合和注释的意思，– 是注释后面的内容的意思，所以查询语句就变成了： SELECT * FROM user WHERE username=’admin’ 所谓的万能密码，本质上就是SQL注入的一种利用方式。一次SQL注入的过程包括以下几个过程： 获取用户请求参数 拼接到代码中 SQL语句按照我们构造参数的语义执行成功 SQL注入的必备条件1.可以控制输入的数据2.服务器要执行的代码拼接了控制的数据 我们会发现SQL注入流程中与正常请求服务器类似，只是黑客控制了数据，构造了SQL查询，而正常的请求不会SQL查询这一步，SQL注入的本质:数据和代码未分离，即数据当做了代码来执行。 2.危害 获取数据库信息 管理员后台用户名和密码 获取其它数据库敏感信息：用户名、密码、手机号、身份证、银行卡信息…… 整个数据库：脱裤 获取服务器权限 植入Webshell，获取服务器后门 读取服务器敏感文件 3.如何防御 严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害 后端代码检查输入的数据是否符合预期，严格限制变量的类型，例如使用正则表达式进行一些匹配处理。 对进入数据库的特殊字符（’，”，，&lt;，&gt;，&amp;，*，; 等）进行转义处理，或编码转换。基本上所有的后端语言都有对字符串进行转义处理的方法，比如 lodash 的 lodash._escapehtmlchar 库。 所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中，即不要直接拼接 SQL 语句。例如 Node.js 中的 mysqljs 库的 query 方法中的 ? 占位参数。 XSSXSS (Cross-Site Scripting)，跨站脚本攻击，因为缩写和 CSS重叠，所以只能叫 XSS。跨站脚本攻击是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。 跨站脚本攻击有可能造成以下影响: 利用虚假输入表单骗取用户个人信息 利用脚本窃取用户Cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。 显示伪造的文章或图片XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。 XSS 的攻击方式千变万化，但还是可以大致细分为几种类型。 1.非持久型 XSS（反射型 XSS ）非持久型 XSS 漏洞，一般是通过给别人发送带有恶意脚本代码参数的 URL，当 URL 地址被打开时，特有的恶意代码参数被 HTML 解析、执行。 举一个例子，比如页面中包含有以下代码： 12345678910&lt;select&gt; &lt;script&gt; document.write('' + '&lt;option value=1&gt;' + location.href.substring(location.href.indexOf('default=') + 8) + '&lt;/option&gt;' ); document.write('&lt;option value=2&gt;English&lt;/option&gt;'); &lt;/script&gt;&lt;/select&gt; 攻击者可以直接通过 URL (类似：https://xxx.com/xxx?default=console.log(document.cookie)) 注入可执行的脚本代码。不过一些浏览器如Chrome其内置了一些XSS过滤器，可以防止大部分反射型XSS攻击。非持久型 XSS 漏洞攻击有以下几点特征： 即时性，不经过服务器存储，直接通过 HTTP 的 GET 和 POST 请求就能完成一次攻击，拿到用户隐私数据。 攻击者需要诱骗点击,必须要通过用户点击链接才能发起。 反馈率低，所以较难发现和响应修复。 盗取用户敏感保密信息。 为了防止出现非持久型 XSS 漏洞，需要确保这么几件事情： Web 页面渲染的所有内容或者渲染的数据都必须来自于服务端。 尽量不要从 URL，document.referrer，document.forms 等这种 DOM API 中获取数据直接渲染。 尽量不要使用 eval, new Function()，document.write()，document.writeln()，window.setInterval()，window.setTimeout()，innerHTML，document.createElement() 等可执行字符串的方法。 如果做不到以上几点，也必须对涉及 DOM 渲染的方法传入的字符串参数做 escape 转义。 前端渲染的时候对任何的字段都需要做 escape 转义编码。 2.持久型XSS(存储型XSS)持久型 XSS 漏洞，一般存在于 Form 表单提交等交互功能，如文章留言，提交文本信息等，黑客利用的 XSS 漏洞，将内容经正常功能提交进入数据库持久保存，当前端页面获得后端从数据库中读出的注入代码时，恰好将其渲染执行。 举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 主要注入页面方式和非持久型 XSS 漏洞类似，只不过持久型的不是来源于 URL，referer，forms 等，而是来源于后端从数据库中读出来的数据 。持久型 XSS 攻击不需要诱骗点击，黑客只需要在提交表单的地方完成注入即可，但是这种 XSS 攻击的成本相对还是很高。攻击成功需要同时满足以下几个条件： POST请求提交表单后端没做转义直接入库。 后端从数据库中取出数据没做转义直接输出给前端。 前端拿到后端数据没做转义直接渲染成 DOM。 持久型 XSS 有以下几个特点： 持久性，植入在数据库中 盗取用户敏感私密信息 危害面积广 3.如何防御对于 XSS 攻击来说，通常有两种方式可以用来防御。 1)CSPCSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 这里以设置 HTTP Header 来举例： 只允许加载本站资源Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片Content-Security-Policy: img-src https://* 允许加载任何来源框架Content-Security-Policy: child-src ‘none’ 如需了解更多属性，请查看Content-Security-Policy文档对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。 2)转义字符用户的输入永远不可信任的，最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义。 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/\"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\\//g, '&amp;#x2F;') return str&#125; 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require('xss')let html = xss('&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;')// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert(\"xss\");&amp;lt;/script&amp;gt;console.log(html) 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。 3) HttpOnly Cookie。 这是预防XSS攻击窃取用户cookie最有效的防御手段。Web应用程序在设置cookie时，将其属性设为HttpOnly，就可以避免该网页的cookie被客户端恶意JavaScript窃取，保护用户cookie信息。 CSRF CSRF(Cross Site Request Forgery)，即跨站请求伪造，是一种常见的Web攻击，它利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。 1. CSRF攻击的原理 完成 CSRF 攻击必须要有三个条件： 用户已经登录了站点 A，并在本地记录了 cookie 在用户没有登出站点 A 的情况下（也就是 cookie 生效的情况下），访问了恶意攻击者提供的引诱危险站点 B (B 站点要求访问站点A)。 站点 A 没有做任何 CSRF 防御 我们来看一个例子： 当我们登入转账页面后，突然眼前一亮惊现”XXX隐私照片，不看后悔一辈子”的链接，耐不住内心躁动，立马点击了该危险的网站（页面代码如下图所示），但当这页面一加载，便会执行submitForm这个方法来提交转账请求，从而将10块转给黑客。 2.如何防御防范 CSRF 攻击可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token 1)SameSite可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 2)Referer CheckHTTP Referer是header的一部分，当浏览器向web服务器发送请求时，一般会带上Referer信息告诉服务器是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。可以通过检查请求的来源来防御CSRF攻击。正常请求的referer具有一定规律，如在提交表单的referer必定是在该页面发起的请求。所以通过检查http包头referer的值是不是这个页面，来判断是不是CSRF攻击。 但在某些情况下如从https跳转到http，浏览器处于安全考虑，不会发送referer，服务器就无法进行check了。若与该网站同域的其他网站有XSS漏洞，那么攻击者可以在其他网站注入恶意脚本，受害者进入了此类同域的网址，也会遭受攻击。出于以上原因，无法完全依赖Referer Check作为防御CSRF的主要手段。但是可以通过Referer Check来监控CSRF攻击的发生。 3)Anti CSRF Token目前比较完善的解决方案是加入Anti-CSRF-Token。即发送请求时在HTTP 请求中以参数的形式加入一个随机产生的token，并在服务器建立一个拦截器来验证这个token。服务器读取浏览器当前域cookie中这个token值，会进行校验该请求当中的token和cookie当中的token值是否都存在且相等，才认为这是合法的请求。否则认为这次请求是违法的，拒绝该次服务。 这种方法相比Referer检查要安全很多，token可以在用户登陆后产生并放于session或cookie中，然后在每次请求时服务器把token从session或cookie中拿出，与本次请求中的token 进行比对。由于token的存在，攻击者无法再构造出一个完整的URL实施CSRF攻击。但在处理多个页面共存问题时，当某个页面消耗掉token后，其他页面的表单保存的还是被消耗掉的那个token，其他页面的表单提交时会出现token错误。 4)验证码应用程序和用户进行交互过程中，特别是账户交易这种核心步骤，强制用户输入验证码，才能完成最终请求。在通常情况下，验证码够很好地遏制CSRF攻击。但增加验证码降低了用户的体验，网站不能给所有的操作都加上验证码。所以只能将验证码作为一种辅助手段，在关键业务点设置验证码。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[],"author":"刘涛"},{"title":"gulp入门(二)","slug":"gulp入门（二）","date":"2019-11-11T08:54:02.000Z","updated":"2019-11-25T01:14:57.695Z","comments":true,"path":"2019/11/11/gulp入门（二）/","link":"","permalink":"http://yoursite.com/2019/11/11/gulp入门（二）/","excerpt":"","text":"实践过程遇到的问题 压缩jsgulp 压缩遇到已经压缩过的 min.js 文件无法再继续压缩会报错跳除压缩程序;解决方法一：先把压缩过的js文件提前剪切到dist/js文件下;执行完gulp要记得吧dist里的js覆盖原项目js文件夹当然这种手动的方法比较麻烦，使用gulp插件自动化处理更加优雅解决方法二：添加gulp-if判断 1234567891011121314151617var condition = function(f) &#123; //这里网上用的是endsWith()方法虽然方便，但是是es6的方法，es5下使用indexOf也同样可以实现 if (f.path.indexOf(\".min.js\", f.path.length - \".min.js\".length) !== -1) &#123; return false; &#125; return true;&#125;;//压缩js文件gulp.task(\"jsmin\", function() &#123; //找到文件 return gulp.src(\"src/js/*.js\") //压缩文件 .pipe(gulpif(condition, uglify())) //保存压缩后的文件 .pipe(gulp.dest(\"dist/js\"));&#125;); 知识补充：includes()：返回布尔值，表示是否找到了参数字符串；startsWith()：返回布尔值，表示参数字符串是否在查找字符串的头部；endsWith()：返回布尔值，表示参数字符串是否在查找字符串的尾部。12345let str = 'Hello world!'; str.startsWith('Hello') // truestr.endsWith('!') // truestr.includes('o') // true 同时这三个方法都支持第二个参数，表示开始搜索的位置。endsWith 的行为与其他两个方法有所不同，它针对的是前n个字符,其他两个方法都是针对从第n个位置（不包含n）直到字符串结束。 12345let str = 'Hello world!'; str.startsWith('world', 6) // truestr.endsWith('Hello', 5) // truestr.includes('Hello', 6) // false gulp4与gulp3gulp3的写法运行遇到运行报错12The following tasks did not complete: scriptDid you forget to signal async completion? 主要原因是一开始装的gulp是gulp4版本，gulp3版本使用原代码就行 原代码： 12345678910//压缩js文件gulp.task(\"script\", function() &#123; //找到文件 gulp .src(\"js/*.js\") //压缩文件 .pipe(uglify()) //保存压缩后的文件 .pipe(gulp.dest(\"dist/js\"));&#125;); 解决方法一： 1234567891011//压缩js文件gulp.task(\"script\", done =&gt; &#123; //找到文件 gulp .src(\"js/*.js\") //压缩文件 .pipe(uglify()) //保存压缩后的文件 .pipe(gulp.dest(\"dist/js\")); done();&#125;); 解决方法二： 123456789//压缩js文件gulp.task(\"script\", function() &#123; //找到文件 return gulp .src(\"js/*.js\") //压缩文件 .pipe(uglify()) //保存压缩后的文件 .pipe(gulp.dest(\"dist/js\")); &#125;); 关于gulp3与gulp4版本对于写串行方式运行任务也有不同gulp3，数组方式，例如： 12345678gulp.task(\"build\", [\"html\",\"cssmin\",\"jsmin\",\"copyImage\"]);``` 和```jsgulp.task('jsmin',['js'], function () &#123; gulp.src('src/js/layer/**') .pipe(gulp.dest(\"dist/js/layer\"));&#125;)) gulp4，需用gulp.series，例如： 1gulp.task('build',gulp.series(gulp.parallel('html','cssmin','jsmin','copyImage'))); 和 1234gulp.task('jsmin',gulp.series('js', function () &#123; return gulp.src('src/js/layer/**') .pipe(gulp.dest(\"dist/js/layer\"));&#125;)) 压缩图片报错一开始怎么试都报错，以为自己代码写错了，后面网上找了半天代码应该没有问题 12345678910//图片压缩gulp.task(\"imagemin\",function()&#123; return gulp.src(\"src/img/**/*.&#123;png,jpg,gif,ico&#125;\") .pipe(imagemin()) .on('error', function(err)&#123; // 报错防止中断 console.error(err) this.emit('end'); &#125;) .pipe(gulp.dest(\"dist/img\")); //放入到dist目录下面的images文件&#125;) 这个时候我想代码没问题，难道是依赖出问题了，我就把node_modules全删了再装一遍，图片压缩就不报错了，可以输出压缩好的图片文件。","categories":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}],"author":"胡豪"},{"title":"gulp入门(一)","slug":"gulp入门（一）","date":"2019-11-07T05:31:50.000Z","updated":"2019-11-13T05:54:30.738Z","comments":true,"path":"2019/11/07/gulp入门（一）/","link":"","permalink":"http://yoursite.com/2019/11/07/gulp入门（一）/","excerpt":"","text":"前言说到前端常见的构建工具，有Webpack/Grunt/Gulp这里简述一下它们都是干什么的：Grunt 和 Gulp 是非常相似的东西，能实现的功能是一样的，当然你可能 Gulp 听的 Grunt 多，通俗的讲，可以把 Gulp 看作 Grunt 的加强版。相对于 Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。Webpack 是一个打包模块化 JavaScript 的工具，在 Webpack 里一切文件皆模块(JavaScript、CSS、SCSS、图片、模板)，通过 Loader 转换文件，通过 Plugin 注入钩子，最后输出由多个模块组合成的文件。经过 Webpack 的处理，最终会输出浏览器能使用的静态资源。使用Vue的小伙伴再熟悉不过，Webpack 专注于构建模块化项目。Webpack的缺点也很明显是只能用于采用模块化开发的项目。今天重点讲gulp； Gulp是什么？Gulp是前端自动化的工具，它能用来做很多很多繁琐的事情，大大便利了前端开发工作流程 搭建web服务器 使用预处理器Sass，Less 压缩优化，可以压缩JS CSS Html 图片 自动将更新变化的代码实时显示在浏览器 前端测试…… 快速入门Gulp 是一个基于流的自动化构建工具。 除了可以管理和执行任务，还支持监听文件、读写文件。Gulp 被设计得非常简单，只通过下面5种个方法就可以胜任几乎所有构建场景： 通过 gulp.task 注册一个任务； 通过 gulp.run 执行任务； 通过 gulp.watch 监听文件变化； 通过 gulp.src 读取文件； 通过 gulp.dest 写文件。 简单语法 gulp.task(name[,deps],fn)说明：定义一个gulp任务name: 类型(必填)：String 指定任务的名称（不应该有空格）deps:类型(可选)：StringArray，该任务依赖的任务（执行name任务要先去执行的任务） 123456gulp.task('A' , function()&#123; console.log('A') &#125;);gulp.task('B' , ['A'] , function()&#123; //运行B之前先去运行A console.log('B')&#125;); gulp.src(globs[, options])说明：src方法指定需要处理的源文件路径，返回当前文件流至可用插件 globs: 类型(必填)：String/StringArray 需要处理的源文件匹配符路径 通配符路径匹配示例： “src/a.js”：指定具体文件； “”：匹配所有文件 例：src/.js(包含src下的所有js文件)； “”：匹配0个或多个子文件夹 例：src//.js(包含src的0个或多个子文件夹下的js文件)； “{}”：匹配多个属性 例：src/{a,b}.js(包含a.js和b.js文件) src/.{jpg,png,gif}(src下的所有jpg/png/gif文件)； “!”：排除文件 例：!src/a.js(不包含src下的a.js文件)； options:类型(可选)：Object 三个属性 buffer read base options.buffer：类型：Boolean 默认：true 设置为false，将返回file.content的流并且不缓冲文件，处理大文件时非常有用； options.read： 类型：Boolean 默认：true 设置false，将不执行读取文件操作，返回null； options.base： 类型：String 设置输出路径以某个路径的某个组成部分为基础向后拼接 1234567gulp.src('client/js/**/*.js') .pipe(minify()) .pipe(gulp.dest('build')); gulp.src('client/js/**/*.js', &#123; base: 'client' &#125;) .pipe(minify()) .pipe(gulp.dest('build')); gulp.dest(path[,options])说明：watch方法用于监听文件变化，一被变化就执行指定任务glob： 需要处理的源文件匹配符路径。类型(必填)：String or StringArray；opts： 类型(可选)：Object 具体参看https://github.com/shama/gaze；tasks： 类型(必填)：StringArray 需要执行的任务的名称数组；cb(event)： 类型(可选)：Function 每个文件变化执行的回调函数； 1.pipe(gulp.dest('build')); gulp.watch(glob[,opts],tasks) or gulp.task(glob [,opts ,cd])说明：watch方法用于监听文件变化，一被变化就执行指定任务glob： 需要处理的源文件匹配符路径。类型(必填)：String or StringArray；opts： 类型(可选)：Object 具体参看https://github.com/shama/gaze；tasks： 类型(必填)：StringArray 需要执行的任务的名称数组；cb(event)： 类型(可选)：Function 每个文件变化执行的回调函数； 如何写首先创建 gulpfile 文件利用任何文本编辑器在项目大的根目录下创建一个名为 gulpfile.js 的文件各个API就不讲了，官网都有，Gulp官网直通车 项目初始化 npm init 安装全局gulp 12npm install gulp -g //全局安装npm install gulp --save-dev //本地安装并加入package.json 这里用了一个gulp插件 gulp-uglify，安装 npm i gulp-uglify -D 定义一个gulp任务gulp.task(name[,deps],fn) 就先写个压缩 js 吧 12345678910111213const gulp = require(\"gulp\");//全局gulpconst uglify = require(\"gulp-uglify\"); //压缩js //压缩js文件 gulp.task(\"script\", function() &#123; //找到文件 gulp .src(\"js/*.js\") //压缩文件 .pipe(uglify()) //保存压缩后的文件 .pipe(gulp.dest(\"dist/js\")); &#125;); 运行gulpgulpfile统计目录下终端运行gulp.script","categories":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://yoursite.com/tags/gulp/"}],"author":"胡豪"},{"title":"网页禁止审查及一些简单禁止用户对页面操作","slug":"网页禁止审查及一些简单禁止用户对页面操作","date":"2019-11-05T03:02:26.000Z","updated":"2019-11-05T03:16:22.867Z","comments":true,"path":"2019/11/05/网页禁止审查及一些简单禁止用户对页面操作/","link":"","permalink":"http://yoursite.com/2019/11/05/网页禁止审查及一些简单禁止用户对页面操作/","excerpt":"","text":"前言对于一些网页，如原创文章，我们不希望用户对我们的网页文章内容拷贝粘贴，所以前端可以做一些操作去禁止，但这种操作也只是防君子不防小人，上有政策下有对策，还是有方法破解的。 先说破解禁止 F12 方法遇到有些网页禁止 F12 审查，我们可以用空白网页先开调试模式，再在地址栏输入网址进入网页 简单禁止 F12 审查此方法就是 js 监听 F12 键盘事件去做操作(不安全，存在绕过漏洞) 1234567891011121314document.onkeydown = function() &#123; if (window.event &amp;&amp; window.event.keyCode == 123) &#123; alert(\"F12被禁用\"); event.keyCode = 0; event.returnValue = false; &#125; if (window.event &amp;&amp; window.event.keyCode == 13) &#123; window.event.keyCode = 505; &#125; if (window.event &amp;&amp; window.event.keyCode == 8) &#123; alert(str + \"\\n请使用Del键进行字符的删除操作！\"); window.event.returnValue = false; &#125;&#125;; 屏蔽右键菜单12345678910111213141516171819document.oncontextmenu = function(event) &#123; if (window.event) &#123; event = window.event; &#125; try &#123; var the = event.srcElement; if ( !( (the.tagName == \"INPUT\" &amp;&amp; the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\" ) ) &#123; return false; &#125; return true; &#125; catch (e) &#123; return false; &#125;&#125;; 屏蔽粘贴12345678910111213141516171819document.onpaste = function(event) &#123; if (window.event) &#123; event = window.event; &#125; try &#123; var the = event.srcElement; if ( !( (the.tagName == \"INPUT\" &amp;&amp; the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\" ) ) &#123; return false; &#125; return true; &#125; catch (e) &#123; return false; &#125;&#125;; 屏蔽复制12345678910111213141516171819document.oncopy = function(event) &#123; if (window.event) &#123; event = window.event; &#125; try &#123; var the = event.srcElement; if ( !( (the.tagName == \"INPUT\" &amp;&amp; the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\" ) ) &#123; return false; &#125; return true; &#125; catch (e) &#123; return false; &#125;&#125;; 屏蔽剪切12345678910111213141516171819document.oncut = function(event) &#123; if (window.event) &#123; event = window.event; &#125; try &#123; var the = event.srcElement; if ( !( (the.tagName == \"INPUT\" &amp;&amp; the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\" ) ) &#123; return false; &#125; return true; &#125; catch (e) &#123; return false; &#125;&#125;; 屏蔽选中12345678910111213141516171819document.onselectstart = function(event) &#123; if (window.event) &#123; event = window.event; &#125; try &#123; var the = event.srcElement; if ( !( (the.tagName == \"INPUT\" &amp;&amp; the.type.toLowerCase() == \"text\") || the.tagName == \"TEXTAREA\" ) ) &#123; return false; &#125; return true; &#125; catch (e) &#123; return false; &#125;&#125;; 总结凡事无绝对，没法做到真正禁止。浏览器菜单里查看页面源代码，直接ctrl+s，爬虫对于页面安全性研究不深，代码来源网上寻找，用时自取。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}],"author":"胡豪"},{"title":"如何在nuxt中使用Vuex做登陆管理","slug":"如何在nuxt中使用Vuex做登陆管理","date":"2019-11-04T02:45:08.000Z","updated":"2019-11-04T08:03:13.952Z","comments":true,"path":"2019/11/04/如何在nuxt中使用Vuex做登陆管理/","link":"","permalink":"http://yoursite.com/2019/11/04/如何在nuxt中使用Vuex做登陆管理/","excerpt":"","text":"前言在vue中vuex可以拿来做状态管理，今天记录下在nuxt框架下如何使用vuex实现项目中的登陆状态的管理 Vuex用token进行验证登录,根据约定,把token放在header中根目录下创建一个store文件夹，在store中创建一个index.js 简述VuexVuex是单项数据流，利用Vuex做状态管理，可以对数据更好地追踪与bug发现 state 初始化状态 gatter 对数据的过滤操作 mutations 进行业务逻辑操作，它是同步的 action 如果需要异步操作，可以写在action中 /store/index.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Vue from \"vue\";import Vuex from \"vuex\";import axios from \"axios\";Vue.use(Vuex);const store = () =&gt; new Vuex.Store(&#123; state: &#123; user: &#123; isLogin: false, userInfo: \"\", token: \"\", ticket: \"\" &#125; &#125;, mutations: &#123; login(state, data) &#123; state.user.isLogin = true; state.user.userInfo = data.userInfo; state.user.userInfo.token = data.token; axios.defaults.headers.common[\"Authorization\"] = data.token; &#125;, loginout(state) &#123; state.user.isLogin = false; state.user.userInfo = \"\"; axios.defaults.headers.common[\"Authorization\"] = \"undefined\"; &#125;, // 设置用户 openId 对应的 key setTicket(state, data) &#123; state.user.ticket = data; &#125; &#125;, actions: &#123; nuxtServerInit(&#123; commit &#125;, &#123; req &#125;) &#123; if (req.session) &#123; if (req.session.authUser) &#123; commit(\"login\", req.session.authUser); &#125; else if (req.session.ticket) &#123; commit(\"setTicket\", req.session.ticket); &#125; &#125; &#125; &#125; &#125;);export default store; middleware官方文档: https://zh.nuxtjs.org/guide/routing#%E4%B8%AD%E9%97%B4%E4%BB%B6利用middleware实现不登录无法访问 123456export default async function (&#123; store,redirect &#125;) &#123; //用户未登录就跳转登录页 if(!store.state.user.isLogin)&#123; redirect('/login') &#125;&#125; 在组件中使用middleware: &#39;mustLogin&#39;, data() {return {}} 登陆组件login登陆页，接口验证成功后，更新store存储的状态 this.$store.commit(&quot;login&quot;, result.data); 完整代码如下： 12345678910111213141516171819202122232425262728methods: &#123; async submitForm(formName) &#123; const account = this.loginForm.account; const password = this.loginForm.password; this.$refs[formName].validate(async valid =&gt; &#123; if (valid) &#123; let result = await login(account, password); if (result.success) &#123; // 登录成功 this.$store.commit(\"login\", result.data); if (window.history.length &gt; 1) &#123; this.$router.go(-1); &#125; else &#123; this.$router.push(\"/\"); &#125; &#125; else &#123; MessageBox(&#123; type: \"error\", title: \"登录信息\", message: result.message &#125;); &#125; &#125; else &#123; return false; &#125; &#125;); &#125;&#125; 登出组件login点击退出按钮，接口发送退出请求，更新store存储的状态 this.$store.commit(&quot;loginout&quot;,null); 1&lt;span v-if=\"$store.state.user.isLogin\" @click=\"loginOut\"&gt;退出&lt;/span&gt; 1234567methods: &#123; async loginOut() &#123; await loginOut(); this.$store.commit(\"loginout\",null); this.$router.push(\"/\") &#125;&#125; 总结至此,就是nuxt中使用Vuex的整个流程,具体不同的地方就需要在项目中针对性地去调整修改。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"vue","slug":"JavaScript/vue","permalink":"http://yoursite.com/categories/JavaScript/vue/"}],"tags":[{"name":"SSR","slug":"SSR","permalink":"http://yoursite.com/tags/SSR/"},{"name":"Nuxt","slug":"Nuxt","permalink":"http://yoursite.com/tags/Nuxt/"}],"author":"胡豪"},{"title":"vue双向数据绑定原理","slug":"vue双向数据绑定原理","date":"2019-10-30T05:57:52.000Z","updated":"2019-12-17T01:23:07.292Z","comments":true,"path":"2019/10/30/vue双向数据绑定原理/","link":"","permalink":"http://yoursite.com/2019/10/30/vue双向数据绑定原理/","excerpt":"","text":"首先我们要了解Object.defineProperty()一、Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性 1.1 属性描述符通过Object.defineProperty()为对象定义属性，有两种形式，且不能混合使用，分别为数据描述符，存取描述符，下面分别描述下两者的区别： 数据描述符 –特有的两个属性（value,writable） 12345let Person = &#123;&#125;Object.defineProperty(Person, 'name', &#123; value: 'jack', writable: true // 是否可以改变&#125;) 属性名 默认值 value undefined get undefined set undefined writable false enumerable false configurable false 二、什么是 getter 和 settergetter 是一种获得属性值的方法，setter 是一种设置属性值的方法getter 负责查询值，它不带任何参数，setter 则负责设置键值，值是以参数的形式传递，在他的函数体中，一切的 return 都是无效的get/set 访问器不是对象的属性，而是属性的特性，特性只有内部才用，因此在 javaScript 中不能直接访问他们，为了表示特性是内部值用两队中括号括起来表示如[[Value]]对象的属性又可分为对象属性和访问器属性 set/get1234567891011121314var person = &#123; _name: \"\", get name() &#123; return this._name; &#125;, set name(n) &#123; this._name = n; &#125;&#125;;// 测试person.name; // 输出 --&gt; ''person.name = \"xiaoming\";person.name; // 输出 --&gt; xiaoming 存取描述符 –是由一对 getter、setter 函数功能来描述的属性get：一个给属性提供getter的方法，如果没有getter则为undefined。该方法返回值被用作属性值。默认为undefined。set：一个给属性提供setter的方法，如果没有setter则为undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认值为undefined。 1234567891011121314151617var person = function() &#123; var _name = &apos; &apos;; var obj = &#123;&#125;; Object.defineProperty(obj, &apos;name&apos;, &#123; configurable: true, enumerable: true, get: function() &#123; return _name; &#125;, set: function(n) &#123; _name = n; &#125; &#125;) return obj;&#125;();person.name = &quot;xiaoming&quot;;person.name // 输出 --&gt; xiaoming vue 的双项数据绑定原理vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。我们先来看 Object.defineProperty()这个方法： 123456789101112var obj = &#123;&#125;;Object.defineProperty(obj, \"name\", &#123; get: function() &#123; console.log(\"我被获取了\"); return val; &#125;, set: function(newVal) &#123; console.log(\"我被设置了\"); &#125;&#125;);obj.name = \"fei\"; //在给obj设置name属性的时候，触发了set这个方法var val = obj.name; //在得到obj的name属性，会触发get方法 vue 是通过数据劫持的方式来做数据绑定的，其中最核心的方法便是通过 Object.defineProperty()来实现对属性的劫持，那么在设置或者获取的时候我们就可以在 get 或者 set 方法里假如其他的触发函数，达到监听数据变动的目的，无疑这个方法是本文中最重要、最基础的内容之一。 实现最简单的双向绑定通过 Object.defineProperty()可以实现数据劫持，是的属性在赋值的时候触发 set 方法 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"demo\"&gt;&lt;/div&gt; &lt;input type=\"text\" id=\"inp\"&gt; &lt;script&gt; var obj = &#123;&#125;; var demo = document.querySelector('#demo') var inp = document.querySelector('#inp') Object.defineProperty(obj, 'name', &#123; get: function() &#123; return val; &#125;, set: function (newVal) &#123;//当该属性被赋值的时候触发 inp.value = newVal; demo.innerHTML = newVal; &#125; &#125;) inp.addEventListener('input', function(e) &#123; // 给obj的name属性赋值，进而触发该属性的set方法 obj.name = e.target.value; &#125;); obj.name = 'changme';//在给obj设置name属性的时候，触发了set这个方法 &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; vue 代码实现observer 实现，主要是给每个 vue 的属性用 Object.defineProperty()，代码如下 function defineReactive(obj, key, val) { var dep = new Dep(); Object.defineProperty(obj, key, { get: function() { //添加订阅者watcher到主题对象Dep if (Dep.target) { // JS的浏览器单线程特性，保证这个全局变量在同一时间内，只会有同一个监听器使用 dep.addSub(Dep.target); } return val; }, set: function(newVal) { if (newVal === val) return; val = newVal; console.log(val); // 作为发布者发出通知 dep.notify(); //通知后dep会循环调用各自的update方法更新视图 } }); } function observe(obj, vm) { Object.keys(obj).forEach(function(key) { defineReactive(vm, key, obj[key]); }); }","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"author":"胡豪"},{"title":"如何理解ES6中Promise","slug":"如何理解ES6中Promise","date":"2019-10-22T10:46:32.000Z","updated":"2019-11-01T09:48:21.094Z","comments":true,"path":"2019/10/22/如何理解ES6中Promise/","link":"","permalink":"http://yoursite.com/2019/10/22/如何理解ES6中Promise/","excerpt":"","text":"什么是Promise/Promise/是ES6中的一个内置的对象（实际上是一个构造函数，通过这个构造函数我们可以创建一个/Promise/对象），它的出现是为了更好地解决JavaScript中异步编程的问题，传统的异步编程最大的特点就是地狱般的回调嵌套，一旦嵌套次数过多，就很容易使我们的代码难以理解和维护。而/Promise/则可以让我们通过链式调用的方法去解决回调嵌套的问题，使我们的代码更容易理解和维护，而且/Promise/还增加了许多有用的特性，让我们处理异步编程得心应手。/Promise/的英文意思是承诺。 Promise的特点 /Promise/有三种状态：Pending（进行中）、Resolved（已完成）、Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 /Promise/一共有三种状态，但是他们之间是如何转化的呢？ 其一： 从Pending（进行中）到Resolved（完成）。其二： 从Pending（进行中）到Rejected（已失败）。 且只有这两种形式的转变，即使是Promise对象的结果也无力回天了。 但是/Promise/并不是完美无缺的，也是有一定的缺点的，如在Pengding时，我们无法取消状态，另外，我们没法判断Pending究竟是刚刚开始的Pending还是即将要完成的Pending。 使用Promise 直接上码 123456789var promise = new Promise(function(resolve, reject) &#123;// ... some codeif (/* 异步操作成功 */)&#123;resolve(value);&#125; else &#123;reject(error);&#125;&#125;); 其中，由于Promise是构造函数，所以我们使用new来创建一个对象即可， 值得注意的是：function(resolve, reject){}这个函数是必须要写的，否则就不是Promise了。 这个函数是为了初始化Promise对象，其中这个函数接受了两个函数作为参数， 如果在函数体中我们执行了resolve函数，那么Promise的状态就会由pending转化为resolved（或fullfilled，两者是相同的），类似的，如果我们执行了reject函数，pending就会变成 rejected。 注意： 这个例子的if语句不是必要的，这里想要表达的意思是如果得到了异步成功的相关结果，我们就将调用resolve，将pending转化为resolved，并且将异步成功后的value值传递进去以便后面使用，说是以便后面使用是因为Promise还有一个then()方法，即可以定义在异步成功（或失败）之后需要做的事情。这也就是resolve和reject内置函数存在的意义了。 当创建了这个Promise对象之后，就一定会有一个结果了，但是成功和失败还是不确定的，我们需要根据判断结果的成功和失败来做不同的事情，于是用到了then()方法，如下所示： 12345 promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 下面这个例子做了详尽的说明 1234567891011121314151617var promise = new Promise(function (resolve, reject) &#123; console.log(\"good\"); var a = 10; var b = a + 25; if ( b === 35 ) &#123; // 一旦异步执行成功，我们就调用内置的 resolve函数，将pending状态转化为resolved，并且传入我们希望传出的执行成功后的结果。 // 注意： 这里一旦状态转变，那么后面就一定会调用then方法中的第一个参数的函数，然后将我们传入给resolve的参数传给then方法中的第一个方法作为参数，我们就可以在then的第一个方法中使用了。 resolve(b); &#125; else &#123; reject(\"异步执行失败\"); &#125;&#125;);promise.then(function (value) &#123; console.log(\"异步执行成功，输出执行结果：\" + value);&#125;, function (error) &#123; console.log(\"异步执行失败，输出执行结果：\" + error);&#125;); Promise的方法1. Promise.prototype.then()上面其实已经介绍了then()方法了，而这里需要强调的有两点。第一：then()方法是Promise原型上定义的方法。第二：then()方法支持链式调用，上一个then()方法调用后返回的结果回传给下一个then()方法中。 第一：我们在chrome中输入Promise.prototype可以看到下面的例子：可以看出在Promise的原型中确实是由then方法的。（注：比如我们想看Array这个内置对象有哪些方法，我们就可以直接在chrome中输入Array.prototype，然后就可以看到对应方法的列表了） 第二： then()的作用是为Promise实例添加状态改变时的回调函数。then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。then()由于支持链式调用，所以也可以这样写成这样： 12345 getJSON(\"/posts.json\").then(function(json) &#123; return json.post; &#125;).then(function(post) &#123; // ...&#125;); 第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 再来看看下面这个例子： 1234567getJSON(\"/post/1.json\").then(function(post) &#123; return getJSON(post.commentURL);&#125;).then(function funcA(comments) &#123; console.log(\"Resolved: \", comments);&#125;, function funcB(err)&#123; console.log(\"Rejected: \", err);&#125;); 即第一个then又返回了一个promise，如何这个promise的状态变成了 Resolved，那么就会执行第二个then的第一个函数， 如果变成了 Rejected，就会执行第二个第二个函数。 2.Promise.prototype.catch() Promise.prototype.catch()方法实际上是then(null, rejection)方法的别名， 这里使用catch（）纯粹是为了便于使用和理解。 123456 getJSON('/posts.json').then(function(posts) &#123; // ... &#125;).catch(function(error) &#123; // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error);&#125;); 在之前的例子中，我们讲解then()方法接受两个参数，第一个参数是pending变成resolved之后执行的函数，它是必选的； 第二个参数是pending变成rejected之后执行的函数，它是可选的。 我们建议，最后不要使用第二个参数，取而代之我们最好使用catch（），如下所示： 12345678910111213141516// bad promise .then(function(data) &#123; // success &#125;, function(err) &#123; // error &#125;); // good promise .then(function(data) &#123; //cb // success &#125;) .catch(function(err) &#123; // error &#125;); 值得注意的是：catch()方法返回的还是一个Promise对象，我们可以在后面继续使用then进行链式调用。 3.Promise.all() Promise.all()方法用于将多个Promise实例包装成一个新的Promise实例，如下所示： 12 var p = Promise.all([p1, p2, p3]);&#125;); 其中的p1，p2，p3都是Promise对象实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。 p的状态由p1，p2，p3决定，分成下面的两种情况： 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 让我们来看看具体的例子： 123456789// 生成一个Promise对象的数组var promises = [2, 3, 5, 7, 11, 13].map(function (id) &#123;return getJSON(\"/post/\" + id + \".json\");&#125;);Promise.all(promises).then(function (posts) &#123;// ...&#125;).catch(function(reason)&#123;// ... 在这个例子中，通过数组的map生成了6个Promise对象，然后作为参数传递给了Promise.all() 只有这6个Promise对象最终返回的都是 resolved时， 才会调用Promise.all()后面then（）方法。 4.Promise.resolve()如果我们希望将一个现有对象转化为Promise对象，我们就可以使用Promise.resolve()方法。根据参数的不同可以分为4种情况： 参数是一个Promise实例如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 参数是一个thenable对象如果参数是一个thenable对象，即具有then()方法的对象，那么Promise.resolve()就会将该对象立即转化成 Promise对象那个，并立即执行then方法。 参数不是具有then方法的对象，或根本就不是对象如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 不带有任何参数 总结","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}],"author":"刘涛"},{"title":"SPA的前世今生","slug":"SPA的前世今生","date":"2019-10-11T07:24:55.000Z","updated":"2019-10-22T12:11:39.775Z","comments":true,"path":"2019/10/11/SPA的前世今生/","link":"","permalink":"http://yoursite.com/2019/10/11/SPA的前世今生/","excerpt":"","text":"前言SPA(Single Page Application)，即单页应用，想必现在的前端对其早已耳熟能详，今天就来说道说道，SPA 的前世今生。 多页面应用（MultiPage Application，MPA）为什么先说多页面，因为传统网站都是多页面的，从大学第一次做网页，到工作使用 JQ 库，一个个 html 页面拼凑而成的网站都是多页面的。每一次页面跳转的时候，后台服务器都会给返回一个新的 html 文档，这种类型的网站也就是多页网站，也叫做多页应用。多页面跳转刷新所有资源，每个公共资源(js、css 等)需选择性重新加载。 页面结构如图： 为什么多页应用的首屏时间快？首屏时间叫做页面首个屏幕的内容展现的时间，当我们访问页面的时候，服务器返回一个 html，页面就会展示出来，这个过程只经历了一个 HTTP 请求，所以页面展示的速度非常快。 为什么搜索引擎优化效果好（SEO）？搜索引擎在做网页排名的时候，要根据网页内容才能给网页权重，来进行网页的排名。搜索引擎是可以识别 html 内容的，而我们每个页面所有的内容都放在 Html 中，所以这种多页应用，seo 排名效果好。 但是它也有缺点，就是切换慢因为每次跳转都需要发出一个 http 请求，如果网络比较慢，在页面之间来回跳转时，就会发现明显的卡顿。新的需求促进新的技术诞生，随着业务量变大功能的复杂，前端对页面性能的要求越来越高，随之而来的就是单页面的应用。 单页应用（SinglePage Web Application，SPA）第一次进入页面的时候会请求一个 html 文件，刷新清除一下。页面切换，也不是传统的请求另一个页面的 html,而是通过路由，改变组件，此时路径也相应变化，但是并没有新的 html 文件请求，页面内容也变化了。原理是：JS 会感知到 url 的变化，通过这一点，可以用 js 动态的将当前页面的内容清除掉，然后将下一个页面的内容挂载到当前页面上，这个时候的路由不是后端来做了，而是前端来做，判断页面到底是显示哪个组件，清除不需要的，显示需要的组件。这种过程就是单页应用，每次跳转的时候不需要再请求 html 文件了。 页面结构如图： 为什么页面切换快？页面每次切换跳转时，并不需要做 html 文件的请求，这样就节约了很多 http 发送时延，我们在切换页面的时候速度很快。 缺点：首屏时间慢，SEO 差单页应用的首屏时间慢，首屏时需要请求一次 html，同时还要发送一次 js 请求，两次请求回来了，首屏才会展示出来。相对于多页应用，首屏时间慢。SEO 效果差，因为搜索引擎只认识 html 里的内容，不认识 js 的内容，而单页应用的内容都是靠 js 渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。 优缺点，必有解决的对策比如说服务器端渲染技术(如 SSR)可以解决 SEO 问题，通过这些技术可以完美解决这些缺点，解决完这些问题，实际上单页面应用对于前端来说是非常完美的页面开发解决方案。 具体对比分析： 多页应用模式MPA 单页应用模式SPA 组成 多个完整页面构成 一个外壳页面和多个页面片段组成 资源共用(css,js) 不共用，每个页面都需要加载 共用，只需在外壳部分加载 刷新方式 整页刷新 页面局部刷新或更改 URL模式 http://xxx/page1.html 和 http://xxx/page2.html http://xxx/shell.html#page1 和 http://xxx/shell.html#page2 用户体验 页面间切换加载慢，不流畅，用户体验差，特别是在移动设备上 页面片段间的切换快，用户体验好，包括在移动设备上 能否实现转场动画 无法实现 容易实现（手机app动效） 页面间传递数据 依赖URL、cookie或者localstorage，实现麻烦 因为在一个页面内，页面间传递数据很容易实现(父子之间传值，或vuex或storage之类) 搜索引擎优化（SEO） 可以直接做 不利于SEO检索，可利用SSR来实现 特别适用的范围 需要对搜索引擎友好的网站 对体验要求高的应用，特别是移动应用 购物网站","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}],"author":"胡豪"},{"title":"JavaScript中深拷贝与浅拷贝的理解","slug":"JavaScript中深拷贝与浅拷贝的理解","date":"2019-10-08T01:08:15.000Z","updated":"2019-10-11T07:13:08.408Z","comments":true,"path":"2019/10/08/JavaScript中深拷贝与浅拷贝的理解/","link":"","permalink":"http://yoursite.com/2019/10/08/JavaScript中深拷贝与浅拷贝的理解/","excerpt":"","text":"前言之所以会出现了深拷贝和浅拷贝，究其根本是因为JS种的变量包含了不同类型的数据值：基本类型和引用类型；同时其中变量的存储方式也不用Object属于堆内存的储存方式；并且JS的值的传递方式如值传递和址传递的会出现不同，所以才会出现这一系列的问题，因此才会使用深拷贝和浅拷贝来解决这些问题。 一、理解堆栈，基本数据类型和引用数据类型 1.堆栈 栈（stack）：系统自动分配的内存空间，内存会由系统自动释放，用来存放函数的参数值，局部变量的值等，特点是先进后出。 堆堆（heap）：系统动态分配的内存，内存大小不一，内存不会自动释放。一般由程序员分配释放，主要负责像Obejct这种变量类型的存储。 2.基本数据类型 概念：存放在栈内存中的简单数据段，数据大小确定，内存空间大小确定 6种基本数据类型：Undefined、Null、Boolean、Number、String、Symbol 3.引用数据类型 概念：存放在堆内存中的数据，如对象、数组、函数等。名存在栈内存，值存在堆内存，栈内存会提供一个引用的地址指向堆内存中的值 二、JavaScript浅拷贝浅拷贝：只复制一层对象属性，可以理解为，只复制对象的基本属性类型，而基本属性类型是存放在栈内存中的，可以直接修改访问的，所以当浅拷贝时，拷贝的对象只是拷贝了原对象的属性，而值都是指向同一个栈内存中的数据，当对象属性值发生修改时，原对象也会被修改。如下示例： 1234567891011121314let arr1 = &#123; color:'red', name:'apple', weight:'100g', detail:&#123; big:'true', eating:'no' &#125; &#125;;let arr2;arr2 = arr1;arr2.color = 'black';console.log(arr2); console.warn(arr1); 输出值： 三、JavaScript深拷贝深拷贝：它不仅将原对象的各个属性逐个复制出去，而且将原对象各个属性所包含的对象也依次采用深复制的方法递归复制到新对象上。这就不会存在上面 obj 和 shallowObj 的 arr 属性指向同一个对象的问题。这是我从某官网看来的解释，我感觉挺绕的，结合对象来看，深拷贝存在于对象这种引用类型中，而引用类型的数据是存在堆内存上的，变量保存的是一个指针，这个指针指向另一个位置。当需要访问引用类型（如对象，数组等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。深拷贝可以看做是在堆内存中新开辟了一个内存空间，复制后的对象的属性所指的指针会指向新开辟的内存空间的地址。所以复制后的对象对属性值进行修改不会影响原对象的属性值。 四、实现深拷贝的方式1.借用JSON对象的 parse 和 stringify(接上面的例子) 1234 let arr3 = JSON.parse(JSON.stringify(arr1));arr3.color=\"balck\";console.log(arr3);console.warn(arr1); 输出结果 2.通过for循环递归调用 12345678910111213141516171819202122function deepClone(obj)&#123; //判断obj是否是数组 let objClone = Array.isArray(obj)?[]:&#123;&#125;; if(obj &amp;&amp; typeof obj===\"object\")&#123; for(key in obj)&#123; if(obj.hasOwnProperty(key))&#123; //判断ojb子元素是否为对象，如果是，递归复制 if(obj[key]&amp;&amp;typeof obj[key] ===\"object\")&#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; //如果不是，简单复制 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone; &#125; var arr4 = deepClone(arr1); arr4.name='bananer'; console.log(arr4); console.warn(arr1); 输出结果 3.封装深拷贝函数 12345678910111213141516171819202122 function deepClone(obj) &#123; let objClone = Array.isArray(obj) ? [] : &#123;&#125;; if(obj &amp;&amp; typeof obj === \"object\") &#123; for(key in obj) &#123; if(obj.hasOwnProperty(key)) &#123; // 判断 obj 是否是对象,如果是，递归复制 if(obj[key] &amp;&amp; typeof obj[key] === \"object\") &#123; objClone[key] = deepClone(obj[key]); &#125;else&#123; // 如果不是 objClone[key] = obj[key]; &#125; &#125; &#125; &#125; return objClone&#125; let a = [1,2,3,4], b = deepClone(a);a[0] = 5;console.log(a,b)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}],"author":"刘涛"},{"title":"闭包的概念与应用","slug":"闭包的概念与应用","date":"2019-10-07T12:28:12.000Z","updated":"2019-10-11T07:13:08.420Z","comments":true,"path":"2019/10/07/闭包的概念与应用/","link":"","permalink":"http://yoursite.com/2019/10/07/闭包的概念与应用/","excerpt":"","text":"什么是闭包？作为一个 JavaScript 语言的开发者，提起闭包肯定不会感到陌生，那么到底什么才是闭包哪？ 闭包不是什么新奇的概念，它早在高级语言开始发展的年代就产生了。闭包（Closure）是词法闭包的简称。对闭包的具体定义有很多种说法，这些说法大体可以分为两类： 一种说法认为闭包是符合一定条件的函数。认为闭包是在其词法上下文中引用了自由变量（自由变量是指局部变量以外的变量）的函数。 另一种说法认为闭包是函数和与其相关的引用环境组合而成的实体。认为闭包是在实现深约束时，需要创建一个能显示表示引用环境的东西，并将它与相关的子程序捆绑在一起，这样捆绑起来的整体被称为闭包。 这两种定义在某种意义上是对立的，一个认为闭包是函数，另一个认为闭包是函数和引用环境组成的整体。很明显第二种说法更确切一些，闭包只是在形式和表现上像函数，但实际上不是函数。函数是一些可执行的代码，这些代码在函数被定义后就确定了，不会在执行时发生变化，所以一个函数只有一个实例。闭包在运行时可以有多个实例，不同的引用环境和相同的函数组合可以产生不同的实例。所谓引用环境是指在程序执行中的某个点所有处于活跃状态的约束组成的集合。其中的约束是指一个变量的名字和其所代表的对象之间的联系。 JavaScript 闭包的本质在支持嵌套作用域的语言中，有时不能简单直接的确定函数的引用环境。这样的语言一般具有这样的特性： 函数是一等公民，即函数可以作为一个函数的返回值或参数，还可以作为一个变量的值 函数可以嵌套定义，即在一个函数内部可以定义另一个函数。 JavaScript 闭包的源自两点，词法作用域和函数当做值传递。 作用域是查找变量时的一些规则。词法作用域就是定义在词法阶段的作用域。或者换句话说，词法作用域是由你书写代码时将变量和块作用域写在哪里来决定的。按照代码书写时的样子，内部函数可以顺着作用域链一层一层地查找、访问函数外的变量，或者我们叫它自由变量。 函数当做值传递，也就是上面所说的函数是一等公民。函数内部的自由变量是在外层函数执行时创建的，外层函数执行完以后，这些变量理应被销毁，但是如果将内层函数作为返回值返回，这些自由变量就被保存了下来。而且无法访问，必须通过内层函数来访问。本来执行过程和词法作用域是封闭的，将内层函数作为返回值返回就提供了一种访问自由变量的方式。 一个函数如何能封闭外部状态哪？当外部状态的scope失效的时候，还有一份留在内部状态里面。在执行过程中，返回函数，或者将函数得以保留下来，并且函数中有自由变量就会形成闭包。一个函数中没有自由变量时，引用环境不会发生变化。 闭包的应用知道了什么是闭包，也理解了闭包的本质，下面可以了解下闭包的几种应用，或许你在日常的开发中已经用到不少了。 封装私有变量，存储计算的值12345678// 将计算的结果保存在 sum 中function add(init) &#123; var sum = init; return function getSum(number) &#123; sum += number; return sum; &#125;&#125; 延迟计算123456789101112131415// 延迟计算function add(init) &#123; var sum = init; var args = []; return function getSum() &#123; // 当参数到达一定的数量时再进行运算 args = args.concat(Array.from(arguments)); if(args.length &gt; 5) &#123; for(let i = 0; i &lt; args.length; i++) &#123; sum += args[i]; &#125; return sum; &#125; &#125;&#125; 延续局部变量的寿命img 对象经常用于进行数据上报，但是通过查询后台的记录可以得知，因为一些低版本的浏览器的实现可能存在 bug，在这些浏览器下使用 report 函数进行数据上报会丢失 30% 左右的数据，也就是说，report 函数并不是每一次都发起了 HTTP 请求。丢失数据的原因是 img 是 report 函数中的局部变量，当 report 函数调用结束后， img 局部变量随即被销毁，而此时或许还没来得及发出 HTTP 请求，所以此次请求就会丢失掉。 123456789101112131415// 这种方法会丢失 30% 左右的数据var report = function (src) &#123; var img = new Image(); img.src = src;&#125;;// 把 img 变量封装起来，就可以解决请求丢失的问题var report = (function()&#123; var imgs = []; return function(src) &#123; var img = new Image(); imgs.push(img); img.src = src; &#125;&#125;)(); 私有数据和应用程序接口有时，你想强制程序与数据的交互方式，以便保护其完整性。通过是使用闭包，完全可以做到这一点。创建此类接口的一种常见方法就是从函数返回对象。这时，定义在原函数中的数据只能由返回对象上定义的方法访问，下面是一个例子： 12345678910111213141516171819202122232425262728293031323334function makeCalendar(name) &#123; var calendar = &#123; owner: name, events: [], &#125;; return &#123; addEvent: function(event, dateString) &#123; var eventInfo = &#123; event: event, date: new Date(dateString), &#125;; calendar.events.push(eventInfo); calendar.events.sort(function(a, b) &#123; return a.date - b.date; &#125;); &#125;, listEvents: function() &#123; if (calendar.events.length &gt; 0) &#123; console.log(calendar.owner + \"'s events are: \"); calendar.events.forEach(function(eventInfo) &#123; var dateStr = eventInfo.date.toLocaleDateString(); var description = dateStr + \": \" + eventInfo.event; console.log(description); &#125;); &#125; else &#123; console.log(calendar.owner + \" has no events.\"); &#125; &#125;, &#125;;&#125; 闭包与内存管理局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，那么这个局部变量就会一直存在。在这个意义上看，闭包的确会使一些数据无法被及时销毁。使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的。如果在将来需要回收这些变量的时候，可以手动把这些变量设置为 null。 参考内容 闭包的概念、形式与应用 什么是闭包？ JavaScript Weekly: Making Sense of Closures JavaScript 设计模式与开发实践","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/闭包/"}],"author":"霜寒"},{"title":"对于Javascript执行上下文的理解","slug":"对于Javascript执行上下文的理解","date":"2019-09-24T02:35:15.000Z","updated":"2019-10-11T07:13:08.419Z","comments":true,"path":"2019/09/24/对于Javascript执行上下文的理解/","link":"","permalink":"http://yoursite.com/2019/09/24/对于Javascript执行上下文的理解/","excerpt":"","text":"前言在这篇文章中，将比较深入地阐述下执行上下文 – JavaScript中最基础也是最重要的一个概念。相信读完这篇文章后，你就会明白javascript引擎内部在执行代码以前到底做了些什么，为什么某些函数以及变量在没有被声明以前就可以被使用，以及它们的最终的值是怎样被定义的。 什么是执行上下文Javascript中代码的运行环境分为以下三种： 全局级别的代码 – 这个是默认的代码运行环境，一旦代码被载入，引擎最先进入的就是这个环境。 函数级别的代码 – 当执行一个函数时，运行函数体中的代码。 Eval的代码 – 在Eval函数内运行的代码。 我们可以将“执行上下文”看做当前代码的运行环境或者作用域。下面我们来看一个示例，其中包括了全局以及函数级别的执行上下文: 上图中，一共用4个执行上下文。紫色的代表全局的上下文；绿色代表person函数内的上下文；蓝色以及橙色代表person函数内的另外两个函数的上下文。注意，不管什么情况下，只存在一个全局的上下文，该上下文能被任何其它的上下文所访问到。也就是说，我们可以在person的上下文中访问到全局上下文中的sayHello变量，当然在函数firstName或者lastName中同样可以访问到该变量。 至于函数上下文的个数是没有任何限制的，每到调用执行一个函数时，引擎就会自动新建出一个函数上下文，换句话说，就是新建一个局部作用域，可以在该局部作用域中声明私有变量等，在外部的上下文中是无法直接访问到该局部作用域内的元素的。在上述例子的，内部的函数可以访问到外部上下文中的声明的变量，反之则行不通。那么，这到底是什么原因呢？引擎内部是如何处理的呢？ 执行上下文堆栈在浏览器中，javascript引擎的工作方式是单线程的。也就是说，某一时刻只有唯一的一个事件是被激活处理的，其它的事件被放入队列中，等待被处理。下面的示例图描述了这样的一个堆栈： 我们已经知道，当javascript代码文件被浏览器载入后，默认最先进入的是一个全局的执行上下文。当在全局上下文中调用执行一个函数时，程序流就进入该被调用函数内，此时引擎就会为该函数创建一个新的执行上下文，并且将其压入到执行上下文堆栈的顶部。浏览器总是执行当前在堆栈顶部的上下文，一旦执行完毕，该上下文就会从堆栈顶部被弹出，然后，进入其下的上下文执行代码。这样，堆栈中的上下文就会被依次执行并且弹出堆栈，直到回到全局的上下文。请看下面一个例子： 1234567(function foo(i) &#123; if (i === 3) &#123; return; &#125;else &#123; foo(++i); &#125; &#125;(0)); 上述foo被声明后，通过()运算符强制直接运行了。函数代码就是调用了其自身3次，每次是局部变量i增加1。每次foo函数被自身调用时，就会有一个新的执行上下文被创建。每当一个上下文执行完毕，该上上下文就被弹出堆栈，回到上一个上下文，直到再次回到全局上下文。真个过程抽象如下图: 由此可见 ，对于执行上下文这个抽象的概念，可以归纳为以下几点： 单线程 同步执行 唯一的一个全局上下文 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行行下文为其创建，即使是调用的自身函数，也是如此。 执行上下文的建立过程我们现在已经知道，每当调用一个函数时，一个新的执行上下文就会被创建出来。然而，在javascript引擎内部，这个上下文的创建过程具体分为两个阶段: 建立阶段(发生在当调用一个函数时，但是在执行函数体内的具体代码以前) 建立变量，函数，arguments对象，参数 建立作用域链 确定this的值 代码执行阶段 变量赋值，函数引用，执行其它代码 实际上可以把执行上下文看做一个对象，其下包含以上3个属性： 12345(executionContextObj = &#123; variableObject: &#123; /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */ &#125;, scopeChain: &#123; /* variableObject 以及所有父执行上下文中的variableObject */ &#125;, this: &#123;&#125; &#125; 建立阶段以及代码执行阶段的详细分析 确切地说，执行上下文对象（上述的executionContextObj）是在函数被调用时，但是在函数体被真正执行以前所创建的。函数被调用时，就是我上述所描述的两个阶段中的第一个阶段 – 建立阶段。这个时刻，引擎会检查函数中的参数，声明的变量以及内部函数，然后基于这些信息建立执行上下文对象（executionContextObj）。在这个阶段，variableObject对象，作用域链，以及this所指向的对象都会被确定。 上述第一个阶段的具体过程如下： 找到当前上下文中的调用函数的代码 在执行被调用的函数体中的代码以前，开始创建执行上下文 进入第一个阶段-建立阶段: 建立variableObject对象: 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值 检查当前上下文中的函数声明:每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用,如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。 初始化作用域链 确定上下文中this的指向对象 代码执行阶段：执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。下面来看个具体的代码示例: 12345678function foo(i) &#123; var a = 'hello'; var b = function privateB() &#123; &#125;; function c() &#123; &#125; &#125; foo(22); 在调用foo(22)的时候，建立阶段如下: 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: undefined, b: undefined &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 由此可见，在建立阶段，除了arguments，函数的声明，以及参数被赋予了具体的属性值，其它的变量属性默认的都是undefined。一旦上述建立阶段结束，引擎就会进入代码执行阶段，这个阶段完成后，上述执行上下文对象如下: 1234567891011121314fooExecutionContext = &#123; variableObject: &#123; arguments: &#123; 0: 22, length: 1 &#125;, i: 22, c: pointer to function c() a: 'hello', b: pointer to function privateB() &#125;, scopeChain: &#123; ... &#125;, this: &#123; ... &#125; &#125; 我们看到，只有在代码执行阶段，变量属性才会被赋予具体的值。 局部变量作用域提升的缘由在网上一直看到这样的总结： 在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，就是一进入函数体，就可以访问到其中声明的变量以及函数。这是对的，但是知道其中的缘由吗？相信你通过上述的解释应该也有所明白了。不过在这边再分析一下。看下面一段代码: 123456789101112(function() &#123; console.log(typeof foo); // function pointer console.log(typeof bar); // undefined var foo = 'hello', bar = function() &#123; return 'world'; &#125;; function foo() &#123; return 'hello'; &#125;&#125;());​ 上述代码定义了一个匿名函数，并且通过()运算符强制理解执行。那么我们知道这个时候就会有个执行上下文被创建，我们看到例子中马上可以访问foo以及bar变量，并且通过typeof输出foo为一个函数引用，bar为undefined。 为什么我们可以在声明foo变量以前就可以访问到foo呢？ 因为在上下文的建立阶段，先是处理arguments, 参数，接着是函数的声明，最后是变量的声明。那么，发现foo函数的声明后，就会在variableObject下面建立一个foo属性，其值是一个指向函数的引用。当处理变量声明的时候，发现有var foo的声明，但是variableObject已经具有了foo属性，所以直接跳过。当进入代码执行阶段的时候，就可以通过访问到foo属性了，因为它已经就存在，并且是一个函数引用。 为什么bar是undefined呢？ 因为bar是变量的声明，在建立阶段的时候，被赋予的默认的值为undefined。由于它只要在代码执行阶段才会被赋予具体的值，所以，当调用typeof(bar)的时候输出的值为undefined。","categories":[],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"}],"author":"刘涛"},{"title":"谈谈前端路由","slug":"谈谈前端路由","date":"2019-09-19T08:57:02.000Z","updated":"2019-10-11T07:13:08.419Z","comments":true,"path":"2019/09/19/谈谈前端路由/","link":"","permalink":"http://yoursite.com/2019/09/19/谈谈前端路由/","excerpt":"","text":"单页面应用与前端路由在传统的 Web 开发中，浏览器根据地址栏的 URL 向服务器发送一个 HTTP 请求，服务器根据 URL 返回一个 HTML 页面。这种情况下，一个 URL 对应一个 HTML 页面，一个 Web 应用包含很多 HTML 页面，这样的应用就是多页面应用；在多页面应用中，页面路由的控制由服务器负责，这种路由方式称为后端路由。 在多页面应用中，每次页面切换都需要向服务器发送一次请求，页面使用的静态资源也需要重新加载，存在一定的浪费。而且，页面的整体刷新对用户体验也有影响，因为不同页面间往往存在共同的部分，例如导航栏、侧边栏等，页面整体刷新也会导致公共部分的刷新。 有没有一种方式让 Web 应用只是看起来像多页面应用，也就是说 URL 的变化可以引起页面内容的变化，但不会向服务器发送新的请求哪？满足这种条件的 Web 应用就是单页面应用（Single Page Application，简称 SPA）。单页面应用虽然名为”单页“，但视觉上的感受仍然是多页面，因为 URL 发生变化，页面上的内容也会变化，但这只是逻辑上的多页面，实际上无论 URL 如何变化，对应的 HTML 文件都是同一个，这也是单页面应用名字的由来。在单页面应用中，URL 发生变化并不会向服务器发送新的请求，所以”逻辑页面“的变化只能由前端负责，这种方式称为前端路由。 前端路由的实现路由就是 URL 到函数的映射，这个是前端路由的原理。如果做到在 URL 发生变化的时候不向服务器发送请求，而是去执行一个控制 UI 组件的函数哪？那就不得不说说 hash 和 history 这两种实现方案了。 基于 hash在一个 URL 的组成中，#号包括#号后边的部分称为 hash。在浏览器中，可以通过location.hash获取到。#代表网页中的一个位置，其右边的字符，就是该位置的标识符。比如： 12// #title 是 hashhttp://www.example.com/index.html#title #号是用来指导浏览器动作的，对服务器完全不起作用，HTTP 请求不会带上#号以及它后边的内容。单单改变#号后边的内容，浏览器只会滚动到指定的位置，不会重新加载网页。而且改变 hash 还会改变浏览器的历史记录。我们可以通过onhashchange监听到 hash 的改变来不刷新浏览器触发视图的更新。代码如下： 123456&lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;white&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#yellow\"&gt;yellow&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#green\"&gt;green&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;这是页面的内容 123456789101112131415161718192021222324252627282930313233343536373839404142function Router() &#123; this.routes = &#123;&#125;; this.currentUrl = \"\";&#125;Router.prototype.route = function(path, callback) &#123; this.routes[path] = callback || function() &#123; console.log(\"请为路由绑定处理方法\"); &#125;;&#125;;Router.prototype.refresh = function() &#123; console.log(\"触发一次 hashchange，hash值为\", location.hash); this.currentUrl = \"/\" + location.hash.slice(1); // 执行当前路由绑定的方法 this.routes[this.currentUrl]();&#125;;Router.prototype.init = function() &#123; window.addEventListener(\"DOMContentLoaded\", this.refresh.bind(this), false); window.addEventListener(\"hashchange\", this.refresh.bind(this), false);&#125;;window.Router = new Router();window.Router.init();var content = document.querySelector(\"body\");function changeBgColor(color) &#123; content.style.backgroundColor = color;&#125;Router.route(\"/\", function() &#123; changeBgColor(\"white\");&#125;);Router.route(\"/yellow\", function() &#123; changeBgColor(\"yellow\");&#125;);Router.route(\"/green\", function() &#123; changeBgColor(\"green\");&#125;); 基于 history 模式在 HTML5 规范中，history新增了一下几个 API： 123history.pushState(); // 添加新的状态到历史状态栈history.replaceState(); // 用新的状态代替当前状态history.state // 返回当前状态对象 通过上面两个操作状态的 API，也能够做到：改变 url 的同时，不刷新页面。所以 history 也具备实现路由控制的潜力。仅仅是改变 url 不刷新页面还不够，还要能够监听到 url 的变化。对于 hash 来说，hash 的改变可以出发 onhashchange 事件，history 并没有这样的事件可以监听。然而，对于一个应用来说，改变一个 url 只有下面三种途径： 点击浏览器的前进或者后退 点击 a 标签 在 JS 代码中直接修改路由 第 2 种和第 3 种途径可以看成是一种，因为 a 标签的默认事件可以被禁止，进而调用 js 方法。关键是第 1 种，HTML5 规范种新增了一个 onpopstate 事件，通过它便可以监听到前进或者后退的按钮点击。要特别注意的是：调用history.pushState和history.replaceState并不会触发 onpopstate 事件。 12345678910111213141516171819202122232425262728293031323334// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件window.addEventListener('DOMContentLoaded', onLoad)// 监听路由变化window.addEventListener('popstate', onPopState)// 路由视图var routerView = nullfunction onLoad () &#123; routerView = document.querySelector('#routeView') onPopState() // 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。 var linkList = document.querySelectorAll('a[href]') linkList.forEach(el =&gt; el.addEventListener('click', function (e) &#123; e.preventDefault() history.pushState(null, '', el.getAttribute('href')) onPopState() &#125;))&#125;// 路由变化时，根据路由渲染对应 UIfunction onPopState () &#123; switch (location.pathname) &#123; case '/home': routerView.innerHTML = 'Home' return case '/about': routerView.innerHTML = 'About' return default: return &#125;&#125; hash vs historyhash 模式下，每个 url 都会带有#号，看起来可能不太友好。但是，hash 模式兼容 IE8 及其以上的浏览器。history 模式使用了 HTML5 里边新的 API，看起来会比较友好。但是，仅仅有前端的参与还是不够的，需要后端进行配置，前端的路由要和后端的路由要匹配起来，在刷新浏览器的时候会给后端发送请求，这个时候后台需要对请求的 url，做一个捕捉，将后端不存在的 url，重定向到指定路由。 参考内容 URL 中的 hash React 进阶之路 单页面应用路由实现原理 hash 和 history 两种模式的区别 前端路由原理解析和实现","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"前端路由","slug":"前端路由","permalink":"http://yoursite.com/tags/前端路由/"}],"author":"霜寒"},{"title":"什么是BFC","slug":"什么是BFC","date":"2019-09-18T01:48:56.000Z","updated":"2019-10-11T07:13:08.418Z","comments":true,"path":"2019/09/18/什么是BFC/","link":"","permalink":"http://yoursite.com/2019/09/18/什么是BFC/","excerpt":"","text":"前言对于BFC的概念以及应用场景一直都不是很明白，今天着重去了解了一下，做了以下总结。 什么是BFCBFC（Block Formatting Context）直译为“块级格式化范围”。是 W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用当涉及到可视化布局的时候，Block Formatting Context提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境中的元素不会影响到其它环境中的布局。比如浮动元素会形成BFC，浮动元素内部子元素的主要受该浮动元素影响，两个浮动元素之间是互不影响的。这里有点类似一个BFC就是一个独立的行政单位的意思。也可以说BFC就是一个作用范围。可以把它理解成是一个独立的容器，并且这个容器的里box的布局，与这个容器外的毫不相干。 触发BFC float的值不能为none overflow的值不能为visible display的值为table-cell, table-caption, inline-block中的任何一个 position的值不为relative和static BFC的约束条件 内部的Box会在垂直方向上一个接一个的放置 垂直方向的距离有margin决定(属于同一个BFC的两个相邻Box的margin会发生重叠，与方向无关) 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此 BFC的区域不会与float的元素区域重叠 计算BFC的高度时，浮动子元素也参与计算 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然 BFC的特性特性1：BFC会阻止垂直外边距折叠 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直margin的重叠，这个包括相邻元素或者嵌套元素，只要他们之间没有阻挡（比如边框、非空内容、padding等）就会发生margin重叠。 ①相邻兄弟元素margin重叠问题 1234567891011121314 &lt;style&gt; p&#123; color: #fff; background: #888; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;p&gt;abc&lt;/p&gt;&lt;/body&gt; 上面例中两个P元素之间距离本该为200px,然而实际上只有100px,发生了margin重叠。遇到这种情形，我们如何处理？只需要在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 解决方案 12345678910111213141516171819 &lt;style&gt; p&#123; color: #fff; background: #888; width: 200px; line-height: 100px; text-align:center; margin: 100px; &#125; .wrap&#123; overflow:hidden; &#125; &lt;/style&gt;&lt;body&gt; &lt;p&gt;ABC&lt;/p&gt; &lt;div class=\"wrap\"&gt; &lt;p&gt;abc&lt;/p&gt; &lt;/div&gt;&lt;/body&gt; ②父子元素margin重叠问题 1234567891011121314151617181920 &lt;style&gt; .box&#123; width:100px; height:100px; background:#ccc; &#125; .wrap &#123; background:yellow; &#125; .wrap h1&#123; background:pink; margin:40px; &#125; &lt;/style&gt;&lt;body&gt;&lt;div class=\"box\"&gt;box&lt;/div&gt;&lt;div class=\"wrap\"&gt; &lt;h1&gt;h1&lt;/h1&gt;&lt;/div&gt;&lt;/body&gt; 解决方案 上图wrap元素与h1元素之间l理论上本该有个40px的上下margin值,然而实际上父子元素并没有存在margin值，与此同时，两个div元素的间距为40px。遇到这种情形，我们如何处理？处理方法其实有很多，在wrap元素中添加:overflow:hidden;或者overflow：auto；使其父元素形成一个BFC；也可以在wrap元素中添加border：1px solid；或是padding：1px；这些都可以有效解决父子元素margin重叠问题。 特性2：BFC不会重叠浮动元素如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。比如下图的效果，参考例子 12345678910111213141516171819&lt;style&gt;.box1&#123; height: 100px; width: 100px; float: left; background: lightblue;&#125;.box2&#123;width: 200px; height: 200px; background: #eee;&#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"box1\"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div class=\"box2\"&gt;喂喂喂!大家不要生气嘛，生气会犯嗔戒的。悟空你也太调皮了，我跟你说过叫你不要乱扔东西，你怎么又……你看，我还没说完你就把棍子给扔掉了!月光宝盒是宝物，你把它扔掉会污染环境，要是砸到小朋友怎么办，就算砸不到小朋友，砸到花花草草也是不对的。&lt;/div&gt;&lt;/body&gt; 上图中，文字围绕着浮动元素排列，不过在这里，这显然不是我们想要的。此时我们可以为.box2元素的样式加上overflow:hidden；使其建立一个BFC,让其内容消除对外界浮动元素的影响。 这个方法可以用来实现两列自适应布局，效果不错，此时左边的宽度固定，右边的内容自适应宽度。如果我们改变文字的大小或者左边浮动元素的大小，两栏布局的结构依然没有改变！ 特性3：BFC可以包含浮动—-清除浮动我们都知道浮动会脱离文档流，接下来我们看看下面的例子： 12345678910111213141516171819&lt;style&gt; .par &#123; border: 5px solid #fcc; width: 300px; &#125; .child &#123; border: 5px solid #f66; width:100px; height: 100px; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=\"par\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 由于容器内两个div元素浮动，脱离了文档流，父容器内容宽度为零（即发生高度塌陷），未能将子元素包裹住。解决这个问题，只需要把把父元素变成一个BFC就行了。常用的办法是给父元素设置overflow:hidden","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}],"author":"刘涛"},{"title":"使用console进行 性能测试 和 计算代码运行时间","slug":"使用console进行-性能测试-和-计算代码运行时间","date":"2019-09-17T06:42:09.000Z","updated":"2019-10-11T07:11:00.817Z","comments":true,"path":"2019/09/17/使用console进行-性能测试-和-计算代码运行时间/","link":"","permalink":"http://yoursite.com/2019/09/17/使用console进行-性能测试-和-计算代码运行时间/","excerpt":"","text":"前言对于前端开发人员，在开发过程中经常需要监控某些表达式或变量的值，如果使用用 debugger 会显得过于笨重，最常用的方法是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。 traceconsole.trace()用来追踪函数的调用过程。 在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，console.trace()方法可以将函数的被调用过程清楚地输出到控制台上。 1&lt;button onclick=\"myFunction()\"&gt;跟踪轨迹&lt;/button&gt; 123456789101112131415function myFunction() &#123; console.log(1) myOtherFunction(); console.log(2)&#125;function myOtherFunction() &#123; console.log(3); myOtherFunction2(); console.log(4);&#125;function myOtherFunction2() &#123; console.trace();&#125; 打印结果： table使用console将对象以表格呈现 可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。 12345678910111213141516171819var Teletubbies = &#123; Tinky:&#123; name: 'Tinky', age: '3' &#125;, lala: &#123; name: 'lala', age: '6' &#125;, Daisy: &#123; name: 'Daisy', age: '4' &#125;, po:&#123; name:'po', age:'5' &#125;&#125;;console.table(Teletubbies); 打印结果： console.time进行时间计算计算程序的执行时间 可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上 12345console.time('计时器');for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125;&#125;console.timeEnd('计时器'); 以上代码可以计算出console.time(&#39;计时器&#39;)和console.timeEnd(&#39;计时器&#39;)之间的代码块所需要的时间。 还可以console.log配合Date对象计算除了console.time()还可以用console.log配合Date对象计算 1234567891011121314151617181920212223var beginTime = +new Date(); for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125; &#125;var endTime = +new Date();console.log(\"用时共计\"+(endTime-beginTime)+\"ms\");//或者var beginTime = new Date().getTime() for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125; &#125;var endTime = new Date().getTime()console.log(\"用时共计\"+(endTime-beginTime)+\"ms\");//或者var beginTime = Date.now()for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125; &#125;var endTime = Date.now()console.log(\"用时共计\"+(endTime-beginTime)+\"ms\"); 那么聪明的你肯定会问这三者的的区别 Date.now()与 new Date().getTime() 的区别它们都可以获取时间戳，但是实际上性能是不一样的（虽然差别不大，但是也算是一种性能的追求），可以做个测试 12345678910111213141516171819202122console.time('+new Date()')for(var i = 0; i &lt; 100000; i++) &#123; var o = + new Date()&#125;console.timeEnd('+new Date()')console.time('new Date().getTime:')for(var j = 0; j &lt; 100000; j++) &#123; var p = new Date().getTime();&#125;console.timeEnd('new Date().getTime:')console.time('Date.now()')for(var k = 0; k &lt; 100000; k++) &#123; var q = Date.now()&#125;console.timeEnd('Date.now()') //输出+new Date(): 42.31396484375msnew Date().getTime:: 33.93408203125msDate.now(): 24.561767578125ms 测试用例[https://jsperf.com/date-now-vs-new-date] profile使用console.profile测试程序性能 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。 1234567891011121314151617function parent() &#123; for (var i = 0; i &lt; 10000; i++) &#123; childA() &#125;&#125;function childA() &#123; for (var i = 0; i &lt; 2000; i++) &#123;&#125;&#125;console.profile('性能分析');parent();console.profileEnd('性能分析');//执行后//Profile '性能分析' started.//Profile '性能分析' finished.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://yoursite.com/tags/性能测试/"}],"author":"胡豪"},{"title":"前端性能优化一:性能指标","slug":"前端性能优化一-性能指标","date":"2019-09-16T02:27:35.000Z","updated":"2019-09-18T01:41:44.773Z","comments":true,"path":"2019/09/16/前端性能优化一-性能指标/","link":"","permalink":"http://yoursite.com/2019/09/16/前端性能优化一-性能指标/","excerpt":"","text":"如果我们想要提高我们的前端性能,那么首先你得先只知道怎么测量你的前端性能。但是哪些前端的性能指标我们应该关注呢?在Web1.0时代当我们讨论到前端性能指标用的最多的就是page load time。到了单页应用程序越来越多的时代,单一的page load time指标已经无法完全衡量前端性能了,因为一个单页应用程序page load time可能只触发了一次,但是用户会跟程序有很多的交互,每一个交互或者动作都需要有指标来衡量他的性能。 接下来就介绍几个比较重要的前端性能指标: first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间 first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas. 这两个指标对用户来说都是很重要的,这两个指标可以认为我们程序正在告诉我们的用户:我们正在正确工作。 First meaningful paint (FMP):这个指标标志着首屏最重要的一块区域的渲染,通常是用户最关注的区域。比如视频网站的视频播放区域,搜索网站的第一个搜索结果区域,又或者是购物网站的照片首图。通常来说浏览器很难清楚的了解哪一块是对于网站首屏来说是最关键的,所以开发者自己来告诉浏览器是哪一块是关键区域是很有必要的。 这也是非常关键的一个指标,通常如果用户能够快速的看到最重要的一块区域被渲染完成,即使其他的区域都还没有被渲染用户可能也不会注意到。 long task:我们都知道浏览器是单线程的在响应用户的操作时通过在任务队列里面增加任务,然后一个个的执行的.这意味着如果我们有一个长任务需要使用较长的时间,那么队列中的其他任务就只能等待,响应用户的操作就会变慢,或者动画就会变卡顿。 Time to interactive (TTI):这个指标表示浏览器已经渲染完了我们首屏需要显示的内容并且已经准备好接受用户的交互信息了,也标志着程序是否可用。程序暂时无法响应用户的交互有下面几个原因: 需要执行的javascript还没有执行完成。 有长任务阻绝着主线程.无法给用户响应。 指标 介绍 first paint (FP)/first contentful paint (FCP) 程序是否正确的开始渲染 First meaningful paint (FMP) 用户最关注的的首屏内容显示 Time to interactive (TTI) 程序是否可用 long task 程序使用的体验(是否响应延迟,动画卡顿) 还有一些其他的指标比如 First Input Delay(首次接受用户响应的延迟时间) First CPU Idle(第一次CPU闲置的时间):这些指标都和上面的指标有着直接的关系。 用户体验知道了这些指标,我们要把这些指标控制在什么样的时间才能给用户带来比较好的用户的体验呢,下面有这样一张表 时间 介绍 0到16ms 用户希望看的动画能够流畅,动画卡顿会带来非常差的用户体验,在浏览器上每秒钟渲染60帧动画就能够保持流畅,这大约就是16ms渲染一帧，这16ms包括了浏览器要渲染新的元素到页面上需要的时间，也就是说程序有大约10ms的时间可以进行操作。 0到100ms 在这个时间内响应用户的交互,用户会觉得响应是非常及时的 100到300ms 用户会感觉到有一些延迟 300到1000ms 当执行一些页面加载或者页面跳转的时候,在这个时间内是一个正常的加载跳转时间 1000ms或以上 超过1000ms(1秒),用户会对之前的操作渐渐失去耐心和注意力 10000ms或以上 当你的响应超过10秒,用户会感到烦躁,然后终止之前操作 上面的延迟时间取决于你使用什么样的网络和设备,比如你使用的电脑和wifi网络,用户在1000ms是一个比较现实的目标。但是当你设备是手机网络只有3G的时候在5000ms内加载才是更现实的目标。 响应时间:处理响应用户的操作在50ms以内在大多数的时间里，用户在使用程序时大多数的时间都在等待网站响应他们的操作比如点击一个按钮,在文本框中输入内容,而不是等待网站加载。那么网站比较理想的响应用户时间是在100ms以内。 100ms?不是50ms吗?我们的目标是在100ms以内响应用户的操作,那为什么处理用户的响应时间只有50ms?因为在我们接受到用户的输入时,可能会有别的任务正在执行.比如我们接受到用户在文本框中输入了一个A,这个时候浏览器正在执行别的任务,浏览器会把这个操作先加入到任务队列里,等浏览器执行完之前的任务才会去处理用户的响应。那么保守的估计为了让用户在100ms以内获得响应,我们的处理用户响应的执行时间就是50ms。 动画:生产每一帧动画的时间在10ms左右理论上来说只要没16ms渲染一帧,动画就会看起来是流畅的,但是浏览器大约需要6ms的时间来将每一帧渲染到画面上.因此产生每一帧动画的时间留给程序的大约就10ms左右。 主线程闲置时间越多越好主线程能够有尽可能多的闲置时间,那么当产生用户交互时就可以立马给用户响应。当主线程闲置时,浏览器会有很多的内部程序需要执行,比如闲置GC等。 主要内容渲染完成且程序可交互时间在5秒之内当页面加载缓慢,用户会失去耐心。网站的加载和响应速度直接影响用户的体验。 如何测试这些指标使用测试工具或者网站 Chrome DevTools-Audits WebPageTest 在真实的用户环境获得这些指标在介绍如何在用户真实环境中或者这些指标之前先介绍一些API performance.mark:创建给定标记的一个timestamp。 performance.measure:两个mark之间所经历的时间 PerformanceObserver:PerformanceObserver接口用于监控性能,可以根据传入的监控事件返回对应的PerformanceEntry对象。 获得FP/FCP1234567891011121314const observer = new PerformanceObserver((list) =&gt; &#123; for (const entry of list.getEntries()) &#123; //这里的name是为了区分'first-paint','first-contentful-paint' const metricName = entry.name; const time = Math.round(entry.startTime + entry.duration); reportToServer(&#123; eventCategory: 'Performance Metrics', eventAction: metricName, eventValue: time, nonInteraction: true, &#125;); &#125; &#125;); observer.observe(&#123;entryTypes: ['paint']&#125;); 根据你首屏最重要的元素获得FMP之前已经介绍过对于浏览器来说很那准确的知道每个网站对重要的一块区域显示的时间,那么只有开发者自己能够准确的找到最重要的一块区域获得FMP,假设我们网站首屏最重要的元素是一个图片就可以这么写. 12345&lt;img src=\"important.jpg\" onload=\"performance.clearMarks('img displayed'); performance.mark('img displayed');\"&gt;&lt;script&gt;performance.clearMarks(\"img displayed\");performance.mark(\"img displayed\");&lt;/script&gt; 获得TTI目前在PerformanceObserver中还没有办法获得TTI的接口,通过这个tti-polyfill可以知道这个tti 12345678910import ttiPolyfill from 'tti-polyfill.js';ttiPolyfill.getFirstConsistentlyInteractive().then((tti) =&gt; &#123; reportToServer(&#123; eventCategory: 'Performance Metrics', eventAction: 'TTI', eventValue: tti, nonInteraction: true, &#125;);&#125;); 监视长任务之前提到过,长任务可能会影响浏览器对用户响应速度或者造成动画的卡顿.那么能意识到长任务的存在并且把他缩短是很有必要的。(长任务API认为50ms以上任务的为长任务) 1234567891011121314const observer = new PerformanceObserver((list) =&gt; &#123; for (const entry of list.getEntries()) &#123; reportToServer(&#123; eventCategory: 'Performance Metrics', eventAction: 'longtask', eventValue: Math.round(entry.startTime + entry.duration), //这里的长任务会包含一个attribute //https://w3c.github.io/longtasks/#sec-TaskAttributionTiming eventLabel: JSON.stringify(entry.attribution), &#125;); &#125;&#125;);observer.observe(&#123;entryTypes: ['longtask']&#125;); 监视响应延迟长任务会阻塞线程导致浏览器无法响应用户操作,之前也提到过如果能在100ms以内响应用户的操作就不会让用户觉得卡顿,那么如果能够监控到你关键交互的响应时间也是很有必要的 1234567891011121314const submitBtn = document.querySelector('#submit');submitBtn.addEventListener('click', (event) =&gt; &#123; const lag = performance.now() - event.timeStamp; if (lag &gt; 100) &#123; reportToServer(&#123; eventCategory: 'Performance Metric' eventAction: 'input-latency', eventLabel: '#subscribe:click', eventValue: Math.round(lag), nonInteraction: true, &#125;); &#125;&#125;); 幸存者偏差当我们的程序如果加载速度很慢(比如加载了过多的js),那么真实用户在网络环境不一致的情况下,有些响应过慢的用户可能早早的在加载完成前就已经退出网站,那么这里就会有一个幸存者偏差的问题.你监控的用户都是已经加载完成的用户。为了能够同时检测到退出的用户. 12345678910111213141516171819202122///写在最头部window.__trackAbandons = () =&gt; &#123; // 去掉事件监听那么这个方法只执行一次 document.removeEventListener('visibilitychange', window.__trackAbandons); //因为我们还没有加载report js API 所以我们要让服务器提供一个post接口在接收这次请求 const ANALYTICS_URL = 'https://ANALYTICS_URL'; const TRACKING_ID = 'TRACKING_ID'; const CLIENT_ID = (Math.random() * Math.pow(2, 52)); // Send the data to Google Analytics via the Measurement Protocol. navigator.sendBeacon &amp;&amp; navigator.sendBeacon(ANALYTICS_URL, [ 'v=1', 't=event', 'ec=Load', 'ea=abandon', 'ni=1', 'dl=' + encodeURIComponent(location.href), 'dt=' + encodeURIComponent(document.title), 'tid=' + TRACKING_ID, 'cid=' + CLIENT_ID, 'ev=' + Math.round(performance.now()), ].join('&amp;'));&#125;;//visibilitychange可以监听页面unload事件//https://developer.mozilla.org/en-US/docs/Web/API/Document/visibilitychange_eventdocument.addEventListener('visibilitychange', window.__trackAbandons); 结论性能对现在的程序越来越重要,那么在一个程序需要进行性能优化的时候.个人认为可以按照这样的一个顺序进行: 数据收集-&gt;讨论性能指标阀值-&gt;针对性能优化-&gt;数据重新验证优化结果 这里主要讨论了我们一些性能指标和收集性能指标的方法,后面会讨论如何针对每一块进行优化。","categories":[],"tags":[]},{"title":"javascript中的Map","slug":"javascript中的Map","date":"2019-08-26T02:53:41.000Z","updated":"2019-09-18T09:21:45.122Z","comments":true,"path":"2019/08/26/javascript中的Map/","link":"","permalink":"http://yoursite.com/2019/08/26/javascript中的Map/","excerpt":"","text":"探究javascript Map什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。ECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。 语法1new Map([iterable]) iterable (可迭代传参)Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 描述一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。 键的比较是基于 “SameValueZero” 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择： 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。 Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。 Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 Map 在涉及频繁增删键值对的场景下会有些性能优势。 最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;object获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。 属性 Map.length get Map[@@species] Map.prototype Map 实例*属性Map.prototype.constructor返回一个函数，它创建了实例的原型。默认是Map函数。 Map.prototype.size返回Map对象的键/值对的数量。 *方法Map.prototype.clear()移除Map对象的所有键/值对 。 Map.prototype.delete(key)如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false Map.prototype.entries()返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg])按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。 Map.prototype.get(key)返回键对应的值，如果不存在，则返回undefined。 Map.prototype.has(key)返回一个布尔值，表示Map实例是否包含键对应的值。 Map.prototype.keys()返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。 Map.prototype.set(key, value)设置Map对象中键的值。返回该Map对象。 Map.prototype.values()返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。 Map.prototype@@iterator返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 实例使用 Map 对象12345678910111213141516171819202122var myMap = new Map(); var keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;, keyString = \"a string\"; // 添加键myMap.set(keyString, \"和键'a string'关联的值\");myMap.set(keyObj, \"和键keyObj关联的值\");myMap.set(keyFunc, \"和键keyFunc关联的值\"); myMap.size; // 3 // 读取值myMap.get(keyString); // \"和键'a string'关联的值\"myMap.get(keyObj); // \"和键keyObj关联的值\"myMap.get(keyFunc); // \"和键keyFunc关联的值\" myMap.get(\"a string\"); // \"和键'a string'关联的值\" // 因为keyString === 'a string'myMap.get(&#123;&#125;); // undefined, 因为keyObj !== &#123;&#125;myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125; 使用 for..of 方法迭代 Map12345678910111213141516171819202122var myMap = new Map();myMap.set(0, \"zero\");myMap.set(1, \"one\");for (var [key, value] of myMap) &#123; console.log(key + \" = \" + value);&#125;// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"for (var key of myMap.keys()) &#123; console.log(key);&#125;// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"for (var value of myMap.values()) &#123; console.log(value);&#125;// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"for (var [key, value] of myMap.entries()) &#123; console.log(key + \" = \" + value);&#125;// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\" 使用 forEach() 方法迭代 Map1234myMap.forEach(function(value, key) &#123; console.log(key + \" = \" + value);&#125;)// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\" Map 与数组的关系123456789101112var kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象var myMap = new Map(kvArray);myMap.get(\"key1\"); // 返回值为 \"value1\"// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组console.log(Array.from(myMap)); // 输出和kvArray相同的数组// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组console.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"] 复制或合并 Maps12345678var original = new Map([ [1, 'one']]);var clone = new Map(original);console.log(clone.get(1)); // oneconsole.log(original === clone); // false. Useful for shallow comparison 请记住，数据本身未被克隆。 Map对象间可以进行合并，但是会保持键的唯一性。 123456789101112131415161718var first = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);var second = new Map([ [1, 'uno'], [2, 'dos']]);// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。// 展开运算符本质上是将Map对象转换成数组。var merged = new Map([...first, ...second]);console.log(merged.get(1)); // unoconsole.log(merged.get(2)); // dosconsole.log(merged.get(3)); // three Map对象也能与数组合并： 1234567891011121314151617var first = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);var second = new Map([ [1, 'uno'], [2, 'dos']]);// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。var merged = new Map([...first, ...second, [1, 'eins']]);console.log(merged.get(1)); // einsconsole.log(merged.get(2)); // dosconsole.log(merged.get(3)); // three 以上讲的是Map，那不得不说map( )是什么ECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法1var new_array = array.map(function callback(currentValue,index,arr), thisValue) 参数callback 生成新数组元素的函数，使用三个参数： currentValue callback 数组中正在处理的当前元素。 index可选 callback 数组中正在处理的当前元素的索引。 array可选 callback map 方法被调用的数组。 thisArg可选 执行 callback 函数时使用的this 值。 示例1234var array1 = [1,3,6];const map1 = array1.map(x =&gt; x *2);console.log(map1); // &gt; Array [2, 6, 12] 1234567891011var array1 = [1, 3,6];const map1 = array1.map(x =&gt; &#123; if (x == 3) &#123; return x * 2; &#125;&#125;); console.log(map1);// &gt; Array [undefined, 6, undefined] 出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了 123456789101112var array1 = [1, 3,6];const map1 = array1.map(x =&gt; &#123; if (x == 3) &#123; return x * 2; &#125; return x&#125;); console.log(map1);// &gt; Array [2, 6, 12] 可以使用 map 重新格式化数组中的对象 12345678910111213141516var oldArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;];var nowArr = oldArray.map(function(obj) &#123; var rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// nowArr 数组为： [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;], // oldArray 数组未被修改: // [&#123;key: 1, value: 10&#125;, // &#123;key: 2, value: 20&#125;, // &#123;key: 3, value: 30&#125;] 用ES5模拟实现ES6中的Map类与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：1.set(key,value):向字典中添加新元素。 2.remove(key):使用键名从字典中移除相应的元素。 3.has(key):如果某个键值存在于字典中，返回true，否则返回false。 4.get(key):通过键名找到指定的值并返回。 5.clear():清空字典。 6.size():返回字典中元素个数。 7.values():将字典所有值以数组形式返回。 8.getItems():返回items变量，代表字典本身。 1234567891011121314151617181920212223242526272829303132333435363738function Map() &#123; var items = &#123;&#125;; this.has = function(key)&#123; //has方法判断某个键值是否在字典中 return key in items; &#125;, this.set = function(key,value)&#123; //set方法为字典添加新元素或更新已有元素 items[key] = value; &#125;, this.remove = function(key)&#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false; &#125;, this.get = function(key)&#123; return this.has(key)?items[key]:undefined; &#125;, this.values = function()&#123; var values = []; //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。 for(var k in items)&#123; if (this.hasOwnProperty(k)) &#123; values.push(items[k]); &#125; &#125; return values; &#125;, this.clear = function()&#123; items = &#123;&#125;; &#125;, this.size = function()&#123; return Object.Keys(items).length; &#125;, this.getItems = function()&#123; return items; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"author":"胡豪"},{"title":"如何为平台设计一个插件系统","slug":"如何为平台设计一个插件系统","date":"2019-08-25T04:19:13.000Z","updated":"2019-09-03T07:09:14.693Z","comments":true,"path":"2019/08/25/如何为平台设计一个插件系统/","link":"","permalink":"http://yoursite.com/2019/08/25/如何为平台设计一个插件系统/","excerpt":"","text":"随着web浏览器的发展,浏览器的性能越来越好,WebGL和WebAssembly提供越来越多的可能性。很多原本只能在终端运行的程序都开始开发web版本例如CAD的web版本,PS的web版本,figma。这一个个的设计协作平台原本在终端都有插件机制。那么如果在web端能提供一个插件机制,对于有一点编程能力的用户,就可以提供更好的用户体验和开发更多的可能性。如何开发一个好的插件系统呢? 一个javascript的插件系统需要满足以下几个方面: 安全性 插件不可以发送请求 插件和程序模块不可以非法的调用相互的数据 插件不可以在不受约束的情况下执行 插件不可以任意的修改UI,从而给用户造成误导 稳定性 插件不能影响主程序的稳定性 插件不可以修改主程序中的常量 易开发性 插件应该是容易开发的,即使是面对没有那么多编程经验的设计师,也应该是容易开发的。 插件要可以使用调试工具。 效率 插件的执行效率不能太慢从而影响整个主程序的效率。 方案一:iframe沙盒实现方式当我们在程序中执行第三方的代码的时候,首先第一个应该会想到的就是iframe。iframe不是我们每天都会用到的html标签。要理解为什么iframe为什么安全，我们有不要想一下iframe标签是用来干什么的。 iframe比较典型的使用场景就是在一个网页中嵌入一个其他的网页。举个例子来说,你需要在网站中嵌入谷歌地图的页面来实现地图的展现功能。你不会希望谷歌地图的页面中的代码有能力访问你本身的一些代码和敏感数据,相应的谷歌地图也不希望你能够访问他页面中的数据和代码。 这意味着一切和iframe的交互都受限于浏览器。当iframe和原网页有不同的域(imow.cn和google.com),他们是完全隔绝的。那么网页和iframe交互的唯一办法就是通过 postMessage。这个message是一个string。需要交互的双方可以选择忽略这个message或者做对应的动作。 iframe和原网页是完全独立的,其实,如果你想要的话浏览器允许我们通过另外一个线程来创建一个iframe。这里. 当我们了解了iframe是如何工作了以后,我们可以在我们需要执行第三方插件的时候创一个iframe，将插件的代码在iframe中执行。在iframe中插件可以执行任何代码,也不会影响到主程序,除非通过提前申明好的message。同时我们可以给iframe的域名设置为null,这意味着根据浏览器跨域保护策略,iframe无法给域名发送任何请求。 iframe就这样很简单的成为我们执行第三方插件的沙盒环境,他的安全性也通过浏览器来保证。插件在沙盒中执行,通过主程序提供的api(postMeassge)和主程序进行交互。代码就像下面这个样子 12345678const scene = await main.loadScene() // 从主程序获取界面数据scene.selection[0].width *= 2 // 修改界面数据scene.createNode(&#123; type: 'RECTANGLE', x: 10, y: 20, ...&#125;)await main.updateScene() // 向主程序发送修改后的界面数据 这里主要的代码是loadScene(发送消息给主程序,然后获得主程序界面的document拷贝),然后修改完以后通过调用updateScene(发送更新消息给主程序).这里需要注意的是 我们拷贝了整个document而不是在每次需要读取或者修改属性的时候通过message传输.postMessage每次传输需要0.1ms.每秒钟大约只允许1000 messages。 我们没有让插件直接使用postMessage api,而是包装了一个api给插件用户使用,这样使用起来不会太笨重。 问题#1:async/await 使用起来不是那么方便这种实现方式第一个问题就是对于一些不那么了解javascript的新手或者设计师来说,async/await关键字还是非常陌生的。但是要使用postMessge是一个异步操作。所以不可避免的要使用async/await来控制异步流程。但是如果只是需要在开头和结束的时候调用我们的api还方便,我们可以告诉用户在调用我们的api时候在前面加上async/await即使他们不知道这个关键字的作用也不会对他们的操作造成非常大的困扰。 但是问题是有些插件需要执行非常复杂的逻辑,在修改一个layout的属性的时候有时候会引起其他好几个layout的更新。比如更新外层的layout的属性之后,内部的layout的属性也可能发生了更新,这个时候你需要先提交你的属性,然后在重新或者视图的属性,那这个时候你的代码就会变成这样: 123456789await mian.loadScene()... 操作 ...await mian.updateScene()await mian.loadScene()... 操作 ...await mian.updateScene()await mian.loadScene()... 操作 ...await mian.updateScene() 这个代码一下子就变的不可控了,而且用户也很难确认什么时候应该要提交我的属性更新。 问题#2:拷贝视图给iframe的操作是非常昂贵的iframe这种实现方式的第二个问题就是,当你需要给插件发送视图信息的时候你需要序列化你的document发送给你iframe，当你的视图非常非常大的时候,这个序列化的操作是非常耗时的,甚至会导致内存溢出。即使我们可以使用增量的加载数据或者懒加载数据这种方式仍然有他的问题: 首先这种方式是非常难实现的,即使有比较好的方案实现了以后,面对比较大的视图,性能仍然不是很理想,而且对于插件开发者来说是非常难理解的，这违背了我们的插件易开发性。 异步方法需要等待你需要到的数据达到才能开始后面的操作,对于异步流程控制来说也是一个挑战(steam? Rx?)。 总的来说如果你的主程序有非常大的document要交给第三方插件来进行操作,那么iframe的这种实现方式就不是非常理想的解决方案 eval如果能在主线程上执行插件代码,那么在性能上就会好很多,但是我们又不能简单的eval(code)执行插件代码,因为这样是很不安全的。 什么导致eval不安全如果我们退一步想:是什么使eval方法不安全?如果我们只是执行一段很单纯的代码 12let code = 'let a = (7 + 1) * 8;'eval(code) 如果只是一段逻辑代码,那么这个代码是没有什么不安全的。之所以认为eval执行的代码不安全是因为在插件代码中有可能会发送网络请求,修改全局的state变量,或者直接修改dom对象等等这些使得我们的插件代码变的不可控,换句话来说是插件具有浏览器api访问的能力让我们插件的代码变的不可控。 是不是能把全局的对象藏起来?如果我们能把全局的对象藏起来,保证插件代码中只能做变量的赋值或者一些if判断的逻辑代码,没有了全局对象xhr,插件将无法发送请求,没有document对象,插件也不具备访问dom的能力,那么插件能力是不是能在我们的可控范围里面了。 隐藏全局对象,理论上是可行的。但是我们很难仅仅通过隐藏全局对象来创建一个绝对安全的运行环境。举例来说,我们现在把window对象设置为null,但是代码还是可以通过({}).constructor来访问全局对象。所以找到所有有可能访问危险api的对象,把所有的路全部堵死是非常难的一件事情。 是不是我们可以找到一个这些全局对象从一开始就不存在的沙盒环境? 方案二:将javascript编译成WebAssemblyDuktape是一个轻量级的用c++写的javascript解释器,他可以将javascript编译成WebAssembly,经过test262测试之后,可以确定他全面的支持了ES5的语法。 这种实现方法有以下几种优缺点 首先这是一种安全的执行环境,因为Duktape不支持任何的浏览器API。作为WebAssembly执行,他本身就是一个沙盒环境,他可以通过提供一个白名单的API和主程序进行交互。 这个解释器是运行在主线程上的。这意味着我们可以创建一个基于主线程的API。(共享document等) 他可能会比原本的javascript慢一些,因为JIT解释器在编译的时候做了很多的优化,但是作为WebAssembly我相信这个性能应该也是可以被接受的。 他需要用浏览器来编译WebAssembly,这会有一些性能消耗。 浏览器的调试工具就不能用了。 看起来好像不错，但是他作为一个线上项目的表现到底怎么样呢?一个javascript引擎来执行另外一个引擎?WebAssembly本身也是比较新的一个东西，我们是不是真的需要一个相对复杂的解决方案?有没有更简单的方法了? 方案三:Realms这个技术可以创建一个沙盒环境来支持插件,当我看到他readme文档的时候,就一下子提起了我的兴趣,Intuitions sandbox iframe without DOM principled version of Node’s ‘vm’ module sync Worker 这不就是我们需要的吗?他的代码看起来是这个样子 123456789let g = window; // outer globallet r = new Realm(); // root realmlet f = r.evaluate(\"(function() &#123; return 17 &#125;)\");f() === 17 // trueReflect.getPrototypeOf(f) === g.Function.prototype // falseReflect.getPrototypeOf(f) === r.global.Function.prototype // true 是不是很酷。这个技术其实可以用现在已有的但是不常用的一个javascript功能来实现。代码想这样 123456function simplifiedEval(scopeProxy, code) &#123; 'use strict' with (scopeProxy) &#123; eval(code) &#125;&#125; 这个就像一个简单版本的Realms,但是管中窥豹,我们可以看见两个关键代码with和Proxy对象。 with(obj)表达式创建了一个作用域,当寻找变量的时候,可以使用这个obj的属性.看个例子: 123456with (Math) &#123; a = PI * r * r x = r * cos(PI) y = r * sin(PI) console.log(x, y)&#125; 在这个例子里,当我们访问PI,cos,sin的时候,就会找到Math的属性。但是console因为Math没有就仍然会找到全局对象。 知道了with表达式,接下来就是Proxy对象,这个对象有下面几个特性 他是一个普通的javascript对象,可以通过obj.x访问对象的属性值. 我们可以实现一个对象属性的get方法来实现obj.x操作,实际上只执行这个get方法. 123456789const scopeProxy = new Proxy(whitelist, &#123; get(target, prop) &#123; // target === whitelist if (prop in target) &#123; return target[prop] &#125; return undefined &#125;&#125; 接下来我们就可以把这个scopeProxy对象作为参数传入with中,他就捕获作用域所有的变量查找,在这个scopeProxy的get方法中进行查找这个变量: 1234with (scopeProxy) &#123; document // undefined! eval(\"xhr\") // undefined!&#125; 这里只有whitelist的属性会被返回,其他都会返回undefined.但是其实利用一些类似({}).constructor表达式还是有可能访问全局对象的.此外,这个沙盒其实还是需要访问一些全局对象的方法的,类似Object.keys 为要给我们的插件系统访问受限全局api的方法然后又不会把window搞乱,Realms沙盒通过创建一个和主程序同源的iframe用来拷贝需要用到的全局API。这个iframe和我们第一种实现中创建的iframe不一样,他不是作为运行程序的沙盒。当你创建一个和主程序同源的iframe以后 他会拷贝一份分开的全局对象(比如:Object.prototype)。 这些全局对象可以从父文档中访问,也就是说我们可以在Realms访问这些全局对象. 我们将这些全局对象放入到Proxy的白名单(whitelist)中，这样在插件代码中就可以访问这些全局对象了。通过创建iframe来拷贝全局对象有一个很重要的好处:即使是通过({}).constructor对象访问到的全局对象,也会是iframe中拷贝的全局对象。这样的实现方式有这些优点: 他在主程序中运行。 因为他本身还是javascript,所以他仍然用JIT编译解析,浏览器对javascript的优化还是有效。 浏览器开发工具也还是有效的。 那么就剩下最后一个问题.他真的够安全了吗? 这样看起来结合了iframe的Realms看起来似乎已经挺不错的了,而且他本身也是tc39下面的项目,所以可靠性应该也不错。但是光有一个安全的沙盒环境是不够的,你的插件肯定需要和主程序进行交互,那么我们就肯定要为我们的插件系统提供API,提供给插件的API系统也一定要是安全的。 举个例子,console.log是浏览器的api是不是javascript功能,那么我们要为插件系统提供一个console.log方法,我们可以这样写: 1realm.evaluate(USER_CODE, &#123; log: console.log &#125;) 或者为了隐藏方法本身,我们可以要求他只传参数 1realm.evaluate(USER_CODE, &#123; log: (...args) =&gt; &#123; console.log(...args) &#125; &#125;) 看起来是这么回事,很可惜,这其实是一个安全漏洞,即使是第二种方法我们还是在Realms外面创建了一个匿名方法,然后直接传入到Realms中。这意味着插件可以通过方法的原型链访问到外部。 正确创建console.log方法的方法是,将这个方法通过Realms包裹起来在Realms内部创建像这样 12345678910111213141516171819// 创建一个工厂方法// 这个工厂方法返回一个新的方法他保存一个闭包const safeLogFactory = realm.evaluate(` (function safeLogFactory(unsafeLog) &#123; return function safeLog(...args) &#123; unsafeLog(...args); &#125; &#125;)`);// 创建一个安全的方法const safeLog = safeLogFactory(console.log);const outerIntrinsics = safeLog instanceof Function;const innerIntrinsics = realm.evaluate(`log instanceof Function`, &#123; log: safeLog &#125;);if (outerIntrinsics || !innerIntrinsics) throw new TypeError(); // 使用realm.evaluate(`log(\"Hello outside world!\")`, &#123; log: safeLog &#125;); 通常来说,在沙盒中不应该能够访问到外部的任何对象包括作用域。因为我们的插件和主程序运行在一个线程中，所以在提供api的时候要非常小心,特别是当你的api需要在realm内部操作外部对象的时候。这对于开发api的开发人员来说是不是有点太不友好了，一不小心就产生了安全隐患，(todo:完善起来)。 结论如果我们的主程序不是特别复杂而且庞大的话,第一种通过iframe的实现方式应该是最为简单的。 如果我们的主程序本身就是通过WebAssembly创建的例如CAD网页版,我们想第二种方式可能是比较适合他们的,或者他们提供更加优秀的基于WebAssembly的解决方案 最后一种方式如果我们能提供一种简单又安全的开发API的办法,这应该是一种性价比比较高的解决方案。","categories":[],"tags":[]},{"title":"call apply bind的区别和用法","slug":"call apply bind的区别和用法","date":"2019-08-22T00:49:23.000Z","updated":"2019-09-03T07:09:14.689Z","comments":true,"path":"2019/08/22/call apply bind的区别和用法/","link":"","permalink":"http://yoursite.com/2019/08/22/call apply bind的区别和用法/","excerpt":"","text":"前言在JavaScript中，call、apply和bind是Function对象自带的三个方法，它们最主要的作用是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。 call和applay的共同点它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。 为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。 改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。 另外，它们的写法也很类似，调用 call 和 apply 的对象，必须是一个函数 Function。 接下来，就会说到具体的写法，那也是它们区别的主要体现。 call和apply的区别它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。 call的写法 1Function.call(obj,[param1[,param2[,…[,paramN]]]]) 需要注意以下几点： 调用 call 的对象，必须是个函数 Function。 call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空 1234567 function func (a,b,c) &#123;&#125;func.call(obj, 1,2,3)// func 接收到的参数实际上是 1,2,3func.call(obj, [1,2,3])// func 接收到的参数实际上是 [1,2,3],undefined,undefined applay的写法 1Function.apply(obj[,argArray]) 需要注意一下几点 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。 12345678910func.apply(obj, [1,2,3])// func 接收到的参数实际上是 1,2,3func.apply(obj, &#123; 0: 1, 1: 2, 2: 3, length: 3&#125;)// func 接收到的参数实际上是 1,2,3 bind的使用bind()函数回创建一个新的函数(称为绑定函数) bind是ES5新增的一个方法 传参和call或apply类似 不会执行对应的函数，call或apply会自动执行对应的函数 返回对函数的引用 bind的写法 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用。 举例说明： 12345678910 function add (a, b) &#123; return a + b;&#125;function sub (a, b) &#123; return a - b;&#125;add.bind(sub, 5, 3); // 这时，并不会返回 8add.bind(sub, 5, 3)(); // 调用后，返回 8 如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。 应用场景：继承 1234567891011121314151617181920 function Animal(name,weight)&#123; this.name = name; this.weight = weight;&#125;function Cat()&#123; // 在call中将this作为thisArgs参数传递 // Animal方法中的this就指向了Cat中的this // 所以Animal中的this指向的就是cat对象 // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性 // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的 Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function()&#123; console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); &#125;&#125;//当通过new运算符产生了cat时，Cat中的this就指向了cat对象var cat = new Cat();cat.say();//输出=&gt; I am cat,my weight is 50 原型扩展在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach 123456789101112131415function test()&#123; // 检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); // 判断arguments是否有forEach方法 console.log(arguments.forEach); // undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item)&#123; console.log(item); // 1 2 3 4 &#125;);&#125;test(1,2,3,4); 总结call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。 bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。 关于 call 和 apply 的便捷记忆法： 12345678910111213猫吃鱼，狗吃肉，奥特曼打小怪兽。有天狗想吃鱼了猫.吃鱼.call(狗，鱼)狗就吃到鱼了猫成精了，想打怪兽奥特曼.打小怪兽.call(猫，小怪兽)猫也可以打小怪兽了","categories":[],"tags":[]},{"title":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","slug":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","date":"2019-08-06T02:40:30.000Z","updated":"2019-09-03T07:09:14.690Z","comments":true,"path":"2019/08/06/cookie、localstorage和sessionstorage三者之间的区别以及使用方式/","link":"","permalink":"http://yoursite.com/2019/08/06/cookie、localstorage和sessionstorage三者之间的区别以及使用方式/","excerpt":"","text":"前言前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。 使用方式cookie： 保存cookie值 123var dataCookie=&apos;110&apos;; document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie; 获取指定名称的cookie值 1234567891011 function getCookie(name) &#123; //获取指定名称的cookie值// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));if(arr != null) &#123; console.log(arr); return unescape(arr[2]);&#125;return null;&#125; var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。 localStorage和sessionStorage：localStorage和sessionStorage所使用的方法是一样的, 下面以sessionStorage为例子： 1234567891011121314var name=&apos;sessionData&apos;;var num=120;sessionStorage.setItem(name,num);//存储数据sessionStorage.setItem(&apos;value2&apos;,119);let dataAll=sessionStorage.valueOf();//获取全部数据console.log(dataAll,&apos;获取全部数据&apos;);var dataSession=sessionStorage.getItem(name);//获取指定键名数据var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值 console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);sessionStorage.removeItem(name); //删除指定键名数据 console.log(dataAll,&apos;获取全部数据1&apos;); sessionStorage.clear();//清空缓存数据：localStorage.clear(); console.log(dataAll,&apos;获取全部数据2&apos;); 三者的异同：生命周期： cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效 localStorage：除非被手动清除，否则将会永久保存。 sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。 存放数据大小： cookie：4kb左右 localStorage和sessionStorage：可以保存5MB的信息 http请求： cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景：从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。 storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。 localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。 浏览器的支持情况: localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。 cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie： 12345if(navigator.cookieEnabled) &#123; alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie &#125; else &#123; alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie &#125; 数据存放处： Cookie、localStorage、sessionStorage数据存放处 各浏览器Cookie大小、个数的限制 1. 浏览器允许每个域名所包含的cookie数： Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。 Firefox每个域名cookie限制为50个。 Opera每个域名cookie限制为30个。 Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。 注：“每个域名cookie限制为20个”将不再正确！ 2. 当很多的cookie被设置，浏览器如何去响应： 除Safari（可以设置全部cookie，不管数量多少），有两个方法： 最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。 Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。 3. 不同浏览器间cookie总大小也不同： Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。 Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。 Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。 注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。最后：不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。","categories":[],"tags":[]},{"title":"javascript垃圾回收机制","slug":"javascript垃圾回收机制","date":"2019-07-01T02:53:41.000Z","updated":"2020-02-25T09:33:33.079Z","comments":true,"path":"2019/07/01/javascript垃圾回收机制/","link":"","permalink":"http://yoursite.com/2019/07/01/javascript垃圾回收机制/","excerpt":"","text":"前言其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码 1234567891011121314151617181920var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var c = &apos;a&apos; function unused() &#123; if (originalThing) &#123; console.log(&quot;hi&quot;); &#125; &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(&apos;1111&apos;); &#125; &#125;;&#125;;setInterval(replaceThing,1000) 最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步: 识别哪些对象需要被回收。 回收/重复使用需要被回收对象的内存。 压缩/整理内存(有些可能没有) 而常见的识别对象是否需要回收的机制有下面几种: 引用计数 (Python) 逃逸分析 (Java) Tracing/Reachable 追踪分析 (javascript) 今天就主要看一下V8中GC的具体实现方式 Tracing/Reachable 追踪分析GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。 The Generational HypothesisGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。 ScavengerV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。 第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。 第二次GC 在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。 ParallelParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。 Scavenger平行调度,同时有多个帮助线程和主线程参与 Major GCMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。 ConcurrentConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。 Major GC同步调度 什么时候会执行GC在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。 我们可以通过手动设置来设置新生代和老代的space大小: 12node --max-old-space-size=1700 index.jsnode --max-new-space-size=1024 index.js 空闲时GC虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过requestIdleCallback事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解React 16 fiber的实现)。 利用主线程空闲时间进行GC Incremental那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。 将一整个GC切分成一小块GC任务,插入到主线程中进行 总结不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。 最后的最后将之前的内存泄漏代码一步步的推演: 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。所有标记完成。此时: 123456789 from-space to-spacetheThing (reachable) theThingreplaceThing (reachable) replaceThingunused originThingoriginThing (reachable) =&gt; longStr c someMethodlongStr (reachable) someMethod (reachable) 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2 第二次GC开始 123456789 from-space to-space old-spacetheThing (reachable) theThing originThing -&gt; theThingreplaceThing (reachable) replaceThing theThing -&gt; longStrunused originThing theThing -&gt; someMethodoriginThing (reachable) =&gt; longStr =&gt; someMethod -&gt; originThing(closure) c someMethodlongStr (reachable) someMethod (reachable) 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法 123456 old-spaceoriginThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure) 结论主要导致内存泄漏的原因是 闭包是在声明的时候被创建的,而不是执行的时候被创建的。 然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。 12345678910111213141516171819202122var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var c = &apos;a&apos; function unused() &#123; if (originalThing) &#123; console.log(&quot;hi&quot;); &#125; &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(&apos;1111&apos;); &#125; &#125;; originalThing = null; //手动释放局部作用域中的变量&#125;;setInterval(replaceThing,1000)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"==的隐式转换","slug":"==的隐式转换","date":"2019-04-28T01:13:40.000Z","updated":"2019-09-18T09:22:59.354Z","comments":true,"path":"2019/04/28/==的隐式转换/","link":"","permalink":"http://yoursite.com/2019/04/28/==的隐式转换/","excerpt":"","text":"前言==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的 探究==1234567891011121314151617181920212223242526272829303132333435363738 对象 \\ 字符串 布尔值 \\ / 数值1. 对象和布尔值比较对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字[] == true; //false []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false2. 对象和字符串比较对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。[1,2,3] == '1,2,3' // true [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;3. 对象和数字比较对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。[1] == 1; // true `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; '1' =&gt; 1 所以结果为true4. 字符串和数字比较字符串和数字进行比较时，字符串转换成数字，二者再比较。'1' == 1 // true5. 字符串和布尔值比较字符串和布尔值进行比较时，二者全部转换成数值再比较。'1' == true; // true 6. 布尔值和数字比较布尔值和数字进行比较时，布尔转换为数字，二者比较。true == 1 // true7. other来看一个有趣的题[] == false;![] == false;还有一些需要记住的，像：undefined == null //true undefined和null 比较返回true，二者和其他值比较返回falseNumber(null) //0 特殊等式NaN 和 -0 在相等比较时的表现有些特别。由于NaN和自身不相等，所以必须使用ES6中的Number.isNaN(..) (或者polyfill)。而- 0 等于 0 （对于===也是如此），因此我们必须使用isNegZero(..)这样的工具函数。 ES6 中新加入一个方法Object.is(..)来判断两个值是否绝对相等，可以用来处理上述所有特殊情况： 123456var a = 2 / \"hello\";var b = -3 * 0;Object.is(a,NaN); //trueObject.is(b,-0); //trueObject.is(b,0); //false 小结能使用 == 或 === 就尽量不要使用Object.is(..),因为前者效率更高，更为通用。Object.is(..)主要用来处理那些特殊的相等比较。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js基础","slug":"js基础","permalink":"http://yoursite.com/tags/js基础/"}],"author":"胡豪"}]}