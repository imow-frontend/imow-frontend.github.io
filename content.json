{"meta":{"title":"阿母工业前端组","subtitle":null,"description":null,"author":"中力前端组","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-29T09:09:19.000Z","updated":"2019-09-03T07:09:14.694Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-29T09:09:57.000Z","updated":"2019-09-03T07:09:14.695Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用console进行 性能测试 和 计算代码运行时间","slug":"使用console进行-性能测试-和-计算代码运行时间","date":"2019-09-17T06:42:09.000Z","updated":"2019-09-17T08:17:07.276Z","comments":true,"path":"2019/09/17/使用console进行-性能测试-和-计算代码运行时间/","link":"","permalink":"http://yoursite.com/2019/09/17/使用console进行-性能测试-和-计算代码运行时间/","excerpt":"","text":"前言对于前端开发人员，在开发过程中经常需要监控某些表达式或变量的值，如果使用用 debugger 会显得过于笨重，最常用的方法是会将值输出到控制台上方便调试。最常用的语句就是console.log(expression)了。 traceconsole.trace()用来追踪函数的调用过程。 在大型项目尤其是框架开发中，函数的调用轨迹可以十分复杂，console.trace()方法可以将函数的被调用过程清楚地输出到控制台上。 1&lt;button onclick=\"myFunction()\"&gt;跟踪轨迹&lt;/button&gt; 123456789101112131415function myFunction() &#123; console.log(1) myOtherFunction(); console.log(2)&#125;function myOtherFunction() &#123; console.log(3); myOtherFunction2(); console.log(4);&#125;function myOtherFunction2() &#123; console.trace();&#125; 打印结果： table使用console将对象以表格呈现 可将传入的对象，或数组以表格形式输出，相比传统树形输出，这种输出方案更适合内部元素排列整齐的对象或数组，不然可能会出现很多的 undefined。 12345678910111213141516171819var Teletubbies = &#123; Tinky:&#123; name: 'Tinky', age: '3' &#125;, lala: &#123; name: 'lala', age: '6' &#125;, Daisy: &#123; name: 'Daisy', age: '4' &#125;, po:&#123; name:'po', age:'5' &#125;&#125;;console.table(Teletubbies); 打印结果： console.time进行时间计算计算程序的执行时间 可以将成对的console.time()和console.timeEnd()之间代码的运行时间输出到控制台上 12345console.time('计时器');for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125;&#125;console.timeEnd('计时器'); 以上代码可以计算出console.time(&#39;计时器&#39;)和console.timeEnd(&#39;计时器&#39;)之间的代码块所需要的时间。 还可以console.log配合Date对象计算除了console.time()还可以用console.log配合Date对象计算 1234567891011121314151617181920212223var beginTime = +new Date(); for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125; &#125;var endTime = +new Date();console.log(\"排序用时共计\"+(endTime-beginTime)+\"ms\");//或者var beginTime = new Date().getTime() for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125; &#125;var endTime = new Date().getTime()console.log(\"排序用时共计\"+(endTime-beginTime)+\"ms\");//或者var beginTime = new Date().getTime() for (var i = 0; i &lt; 1000; i++) &#123; for (var j = 0; j &lt; 1000; j++) &#123;&#125; &#125;var endTime = new Date().getTime()console.log(\"排序用时共计\"+(endTime-beginTime)+\"ms\"); 那么你肯定会问这三者的的区别 Date.now()与 new Date().getTime() 的区别它们都可以获取时间戳，但是实际上性能是不一样的（虽然差别不大，但是也算是一种性能的追求），可以做个测试 12345678910111213141516171819202122console.time('+new Date()')for(var i = 0; i &lt; 100000; i++) &#123; var o = + new Date()&#125;console.timeEnd('+new Date()')console.time('new Date().getTime:')for(var j = 0; j &lt; 100000; j++) &#123; var p = new Date().getTime();&#125;console.timeEnd('new Date().getTime:')console.time('Date.now()')for(var k = 0; k &lt; 100000; k++) &#123; var q = Date.now()&#125;console.timeEnd('Date.now()') //输出+new Date(): 42.31396484375msnew Date().getTime:: 33.93408203125msDate.now(): 24.561767578125ms 测试用例[https://jsperf.com/date-now-vs-new-date] profile使用console.profile测试程序性能 开发中，我们常常要评估段代码或是某个函数的性能。在函数中手动打印时间固然可以，但显得不够灵活而且有误差。借助控制台以及console.profile()方法我们可以很方便地监控运行性能。 1234567891011121314151617function parent() &#123; for (var i = 0; i &lt; 10000; i++) &#123; childA() &#125;&#125;function childA() &#123; for (var i = 0; i &lt; 2000; i++) &#123;&#125;&#125;console.profile('性能分析');parent();console.profileEnd('性能分析');//执行后//Profile '性能分析' started.//Profile '性能分析' finished.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"性能测试","slug":"性能测试","permalink":"http://yoursite.com/tags/性能测试/"}]},{"title":"前端性能优化一:性能指标","slug":"前端性能优化一-性能指标","date":"2019-09-16T02:27:35.000Z","updated":"2019-09-17T08:08:30.841Z","comments":true,"path":"2019/09/16/前端性能优化一-性能指标/","link":"","permalink":"http://yoursite.com/2019/09/16/前端性能优化一-性能指标/","excerpt":"","text":"前言如果我们想要提高我们的前端性能,那么首先你得先只知道怎么测量你的前端性能。但是哪些前端的性能指标我们应该关注呢?在Web1.0时代当我们讨论到前端性能指标用的最多的就是page load time。到了单页应用程序越来越多的时代,单一的page load time指标已经无法完全衡量前端性能了,因为一个单页应用程序page load time可能只触发了一次,但是用户会跟程序有很多的交互,每一个交互或者动作都需要有指标来衡量他的性能。 接下来就介绍几个比较重要的前端性能指标: first paint (FP):这个指标标志着浏览器渲染第一个像素点的时间 first contentful paint (FCP):和FP标志着任意一个像素点被渲染的时间不同,FCP标志着浏览器渲染第一个内容元素的时间,这些内容元素可以是text,image,SVG,canvas. 这两个指标对用户来说都是很重要的,这两个指标可以认为我们程序正在告诉我们的用户:我们正在正确工作。 First meaningful paint (FMP):这个指标标志着首屏最重要的一块区域的渲染,通常是用户最关注的区域。比如视频网站的视频播放区域,搜索网站的第一个搜索结果区域,又或者是购物网站的照片首图。通常来说浏览器很难清楚的了解哪一块是对于网站首屏来说是最关键的,所以开发者自己来告诉浏览器是哪一块是关键区域是很有必要的。 这也是非常关键的一个指标,通常如果用户能够快速的看到最重要的一块区域被渲染完成,即使其他的区域都还没有被渲染用户可能也不会注意到。 long task:我们都知道浏览器是单线程的在响应用户的操作时通过在任务队列里面增加任务,然后一个个的执行的.这意味着如果我们有一个长任务需要使用较长的时间,那么队列中的其他任务就只能等待,响应用户的操作就会变慢,或者动画就会变卡顿。","categories":[],"tags":[]},{"title":"javascript中的Map","slug":"javascript中的Map","date":"2019-08-26T02:53:41.000Z","updated":"2019-09-03T07:09:14.691Z","comments":true,"path":"2019/08/26/javascript中的Map/","link":"","permalink":"http://yoursite.com/2019/08/26/javascript中的Map/","excerpt":"","text":"探究javascript Map什么是Map，此处说的Map，非js中的map( )方法,下文会详细解释。Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。ECMAScript6原生实现了Map类，即我们所说的字典，字典和集合很像，不过集合是以值值得形式存储元素，字典则是以键值的形式存储元素。字典也叫映射。 语法1new Map([iterable]) iterable (可迭代传参)Iterable 可以是一个数组或者其他 iterable 对象，其元素为键值对(两个元素的数组，例如: [[ 1, ‘one’ ],[ 2, ‘two’ ]])。 每个键值对都会添加到新的 Map。null 会被当做 undefined。 描述一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个 for…of 循环在每次迭代后会返回一个形式为[key，value]的数组。 键的比较是基于 “SameValueZero” 算法：NaN 是与 NaN 相等的（虽然 NaN !== NaN），剩下所有其它的值是根据 === 运算符的结果判断是否相等。 Objects 和 Maps 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 Maps 使用。不过 Maps 和 Objects 有一些重要的区别，在下列情况里使用 Map 会是更好的选择： 一个Object的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值，包括函数、对象、基本类型。 Map 中的键值是有序的，而添加到对象中的键则不是。因此，当对它进行遍历时，Map 对象是按插入的顺序返回键值。 你可以通过 size 属性直接获取一个 Map 的键值对个数，而 Object 的键值对个数只能手动计算。 Map 可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。 Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然 ES5 开始可以用 map = Object.create(null) 来创建一个没有原型的对象，但是这种用法不太常见。 Map 在涉及频繁增删键值对的场景下会有些性能优势。 最大的差别其实就是：object的键的类型是 字符串；map的键的类型是 可以是任意类型;object获取键值使用Object.keys（返回数组）；Map获取键值使用 map变量.keys() (返回迭代器)。 属性 Map.length get Map[@@species] Map.prototype Map 实例*属性Map.prototype.constructor返回一个函数，它创建了实例的原型。默认是Map函数。 Map.prototype.size返回Map对象的键/值对的数量。 *方法Map.prototype.clear()移除Map对象的所有键/值对 。 Map.prototype.delete(key)如果 Map 对象中存在该元素，则移除它并返回 true；否则如果该元素不存在则返回 false Map.prototype.entries()返回一个新的 Iterator 对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 Map.prototype.forEach(callbackFn[, thisArg])按插入顺序，为 Map对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。 Map.prototype.get(key)返回键对应的值，如果不存在，则返回undefined。 Map.prototype.has(key)返回一个布尔值，表示Map实例是否包含键对应的值。 Map.prototype.keys()返回一个新的 Iterator对象， 它按插入顺序包含了Map对象中每个元素的键 。 Map.prototype.set(key, value)设置Map对象中键的值。返回该Map对象。 Map.prototype.values()返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的值 。 Map.prototype@@iterator返回一个新的Iterator对象，它按插入顺序包含了Map对象中每个元素的 [key, value] 数组。 实例使用 Map 对象12345678910111213141516171819202122var myMap = new Map(); var keyObj = &#123;&#125;, keyFunc = function () &#123;&#125;, keyString = \"a string\"; // 添加键myMap.set(keyString, \"和键'a string'关联的值\");myMap.set(keyObj, \"和键keyObj关联的值\");myMap.set(keyFunc, \"和键keyFunc关联的值\"); myMap.size; // 3 // 读取值myMap.get(keyString); // \"和键'a string'关联的值\"myMap.get(keyObj); // \"和键keyObj关联的值\"myMap.get(keyFunc); // \"和键keyFunc关联的值\" myMap.get(\"a string\"); // \"和键'a string'关联的值\" // 因为keyString === 'a string'myMap.get(&#123;&#125;); // undefined, 因为keyObj !== &#123;&#125;myMap.get(function() &#123;&#125;) // undefined, 因为keyFunc !== function () &#123;&#125; 使用 for..of 方法迭代 Map12345678910111213141516171819202122var myMap = new Map();myMap.set(0, \"zero\");myMap.set(1, \"one\");for (var [key, value] of myMap) &#123; console.log(key + \" = \" + value);&#125;// 将会显示两个log。一个是\"0 = zero\"另一个是\"1 = one\"for (var key of myMap.keys()) &#123; console.log(key);&#125;// 将会显示两个log。 一个是 \"0\" 另一个是 \"1\"for (var value of myMap.values()) &#123; console.log(value);&#125;// 将会显示两个log。 一个是 \"zero\" 另一个是 \"one\"for (var [key, value] of myMap.entries()) &#123; console.log(key + \" = \" + value);&#125;// 将会显示两个log。 一个是 \"0 = zero\" 另一个是 \"1 = one\" 使用 forEach() 方法迭代 Map1234myMap.forEach(function(value, key) &#123; console.log(key + \" = \" + value);&#125;)// 将会显示两个logs。 一个是 \"0 = zero\" 另一个是 \"1 = one\" Map 与数组的关系123456789101112var kvArray = [[\"key1\", \"value1\"], [\"key2\", \"value2\"]];// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象var myMap = new Map(kvArray);myMap.get(\"key1\"); // 返回值为 \"value1\"// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组console.log(Array.from(myMap)); // 输出和kvArray相同的数组// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组console.log(Array.from(myMap.keys())); // 输出 [\"key1\", \"key2\"] 复制或合并 Maps12345678var original = new Map([ [1, 'one']]);var clone = new Map(original);console.log(clone.get(1)); // oneconsole.log(original === clone); // false. Useful for shallow comparison 请记住，数据本身未被克隆。 Map对象间可以进行合并，但是会保持键的唯一性。 123456789101112131415161718var first = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);var second = new Map([ [1, 'uno'], [2, 'dos']]);// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。// 展开运算符本质上是将Map对象转换成数组。var merged = new Map([...first, ...second]);console.log(merged.get(1)); // unoconsole.log(merged.get(2)); // dosconsole.log(merged.get(3)); // three Map对象也能与数组合并： 1234567891011121314151617var first = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);var second = new Map([ [1, 'uno'], [2, 'dos']]);// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。var merged = new Map([...first, ...second, [1, 'eins']]);console.log(merged.get(1)); // einsconsole.log(merged.get(2)); // dosconsole.log(merged.get(3)); // three 以上讲的是Map，那不得不说map( )是什么ECMAScript5中我们有一个数组方法 map( ),区别于ECMAScript6 中 Map类map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 语法1var new_array = array.map(function callback(currentValue,index,arr), thisValue) 参数callback 生成新数组元素的函数，使用三个参数： currentValue callback 数组中正在处理的当前元素。 index可选 callback 数组中正在处理的当前元素的索引。 array可选 callback map 方法被调用的数组。 thisArg可选 执行 callback 函数时使用的this 值。 示例1234var array1 = [1,3,6];const map1 = array1.map(x =&gt; x *2);console.log(map1); // &gt; Array [2, 6, 12] 1234567891011var array1 = [1, 3,6];const map1 = array1.map(x =&gt; &#123; if (x == 3) &#123; return x * 2; &#125;&#125;); console.log(map1);// &gt; Array [undefined, 6, undefined] 出现undefined ：只是增加了一个条件，即x的值为3时才乘以2，之所以会出现undefined，是因为map()方法创建了一个新数组，但新数组并不是在遍历完array1后才被赋值的，而是每遍历一次就得到一个值。所以，下面这样修改后就正确了 123456789101112var array1 = [1, 3,6];const map1 = array1.map(x =&gt; &#123; if (x == 3) &#123; return x * 2; &#125; return x&#125;); console.log(map1);// &gt; Array [2, 6, 12] 可以使用 map 重新格式化数组中的对象 12345678910111213141516var oldArray = [&#123;key: 1, value: 10&#125;, &#123;key: 2, value: 20&#125;, &#123;key: 3, value: 30&#125;];var nowArr = oldArray.map(function(obj) &#123; var rObj = &#123;&#125;; rObj[obj.key] = obj.value; return rObj;&#125;);// nowArr 数组为： [&#123;1: 10&#125;, &#123;2: 20&#125;, &#123;3: 30&#125;], // oldArray 数组未被修改: // [&#123;key: 1, value: 10&#125;, // &#123;key: 2, value: 20&#125;, // &#123;key: 3, value: 30&#125;] 用ES5模拟实现ES6中的Map类与Set类一样，我们用Object的实例而不是数组存储元素,我们实现以下方法：1.set(key,value):向字典中添加新元素。 2.remove(key):使用键名从字典中移除相应的元素。 3.has(key):如果某个键值存在于字典中，返回true，否则返回false。 4.get(key):通过键名找到指定的值并返回。 5.clear():清空字典。 6.size():返回字典中元素个数。 7.values():将字典所有值以数组形式返回。 8.getItems():返回items变量，代表字典本身。 1234567891011121314151617181920212223242526272829303132333435363738function Map() &#123; var items = &#123;&#125;; this.has = function(key)&#123; //has方法判断某个键值是否在字典中 return key in items; &#125;, this.set = function(key,value)&#123; //set方法为字典添加新元素或更新已有元素 items[key] = value; &#125;, this.remove = function(key)&#123; if (this.has(key)) &#123; delete items[key]; return true; &#125; return false; &#125;, this.get = function(key)&#123; return this.has(key)?items[key]:undefined; &#125;, this.values = function()&#123; var values = []; //for...in会遍历出对象原型上的属性，所以要this.hasOwnProperty()方法选出对象自身的属性。 for(var k in items)&#123; if (this.hasOwnProperty(k)) &#123; values.push(items[k]); &#125; &#125; return values; &#125;, this.clear = function()&#123; items = &#123;&#125;; &#125;, this.size = function()&#123; return Object.Keys(items).length; &#125;, this.getItems = function()&#123; return items; &#125;&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"如何为平台设计一个插件系统","slug":"如何为平台设计一个插件系统","date":"2019-08-25T04:19:13.000Z","updated":"2019-09-03T07:09:14.693Z","comments":true,"path":"2019/08/25/如何为平台设计一个插件系统/","link":"","permalink":"http://yoursite.com/2019/08/25/如何为平台设计一个插件系统/","excerpt":"","text":"随着web浏览器的发展,浏览器的性能越来越好,WebGL和WebAssembly提供越来越多的可能性。很多原本只能在终端运行的程序都开始开发web版本例如CAD的web版本,PS的web版本,figma。这一个个的设计协作平台原本在终端都有插件机制。那么如果在web端能提供一个插件机制,对于有一点编程能力的用户,就可以提供更好的用户体验和开发更多的可能性。如何开发一个好的插件系统呢? 一个javascript的插件系统需要满足以下几个方面: 安全性 插件不可以发送请求 插件和程序模块不可以非法的调用相互的数据 插件不可以在不受约束的情况下执行 插件不可以任意的修改UI,从而给用户造成误导 稳定性 插件不能影响主程序的稳定性 插件不可以修改主程序中的常量 易开发性 插件应该是容易开发的,即使是面对没有那么多编程经验的设计师,也应该是容易开发的。 插件要可以使用调试工具。 效率 插件的执行效率不能太慢从而影响整个主程序的效率。 方案一:iframe沙盒实现方式当我们在程序中执行第三方的代码的时候,首先第一个应该会想到的就是iframe。iframe不是我们每天都会用到的html标签。要理解为什么iframe为什么安全，我们有不要想一下iframe标签是用来干什么的。 iframe比较典型的使用场景就是在一个网页中嵌入一个其他的网页。举个例子来说,你需要在网站中嵌入谷歌地图的页面来实现地图的展现功能。你不会希望谷歌地图的页面中的代码有能力访问你本身的一些代码和敏感数据,相应的谷歌地图也不希望你能够访问他页面中的数据和代码。 这意味着一切和iframe的交互都受限于浏览器。当iframe和原网页有不同的域(imow.cn和google.com),他们是完全隔绝的。那么网页和iframe交互的唯一办法就是通过 postMessage。这个message是一个string。需要交互的双方可以选择忽略这个message或者做对应的动作。 iframe和原网页是完全独立的,其实,如果你想要的话浏览器允许我们通过另外一个线程来创建一个iframe。这里. 当我们了解了iframe是如何工作了以后,我们可以在我们需要执行第三方插件的时候创一个iframe，将插件的代码在iframe中执行。在iframe中插件可以执行任何代码,也不会影响到主程序,除非通过提前申明好的message。同时我们可以给iframe的域名设置为null,这意味着根据浏览器跨域保护策略,iframe无法给域名发送任何请求。 iframe就这样很简单的成为我们执行第三方插件的沙盒环境,他的安全性也通过浏览器来保证。插件在沙盒中执行,通过主程序提供的api(postMeassge)和主程序进行交互。代码就像下面这个样子 12345678const scene = await main.loadScene() // 从主程序获取界面数据scene.selection[0].width *= 2 // 修改界面数据scene.createNode(&#123; type: 'RECTANGLE', x: 10, y: 20, ...&#125;)await main.updateScene() // 向主程序发送修改后的界面数据 这里主要的代码是loadScene(发送消息给主程序,然后获得主程序界面的document拷贝),然后修改完以后通过调用updateScene(发送更新消息给主程序).这里需要注意的是 我们拷贝了整个document而不是在每次需要读取或者修改属性的时候通过message传输.postMessage每次传输需要0.1ms.每秒钟大约只允许1000 messages。 我们没有让插件直接使用postMessage api,而是包装了一个api给插件用户使用,这样使用起来不会太笨重。 问题#1:async/await 使用起来不是那么方便这种实现方式第一个问题就是对于一些不那么了解javascript的新手或者设计师来说,async/await关键字还是非常陌生的。但是要使用postMessge是一个异步操作。所以不可避免的要使用async/await来控制异步流程。但是如果只是需要在开头和结束的时候调用我们的api还方便,我们可以告诉用户在调用我们的api时候在前面加上async/await即使他们不知道这个关键字的作用也不会对他们的操作造成非常大的困扰。 但是问题是有些插件需要执行非常复杂的逻辑,在修改一个layout的属性的时候有时候会引起其他好几个layout的更新。比如更新外层的layout的属性之后,内部的layout的属性也可能发生了更新,这个时候你需要先提交你的属性,然后在重新或者视图的属性,那这个时候你的代码就会变成这样: 123456789await mian.loadScene()... 操作 ...await mian.updateScene()await mian.loadScene()... 操作 ...await mian.updateScene()await mian.loadScene()... 操作 ...await mian.updateScene() 这个代码一下子就变的不可控了,而且用户也很难确认什么时候应该要提交我的属性更新。 问题#2:拷贝视图给iframe的操作是非常昂贵的iframe这种实现方式的第二个问题就是,当你需要给插件发送视图信息的时候你需要序列化你的document发送给你iframe，当你的视图非常非常大的时候,这个序列化的操作是非常耗时的,甚至会导致内存溢出。即使我们可以使用增量的加载数据或者懒加载数据这种方式仍然有他的问题: 首先这种方式是非常难实现的,即使有比较好的方案实现了以后,面对比较大的视图,性能仍然不是很理想,而且对于插件开发者来说是非常难理解的，这违背了我们的插件易开发性。 异步方法需要等待你需要到的数据达到才能开始后面的操作,对于异步流程控制来说也是一个挑战(steam? Rx?)。 总的来说如果你的主程序有非常大的document要交给第三方插件来进行操作,那么iframe的这种实现方式就不是非常理想的解决方案 eval如果能在主线程上执行插件代码,那么在性能上就会好很多,但是我们又不能简单的eval(code)执行插件代码,因为这样是很不安全的。 什么导致eval不安全如果我们退一步想:是什么使eval方法不安全?如果我们只是执行一段很单纯的代码 12let code = 'let a = (7 + 1) * 8;'eval(code) 如果只是一段逻辑代码,那么这个代码是没有什么不安全的。之所以认为eval执行的代码不安全是因为在插件代码中有可能会发送网络请求,修改全局的state变量,或者直接修改dom对象等等这些使得我们的插件代码变的不可控,换句话来说是插件具有浏览器api访问的能力让我们插件的代码变的不可控。 是不是能把全局的对象藏起来?如果我们能把全局的对象藏起来,保证插件代码中只能做变量的赋值或者一些if判断的逻辑代码,没有了全局对象xhr,插件将无法发送请求,没有document对象,插件也不具备访问dom的能力,那么插件能力是不是能在我们的可控范围里面了。 隐藏全局对象,理论上是可行的。但是我们很难仅仅通过隐藏全局对象来创建一个绝对安全的运行环境。举例来说,我们现在把window对象设置为null,但是代码还是可以通过({}).constructor来访问全局对象。所以找到所有有可能访问危险api的对象,把所有的路全部堵死是非常难的一件事情。 是不是我们可以找到一个这些全局对象从一开始就不存在的沙盒环境? 方案二:将javascript编译成WebAssemblyDuktape是一个轻量级的用c++写的javascript解释器,他可以将javascript编译成WebAssembly,经过test262测试之后,可以确定他全面的支持了ES5的语法。 这种实现方法有以下几种优缺点 首先这是一种安全的执行环境,因为Duktape不支持任何的浏览器API。作为WebAssembly执行,他本身就是一个沙盒环境,他可以通过提供一个白名单的API和主程序进行交互。 这个解释器是运行在主线程上的。这意味着我们可以创建一个基于主线程的API。(共享document等) 他可能会比原本的javascript慢一些,因为JIT解释器在编译的时候做了很多的优化,但是作为WebAssembly我相信这个性能应该也是可以被接受的。 他需要用浏览器来编译WebAssembly,这会有一些性能消耗。 浏览器的调试工具就不能用了。 看起来好像不错，但是他作为一个线上项目的表现到底怎么样呢?一个javascript引擎来执行另外一个引擎?WebAssembly本身也是比较新的一个东西，我们是不是真的需要一个相对复杂的解决方案?有没有更简单的方法了? 方案三:Realms这个技术可以创建一个沙盒环境来支持插件,当我看到他readme文档的时候,就一下子提起了我的兴趣,Intuitions sandbox iframe without DOM principled version of Node’s ‘vm’ module sync Worker 这不就是我们需要的吗?他的代码看起来是这个样子 123456789let g = window; // outer globallet r = new Realm(); // root realmlet f = r.evaluate(\"(function() &#123; return 17 &#125;)\");f() === 17 // trueReflect.getPrototypeOf(f) === g.Function.prototype // falseReflect.getPrototypeOf(f) === r.global.Function.prototype // true 是不是很酷。这个技术其实可以用现在已有的但是不常用的一个javascript功能来实现。代码想这样 123456function simplifiedEval(scopeProxy, code) &#123; 'use strict' with (scopeProxy) &#123; eval(code) &#125;&#125; 这个就像一个简单版本的Realms,但是管中窥豹,我们可以看见两个关键代码with和Proxy对象。 with(obj)表达式创建了一个作用域,当寻找变量的时候,可以使用这个obj的属性.看个例子: 123456with (Math) &#123; a = PI * r * r x = r * cos(PI) y = r * sin(PI) console.log(x, y)&#125; 在这个例子里,当我们访问PI,cos,sin的时候,就会找到Math的属性。但是console因为Math没有就仍然会找到全局对象。 知道了with表达式,接下来就是Proxy对象,这个对象有下面几个特性 他是一个普通的javascript对象,可以通过obj.x访问对象的属性值. 我们可以实现一个对象属性的get方法来实现obj.x操作,实际上只执行这个get方法. 123456789const scopeProxy = new Proxy(whitelist, &#123; get(target, prop) &#123; // target === whitelist if (prop in target) &#123; return target[prop] &#125; return undefined &#125;&#125; 接下来我们就可以把这个scopeProxy对象作为参数传入with中,他就捕获作用域所有的变量查找,在这个scopeProxy的get方法中进行查找这个变量: 1234with (scopeProxy) &#123; document // undefined! eval(\"xhr\") // undefined!&#125; 这里只有whitelist的属性会被返回,其他都会返回undefined.但是其实利用一些类似({}).constructor表达式还是有可能访问全局对象的.此外,这个沙盒其实还是需要访问一些全局对象的方法的,类似Object.keys 为要给我们的插件系统访问受限全局api的方法然后又不会把window搞乱,Realms沙盒通过创建一个和主程序同源的iframe用来拷贝需要用到的全局API。这个iframe和我们第一种实现中创建的iframe不一样,他不是作为运行程序的沙盒。当你创建一个和主程序同源的iframe以后 他会拷贝一份分开的全局对象(比如:Object.prototype)。 这些全局对象可以从父文档中访问,也就是说我们可以在Realms访问这些全局对象. 我们将这些全局对象放入到Proxy的白名单(whitelist)中，这样在插件代码中就可以访问这些全局对象了。通过创建iframe来拷贝全局对象有一个很重要的好处:即使是通过({}).constructor对象访问到的全局对象,也会是iframe中拷贝的全局对象。这样的实现方式有这些优点: 他在主程序中运行。 因为他本身还是javascript,所以他仍然用JIT编译解析,浏览器对javascript的优化还是有效。 浏览器开发工具也还是有效的。 那么就剩下最后一个问题.他真的够安全了吗? 这样看起来结合了iframe的Realms看起来似乎已经挺不错的了,而且他本身也是tc39下面的项目,所以可靠性应该也不错。但是光有一个安全的沙盒环境是不够的,你的插件肯定需要和主程序进行交互,那么我们就肯定要为我们的插件系统提供API,提供给插件的API系统也一定要是安全的。 举个例子,console.log是浏览器的api是不是javascript功能,那么我们要为插件系统提供一个console.log方法,我们可以这样写: 1realm.evaluate(USER_CODE, &#123; log: console.log &#125;) 或者为了隐藏方法本身,我们可以要求他只传参数 1realm.evaluate(USER_CODE, &#123; log: (...args) =&gt; &#123; console.log(...args) &#125; &#125;) 看起来是这么回事,很可惜,这其实是一个安全漏洞,即使是第二种方法我们还是在Realms外面创建了一个匿名方法,然后直接传入到Realms中。这意味着插件可以通过方法的原型链访问到外部。 正确创建console.log方法的方法是,将这个方法通过Realms包裹起来在Realms内部创建像这样 12345678910111213141516171819// 创建一个工厂方法// 这个工厂方法返回一个新的方法他保存一个闭包const safeLogFactory = realm.evaluate(` (function safeLogFactory(unsafeLog) &#123; return function safeLog(...args) &#123; unsafeLog(...args); &#125; &#125;)`);// 创建一个安全的方法const safeLog = safeLogFactory(console.log);const outerIntrinsics = safeLog instanceof Function;const innerIntrinsics = realm.evaluate(`log instanceof Function`, &#123; log: safeLog &#125;);if (outerIntrinsics || !innerIntrinsics) throw new TypeError(); // 使用realm.evaluate(`log(\"Hello outside world!\")`, &#123; log: safeLog &#125;); 通常来说,在沙盒中不应该能够访问到外部的任何对象包括作用域。因为我们的插件和主程序运行在一个线程中，所以在提供api的时候要非常小心,特别是当你的api需要在realm内部操作外部对象的时候。这对于开发api的开发人员来说是不是有点太不友好了，一不小心就产生了安全隐患，(todo:完善起来)。 结论如果我们的主程序不是特别复杂而且庞大的话,第一种通过iframe的实现方式应该是最为简单的。 如果我们的主程序本身就是通过WebAssembly创建的例如CAD网页版,我们想第二种方式可能是比较适合他们的,或者他们提供更加优秀的基于WebAssembly的解决方案 最后一种方式如果我们能提供一种简单又安全的开发API的办法,这应该是一种性价比比较高的解决方案。","categories":[],"tags":[]},{"title":"call apply bind的区别和用法","slug":"call apply bind的区别和用法","date":"2019-08-22T00:49:23.000Z","updated":"2019-09-03T07:09:14.689Z","comments":true,"path":"2019/08/22/call apply bind的区别和用法/","link":"","permalink":"http://yoursite.com/2019/08/22/call apply bind的区别和用法/","excerpt":"","text":"前言在JavaScript中，call、apply和bind是Function对象自带的三个方法，它们最主要的作用是改变 this 的指向。在平时的工作中，除了在写一些基础类，或者公用库方法的时候会用到它们，其他时候 call 和 apply 的应用场景并不多。 call和applay的共同点它们的共同点是，都能够改变函数执行时的上下文，将一个对象的方法交给另一个对象来执行，并且是立即执行的。 为何要改变执行上下文？举一个生活中的小例子：平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。 改变执行上下文也是一样的，A 对象有一个方法，而 B 对象因为某种原因，也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？当然是借用 A 对象的啦，既完成了需求，又减少了内存的占用。 另外，它们的写法也很类似，调用 call 和 apply 的对象，必须是一个函数 Function。 接下来，就会说到具体的写法，那也是它们区别的主要体现。 call和apply的区别它们的区别，主要体现在参数的写法上。先来看一下它们各自的具体写法。 call的写法 1Function.call(obj,[param1[,param2[,…[,paramN]]]]) 需要注意以下几点： 调用 call 的对象，必须是个函数 Function。 call 的第一个参数，是一个对象。 Function 的调用者，将会指向这个对象。如果不传，则默认为全局对象 window。 第二个参数开始，可以接收任意个参数。每个参数会映射到相应位置的 Function 的参数上。但是如果将所有的参数作为数组传入，它们会作为一个整体映射到 Function 对应的第一个参数上，之后参数都为空 1234567 function func (a,b,c) &#123;&#125;func.call(obj, 1,2,3)// func 接收到的参数实际上是 1,2,3func.call(obj, [1,2,3])// func 接收到的参数实际上是 [1,2,3],undefined,undefined applay的写法 1Function.apply(obj[,argArray]) 需要注意一下几点 它的调用者必须是函数 Function，并且只接收两个参数，第一个参数的规则与 call 一致。 第二个参数，必须是数组或者类数组，它们会被转换成类数组，传入 Function 中，并且会被映射到 Function 对应的参数上。这也是 call 和 apply 之间，很重要的一个区别。 12345678910func.apply(obj, [1,2,3])// func 接收到的参数实际上是 1,2,3func.apply(obj, &#123; 0: 1, 1: 2, 2: 3, length: 3&#125;)// func 接收到的参数实际上是 1,2,3 bind的使用bind()函数回创建一个新的函数(称为绑定函数) bind是ES5新增的一个方法 传参和call或apply类似 不会执行对应的函数，call或apply会自动执行对应的函数 返回对函数的引用 bind的写法 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，bind 方法的返回值是函数，并且需要稍后调用，才会执行。而 apply 和 call 则是立即调用。 举例说明： 12345678910 function add (a, b) &#123; return a + b;&#125;function sub (a, b) &#123; return a - b;&#125;add.bind(sub, 5, 3); // 这时，并不会返回 8add.bind(sub, 5, 3)(); // 调用后，返回 8 如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。 应用场景：继承 1234567891011121314151617181920 function Animal(name,weight)&#123; this.name = name; this.weight = weight;&#125;function Cat()&#123; // 在call中将this作为thisArgs参数传递 // Animal方法中的this就指向了Cat中的this // 所以Animal中的this指向的就是cat对象 // 在Animal中定义了name和weight属性，就相当于在cat中定义了这些属性 // cat对象便拥有了Animal中定义的属性，从而达到了继承的目的 Animal.call(this,&apos;cat&apos;,&apos;50&apos;); //Animal.apply(this,[&apos;cat&apos;,&apos;50&apos;]); this.say = function()&#123; console.log(&quot;I am &quot; + this.name+&quot;,my weight is &quot; + this.weight); &#125;&#125;//当通过new运算符产生了cat时，Cat中的this就指向了cat对象var cat = new Cat();cat.say();//输出=&gt; I am cat,my weight is 50 原型扩展在原型函数上扩展和自定义方法，从而不污染原生函数。例如：我们在 Array 上扩展一个 forEach 123456789101112131415function test()&#123; // 检测arguments是否为Array的实例 console.log( arguments instanceof Array, //false Array.isArray(arguments) //false ); // 判断arguments是否有forEach方法 console.log(arguments.forEach); // undefined // 将数组中的forEach应用到arguments上 Array.prototype.forEach.call(arguments,function(item)&#123; console.log(item); // 1 2 3 4 &#125;);&#125;test(1,2,3,4); 总结call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。 bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。 关于 call 和 apply 的便捷记忆法： 12345678910111213猫吃鱼，狗吃肉，奥特曼打小怪兽。有天狗想吃鱼了猫.吃鱼.call(狗，鱼)狗就吃到鱼了猫成精了，想打怪兽奥特曼.打小怪兽.call(猫，小怪兽)猫也可以打小怪兽了","categories":[],"tags":[]},{"title":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","slug":"cookie、localstorage和sessionstorage三者之间的区别以及使用方式","date":"2019-08-06T02:40:30.000Z","updated":"2019-09-03T07:09:14.690Z","comments":true,"path":"2019/08/06/cookie、localstorage和sessionstorage三者之间的区别以及使用方式/","link":"","permalink":"http://yoursite.com/2019/08/06/cookie、localstorage和sessionstorage三者之间的区别以及使用方式/","excerpt":"","text":"前言前端开发的时候，在网页刷新的时候，所有数据都会被清空，这时候就要用到本地存储的技术，前端本地存储的方式有三种，分别是cookie，localstorage和sessionStorage ，这是大家都知道的。 使用方式cookie： 保存cookie值 123var dataCookie=&apos;110&apos;; document.cookie = &apos;token&apos; + &quot;=&quot; +dataCookie; 获取指定名称的cookie值 1234567891011 function getCookie(name) &#123; //获取指定名称的cookie值// (^| )name=([^;]*)(;|$),match[0]为与整个正则表达式匹配的字符串，match[i]为正则表达式捕获数组相匹配的数组；var arr = document.cookie.match(new RegExp(&quot;(^| )&quot;+name+&quot;=([^;]*)(;|$)&quot;));if(arr != null) &#123; console.log(arr); return unescape(arr[2]);&#125;return null;&#125; var cookieData=getCookie(&apos;token&apos;); //cookie赋值给变量。 localStorage和sessionStorage：localStorage和sessionStorage所使用的方法是一样的, 下面以sessionStorage为例子： 1234567891011121314var name=&apos;sessionData&apos;;var num=120;sessionStorage.setItem(name,num);//存储数据sessionStorage.setItem(&apos;value2&apos;,119);let dataAll=sessionStorage.valueOf();//获取全部数据console.log(dataAll,&apos;获取全部数据&apos;);var dataSession=sessionStorage.getItem(name);//获取指定键名数据var dataSession2=sessionStorage.sessionData;//sessionStorage是js对象，也可以使用key的方式来获取值 console.log(dataSession,dataSession2,&apos;获取指定键名数据&apos;);sessionStorage.removeItem(name); //删除指定键名数据 console.log(dataAll,&apos;获取全部数据1&apos;); sessionStorage.clear();//清空缓存数据：localStorage.clear(); console.log(dataAll,&apos;获取全部数据2&apos;); 三者的异同：生命周期： cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效 localStorage：除非被手动清除，否则将会永久保存。 sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。 存放数据大小： cookie：4kb左右 localStorage和sessionStorage：可以保存5MB的信息 http请求： cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 应用场景：从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。 storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的。 localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。 浏览器的支持情况: localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。 cookie的浏览器支持没有找到，可以通过下面这段代码来判断所使用的浏览器是否支持cookie： 12345if(navigator.cookieEnabled) &#123; alert(&quot;你的浏览器支持cookie功能&quot;);//提示浏览器支持cookie &#125; else &#123; alert(&quot;你的浏览器不支持cookie&quot;);//提示浏览器不支持cookie &#125; 数据存放处： Cookie、localStorage、sessionStorage数据存放处 各浏览器Cookie大小、个数的限制 1. 浏览器允许每个域名所包含的cookie数： Microsoft指出InternetExplorer8增加cookie限制为每个域名50个，但IE7似乎也允许每个域名50个cookie。 Firefox每个域名cookie限制为50个。 Opera每个域名cookie限制为30个。 Safari/WebKit貌似没有cookie限制。但是如果cookie很多，则会使header大小超过服务器的处理的限制，会导致错误发生。 注：“每个域名cookie限制为20个”将不再正确！ 2. 当很多的cookie被设置，浏览器如何去响应： 除Safari（可以设置全部cookie，不管数量多少），有两个方法： 最少最近使用（leastrecentlyused(LRU)）的方法：当Cookie已达到限额，自动踢除最老的Cookie，以使给最新的Cookie一些空间。Internet Explorer和Opera使用此方法。 Firefox很独特：虽然最后的设置的Cookie始终保留，但似乎随机决定哪些cookie被保留。似乎没有任何计划（建议：在Firefox中不要超过Cookie限制）。 3. 不同浏览器间cookie总大小也不同： Firefox和Safari允许cookie多达4097个字节，包括名（name）、值（value）和等号。 Opera允许cookie多达4096个字节，包括：名（name）、值（value）和等号。 Internet Explorer允许cookie多达4095个字节，包括：名（name）、值（value）和等号。 注：多字节字符计算为两个字节。在所有浏览器中，任何cookie大小超过限制都被忽略，且永远不会被设置。最后：不要把什么数据都放在 Cookie、localStorage 和 sessionStorage中，毕竟前端的安全性这么低。只要打开控制台就可以任意的修改 Cookie、localStorage 和 sessionStorage的数据了。涉及到金钱或者其他比较重要的信息，还是要存在后台比较好。","categories":[],"tags":[]},{"title":"javascript垃圾回收机制","slug":"javascript垃圾回收机制","date":"2019-07-01T02:53:41.000Z","updated":"2019-09-03T07:09:14.692Z","comments":true,"path":"2019/07/01/javascript垃圾回收机制/","link":"","permalink":"http://yoursite.com/2019/07/01/javascript垃圾回收机制/","excerpt":"","text":"前言其实大多数的时候作为javascript开发者不需要太关心内存的使用和释放,因为所有的javascript环境都实现了各自的垃圾回收机制(garbage collector(GC)),但是随着现在的SPA越来越多也越来越大,越来越追求极致的性能渐渐也要求开发者能够适当的了解一些垃圾回收机制内部的实现原理,在性能优化和追踪内存泄漏的时候都能够起到一点帮助。看一段内存泄漏的代码 1234567891011121314151617181920var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var c = &apos;a&apos; function unused() &#123; if (originalThing) &#123; console.log(&quot;hi&quot;); &#125; &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(&apos;1111&apos;); &#125; &#125;;&#125;;setInterval(replaceThing,1000) 最早想要去深入了解javacript GC是看到这道找内存泄漏的题目(具体怎么内存泄漏,我们后面在分析).任何一种GC管理都需要做这几步: 识别哪些对象需要被回收。 回收/重复使用需要被回收对象的内存。 压缩/整理内存(有些可能没有) 而常见的识别对象是否需要回收的机制有下面几种: 引用计数 (Python) 逃逸分析 (Java) Tracing/Reachable 追踪分析 (javascript) 今天就主要看一下V8中GC的具体实现方式 Tracing/Reachable 追踪分析GC的第一步就是要找出哪些对象需要被回收,哪些不需要。在追踪分析(Tracing/Reachable)中,认为可以被追踪到(reachability)的对象认为是不能被回收的对象,剩下的不能被追踪到的对象就是要回收的对象。在V8中,追踪分析会从根对象开始(GC Root)根据指针将所有被能被追踪到的对象标记为reachable,javascript中根对象包括调用堆栈和global对象。 The Generational HypothesisGenerational Hypothesis的意思是大部分的对象在早期就需要被回收。基于这样的一个假设,有很多的编程语言的垃圾回收机制在设计的时候都是将内存分代,年轻代(young generation),和老代(old generation)。这里的代其实就是开辟两块space分别存储刚被分配的对象和经过两次GC还是没有被回收的对象。在V8中有两个垃圾回收器分别对年轻代和老代进行垃圾回收,Scavenger针对年轻代进行垃圾回收,Major GC针对老代进行垃圾回收,他们的算法也是不同的。 ScavengerV8在年轻代的内存space使用的是semi-space算法,也就是说将内存分为两半,同时只有一块的内存能被使用,另外一半是完全空的(或者说这一半内存都是可以被分配的)。在程序开始执行的时候,将所有的变量都分配可以被使用的一半内存中(叫做from-space)。当第一次GC开始的时候根据追踪分析结果,将所有可以reachable的对象(不能被释放的对象),全部转移到剩余一半可以被分配的内存中(to-space)，这样from-space中的内存又全部可以被分配了，这个时候如果又有新申明的对象需要分配内存,就会分配到这一块内存当中了,最后在转移完不能被释放的对象之后,还需要更新引用指针,指向在to-space中最新的地址。 第二次GC开始的时候,在原本的to-space中仍然不能被释放的对象首先转移到老代(old generation)的space中,这时候to-space中又全部可以被分配,重复之前的操作。从from-space中将不能被释放的对象转移过来。完成2次GC之后,存货了两次的对象现在就在老代里面了,而存活一次GC的对象现在就在to-space中了,这个to-space也被叫做intermediate generation(中生代).在Scavenger中回收内存有三个过程:标记(追踪分析),转移(from-space to to-space),更新指针地址。 第二次GC 在这种内存回收的机制中,其中一个问题就是转移对象的时候是会消耗一定性能的,但是根据Generational Hypothesis的假设大部分的对象在早期就会被回收了,这也就意味着只有少部分不能被回收的对象需要被移动，这也意味着如果这个假设不成立，比如我们的代码中有很多的闭包导致很多的作用域不能被释放,那么将会有大量的对象需要在space之间转移,是比较浪费性能的。但是相反的,基于大部分对象都可以在早期被回收的假设,如果大部分的对象在早期就可以被释放,这种机制的内存回收对这需要在早期就回收的对象其实是什么都不需要做的,只需要把不能释放的少部分对象进行转移（from-space to to-space）,然后在下次分配内存的时候把这部分需要释放的对象所占的内存直接覆盖就可以了(rewrite dead object)。 ParallelParallel是V8中调度线程进行内存回收的一种算法,指的是主线程和帮助线程同时进行相同工作量的内存回收,这种算法还是会停止主线程正在进行的全部工作,但是工作量被平摊到几个线程之后,理论上时间也被参与线程的数量整除了(加上一些同步调度的开销)。Scavenger就是使用的这种线程调度机制,当需要进行内存回收的时候,所有的线程获得一定数量的存活的对象引用指针,开始同时将这些存活对象搬运到to-space中。不同的线程可能通过不同引用路径访问到同一个对象,当线程将存活对象转移到to-space之后,更新完指针地址后,会在from-space的老对象中留下一个forwarding指针,这样其他线程找到这个对象之后就可以通过这个指针来找到新的地址更新引用地址了。 Scavenger平行调度,同时有多个帮助线程和主线程参与 Major GCMajor GC主要负责老代的内存回收,同样也是三个过程:标记(追踪分析),清除,整理压缩内存。标记这一步和Scavenger一样通过追踪分析确定哪些内存需要被回收,然后在对象被回收以后将被回收的内存加入到free-list这个数据结构中,free-list就像是一个个抽屉,每个抽屉的大小代表了从这个地址开始可以被连续分配的内存的大小,当我们需要在老代中重新分配内存的时候就可以快速的根据需要分配内存的大小找到一个合适的抽屉把内存进行分配。最后就是进行内存整理,这个就好像是Windows系统整理磁盘一样,将还没被幸存的对象利用free-list查找拷贝到其他的已经被整理完的page中,这样使小块的内存碎片也被整理完之后加以利用。跟Scavenger中一样来回拷贝对象也会有性能的消耗,在V8中只会对高度碎片化的page进行整理,对其他的page进行清除,这样在转移的时候也是一样的只需要转移存活的对象就可以了。 ConcurrentConcurrent同样也是V8中进行内存回收的线程调度算法,当主线程执行Javascript的时候,帮助线程同步进行内存回收的一些工作。相比Parallel来说这个算法要复杂的多,可能前一毫秒帮助线程在进行GC操作,后一毫秒主线程就改变了这个对象。也有可能帮助线程和主线程同时读取修改同一个对象。但是这种算法的优势就是当帮助线程进行GC工作的时候,主线程可以继续执行JavaScript,完全不会受到影响。Major GC就是采用的这个算法,当老代的内存到达一定系统自动计算的阀值,就开始进行Major GC,首先每个帮助线程都会获得一定数量的对象指针,开始针对这些对象进行标记,然后根据对象的引用指针对reachable对象都进行标记,在进行这些标记的同时,主线程仍然在执行JavaScript没有受到影响。当帮助线程完成标记,或者老代触及了设定的阀值,主线程也开始参与GC,他首先进行一步快速的标记确认,确保帮助线程在标记的同时主线程修改的对象标记正确(在帮助线程进行标记的时候,如果主线程执行的JavaScript修改了对象会有Write barriers,类似于有个标记)。当主线程确认所有存活的对象都被标记以后,主线程会和几个子线程一起,对一些内存page进行压缩和更新指针的工作,不是所有的page都需要进行压缩(只对高碎片化的进行压缩),不需要压缩的利用free-list进行打扫。 Major GC同步调度 什么时候会执行GC在JavaScript中我们没办法用编程的方式主动触发GC,因为涉及到复杂的线程调度,主动的触发GC可能会影响正在执行的GC或者下次的GC。对于Scavenger来说,当在新生代中分配内存时,已经没有空间分配内存导致分配内存失败时,开始Scavenger垃圾回收,希望能释放一些内存,然后在尝试重新分配内存。对于老代来说,开启内存回收的时机要复杂很多,简单来说会根据老代中内存占用的百分比和需要被分配对象的百分比计算出一个合适的阀值,触及到这个阀值就会开启老代的垃圾回收。 我们可以通过手动设置来设置新生代和老代的space大小: 12node --max-old-space-size=1700 index.jsnode --max-new-space-size=1024 index.js 空闲时GC虽然我们通过JavaScript没办法主动触发GC,但是在V8中还有一个空闲GC的机制,他根据被嵌入宿主来决定什么时候属于空闲时来执行GC。比如V8在Chrome浏览器中,为了保证动画渲染的流畅,一秒钟需要渲染60个帧,相当于16.6毫秒渲染一帧,在16.6毫秒以内渲染完了一帧,比如只花了10毫秒就渲染完了这一帧的动画,那么你就有了6.6毫秒的空闲时间可以执行一些空闲时的GC(在许多新版本的浏览器中,开发者也可以通过requestIdleCallback事件,利用浏览器空闲时间来提高性能,有兴趣的可以去了解React 16 fiber的实现)。 利用主线程空闲时间进行GC Incremental那么在空闲的几毫秒时间里能完成一次GC吗?那就是接下来就要介绍另外一种调度算法Incremental了,相比较于其他调度算法在暂停一次主线程执行一整次完成的GC,Incremental要求把一整个GC中的工作拆成一小块,和主线程中的JS递进的执行,或者在主线程有空闲时间的时候执行一小块GC任务。 将一整个GC切分成一小块GC任务,插入到主线程中进行 总结不同JavaScript引擎实现GC都有不同程度的差异,本文主要以V8为例,有很多地方没有非常仔细的展开,比如：其实老代里面不是只有一块space,而是有4块space组成,每块space存放着不同的数据(old space,large object space,matedata space,code space)。垃圾回收设计本身就是一个很复杂的程序,有了GC,让开发者可以完全不用担心内存的管理问题。但是适当的了解垃圾回收的原理能够帮助我们更加深入的理解JavaScript的运行环境,也可以帮助我们写出更高效率的代码。 最后的最后将之前的内存泄漏代码一步步的推演: 首先在全局作用域中声明了两个变量theThing和replaceThing,其中replaceThing被赋值为一个方法(callable object),然后调用setInterval方法,每隔1000毫秒调用一次replaceThing。 1000毫秒到了,执行replaceThing,创建一个新的局部作用域,根据hoist,先将方法unused方法声明,然后声明了originThing和c变量。这里特别要注意,闭包是在方法声明的时候被创建的而不是在方法执行的时候创建的,所以当声明了unused方法以后,同时创建了一个闭包,里面包含了unused方法使用的局部作用域变量originThing。另外在V8中一旦作用域有闭包,这个上下文会被绑定到所有方法当中作为闭包,即使这个方法没有使用这个作用域中的任何一个变量,所以在这里给全局作用域赋值的时候,someMethod作为一个方法,也被绑定一个unused创建的闭包,且被赋值在全局作用域中的theThing上了。 如果这时候开始第一次GC,从全局对象进行Reachable分析:theThing(reachable),replaceThing(reachable),theThing-&gt;longStr(reachable),theThing-&gt;someMethod(reachable),execution stack -&gt; setInterval -&gt; closure -&gt; originThing(reachable)。所有标记完成。此时: 123456789 from-space to-spacetheThing (reachable) theThingreplaceThing (reachable) replaceThingunused originThingoriginThing (reachable) =&gt; longStr c someMethodlongStr (reachable) someMethod (reachable) 在过1000毫秒以后又执行replaceThing,又执行一遍步骤2 第二次GC开始 123456789 from-space to-space old-spacetheThing (reachable) theThing originThing -&gt; theThingreplaceThing (reachable) replaceThing theThing -&gt; longStrunused originThing theThing -&gt; someMethodoriginThing (reachable) =&gt; longStr =&gt; someMethod -&gt; originThing(closure) c someMethodlongStr (reachable) someMethod (reachable) 因为闭包一直连着这originThing,导致了old-space中的originThing一直无法释放。随着时间的推移,每个1000毫秒执行一次replaceThing方法 123456 old-spaceoriginThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure)originThing -&gt; theThing -&gt; longStr &amp; someMethod -&gt; originThing(closure) 结论主要导致内存泄漏的原因是 闭包是在声明的时候被创建的,而不是执行的时候被创建的。 然后导致在originalThing还引用着老的theThing,theThing中的someMethod引用着originalThing导致全部都reachable无法释放。 12345678910111213141516171819202122var theThing = null;var replaceThing = function () &#123; var originalThing = theThing; var c = &apos;a&apos; function unused() &#123; if (originalThing) &#123; console.log(&quot;hi&quot;); &#125; &#125;; theThing = &#123; longStr: new Array(1000000).join(&apos;*&apos;), someMethod: function () &#123; console.log(&apos;1111&apos;); &#125; &#125;; originalThing = null; //手动释放局部作用域中的变量&#125;;setInterval(replaceThing,1000)","categories":[],"tags":[]},{"title":"==的隐式转换","slug":"==的隐式转换","date":"2019-04-28T01:13:40.000Z","updated":"2019-09-03T07:09:14.688Z","comments":true,"path":"2019/04/28/==的隐式转换/","link":"","permalink":"http://yoursite.com/2019/04/28/==的隐式转换/","excerpt":"","text":"前言==在js中用到的很多，大家都知道两个等于号只判断值，===值和类型都会判断，接下来我们就来看看==是如何判断的 1234567891011121314151617181920212223242526272829303132333435363738 对象 \\ 字符串 布尔值 \\ / 数值1. 对象和布尔值比较对象和布尔值进行比较时，对象先转换为字符串，然后再转换为数字，布尔值直接转换为数字[] == true; //false []转换为字符串'',然后转换为数字0,true转换为数字1，所以为false2. 对象和字符串比较对象和字符串进行比较时，对象转换为字符串，然后两者进行比较。[1,2,3] == '1,2,3' // true [1,2,3]转化为'1,2,3'，然后和'1,2,3'， so结果为true;3. 对象和数字比较对象和数字进行比较时，对象先转换为字符串，然后转换为数字，再和数字进行比较。[1] == 1; // true `对象先转换为字符串再转换为数字，二者再比较 [1] =&gt; '1' =&gt; 1 所以结果为true4. 字符串和数字比较字符串和数字进行比较时，字符串转换成数字，二者再比较。'1' == 1 // true5. 字符串和布尔值比较字符串和布尔值进行比较时，二者全部转换成数值再比较。'1' == true; // true 6. 布尔值和数字比较布尔值和数字进行比较时，布尔转换为数字，二者比较。true == 1 // true7. other来看一个有趣的题[] == false;![] == false;还有一些需要记住的，像：undefined == null //true undefined和null 比较返回true，二者和其他值比较返回falseNumber(null) //0","categories":[],"tags":[]}]}